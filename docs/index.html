

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Albert - Differential PyTorch Physics Engine for Testing Theories</title>
    
    <!-- Primary Meta Tags -->
    <meta name="title" content="Albert - Differential PyTorch Physics Engine for Testing Theories">
    <meta name="description" content="A PyTorch-based physics engine for testing and validating fundamental theories through differentiable simulations.">
    <meta name="keywords" content="physics engine, differential equations, gravitational theories, general relativity, experimental validation, PyTorch physics, differential physics, research tools">
    <meta name="author" content="Albert Project">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://albert.so/">
    <meta property="og:title" content="Albert - Differential PyTorch Physics Engine">
    <meta property="og:description" content="A PyTorch-based physics engine for testing and validating fundamental theories through differentiable simulations.">
    <meta property="og:image" content="https://albert.so/docs/sketch.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:site_name" content="Albert">
    
    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://albert.so/">
    <meta property="twitter:title" content="Albert - Differential PyTorch Physics Engine">
    <meta property="twitter:description" content="A PyTorch-based physics engine for testing and validating fundamental theories through differentiable simulations.">
    <meta property="twitter:image" content="https://albert.so/docs/sketch.png">
    
    <!-- Additional Meta Tags -->
    <meta name="robots" content="index, follow">
    <meta name="language" content="English">
    <meta name="revisit-after" content="7 days">
    <link rel="canonical" href="https://albert.so/">
    
    <!-- Favicon -->
    <link rel="icon" type="image/png" href="sketch.png">
    <link rel="apple-touch-icon" href="sketch.png">
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,700;1,400;1,500;1,700&family=Playfair+Display:ital,wght@0,400;0,700;1,400;1,700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true, theme: 'default' });
    </script>
    
    <!-- Tailwind Config -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        'serif': ['EB Garamond', 'Georgia', 'serif'],
                        'display': ['Playfair Display', 'serif'],
                        'mono': ['JetBrains Mono', 'monospace'],
                    },
                    colors: {
                        'white': '#FAF8F3',          // Override white to match paper
                        'ink': '#2D2D2D',           // Dark text
                        'paper': '#FAF8F3',          // Background
                        'accent': '#1A3A8A',         // Deep blue (primary)
                        'muted': '#8B7355',          // Brown (secondary)
                        'success': '#556B2F',        // Olive green (validation)
                        'danger': '#B91C1C',         // Deep red (errors)
                        'warning': '#D97706',        // Amber (in progress)
                        'quantum': '#059669',        // Emerald (quantum tests)
                        'extreme': '#7C3AED',        // Purple (extreme regime)
                        'canvas-bg': '#FAF8F3',      // Canvas backgrounds - same as paper
                        'canvas-stroke': '#E5E7EB',  // Canvas lines
                        'code-bg': '#FAF8F3',        // Code block background - same as paper
                        'code-border': '#E8E2D8',    // Code block border
                    }
                }
            }
        }
    </script>
    
    <style>
        /* Remove Aeonik font-face declarations */
        
        h1, h2, h3, h4, h5, h6 {
            font-family: 'Playfair Display', 'Georgia', serif;
        }
        
        body {
            font-family: 'EB Garamond', 'Georgia', serif;
        }
        
        /* Update formula-display to use new colors */
        .formula-display {
            @apply text-center text-accent bg-paper py-6 px-8 rounded-xl my-6 mx-auto;
            font-family: 'Times New Roman', 'Georgia', serif;
            font-size: 1.4rem;
            width: fit-content;
            min-width: 300px;
            box-shadow: 0 2px 8px rgba(26, 13, 171, 0.08);
            border: 1px solid rgba(26, 58, 138, 0.15);
            position: relative;
        }
        
        /* Update code-block colors */
        .code-block {
            @apply bg-code-bg text-ink border border-code-border;
            padding: 1.5rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.875rem;
            line-height: 1.6;
            white-space: pre-wrap;
        }
        
        .code-block .comment { @apply text-muted; }
        .code-block .string { @apply text-success; }
        .code-block .keyword { @apply text-accent; }
        .code-block .function { @apply text-ink; }
        
        html {
            scroll-behavior: smooth;
        }
        
        @keyframes pulse {
            0%, 100% { 
                opacity: 1; 
            }
            50% { 
                opacity: 0.6; 
            }
        }
        
        .pulse-animation {
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes gravitationalFloat {
            0%, 100% { 
                transform: translateY(0px) scale(1) rotateZ(0deg); 
            }
            20% { 
                transform: translateY(-2px) scale(1.008) rotateZ(0.2deg); 
            }
            40% { 
                transform: translateY(-3px) scale(1.01) rotateZ(-0.1deg); 
            }
            60% { 
                transform: translateY(1px) scale(0.995) rotateZ(0.15deg); 
            }
            80% { 
                transform: translateY(-1px) scale(1.003) rotateZ(-0.1deg); 
            }
        }
        
        @keyframes gravitationalPulse {
            0%, 100% { 
                transform: scale(1); 
                filter: brightness(1);
            }
            50% { 
                transform: scale(1.01); 
                filter: brightness(1.02);
            }
        }
        
        .gravitational-text {
            animation: gravitationalFloat 8s ease-in-out infinite;
        }
        
        .gravitational-pulse {
            animation: gravitationalPulse 4s ease-in-out infinite;
        }
        
        .glow {
            box-shadow: 0 4px 20px rgba(59, 130, 246, 0.3);
        }
        
        .non-interactive {
            pointer-events: none;
        }
        .interactive {
            pointer-events: auto;
        }
        
        body {
            background-color: #FAF8F3; /* colors.paper - Light cream matching sketch background */
        }
        
        /* New animations for the journey */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .animate-fadeIn {
            animation: fadeIn 1s ease-out;
        }
        
        /* Counting animation helper */
        .counting-animation {
            transition: all 2s ease-out;
        }
        
        /* Golden ratio spiral animation */
        @keyframes spiralRotate {
            from {
                transform: rotate(0deg);
            }
            to {
                transform: rotate(360deg);
            }
        }
        
        /* Scroll indicator bounce */
        @keyframes bounce {
            0%, 100% {
                transform: translateY(0);
            }
            50% {
                transform: translateY(-10px);
            }
        }
        
        /* Albert logo frame styling */
        .sketch-frame {
            position: relative;
            background: linear-gradient(135deg, 
                rgba(250, 248, 243, 0.9) 0%, 
                rgba(255, 255, 255, 0.95) 40%, 
                rgba(255, 255, 255, 0.95) 60%, 
                rgba(250, 248, 243, 0.9) 100%);
            box-shadow: 
                inset 0 1px 3px rgba(0, 0, 0, 0.06),
                0 4px 12px rgba(45, 45, 45, 0.08);
        }
        
        .sketch-frame::before {
            content: '';
            position: absolute;
            inset: -1px;
            background: linear-gradient(135deg, 
                transparent 30%, 
                rgba(26, 58, 138, 0.05) 50%, 
                transparent 70%);
            border-radius: 0.75rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .sketch-frame:hover::before {
            opacity: 1;
        }
        
        /* Vintage paper texture overlay */
        .sketch-paper {
            position: relative;
            background: 
                radial-gradient(ellipse at top left, rgba(232, 226, 216, 0.2) 0%, transparent 50%),
                radial-gradient(ellipse at bottom right, rgba(232, 226, 216, 0.2) 0%, transparent 50%),
                white;
            box-shadow: inset 0 1px 4px rgba(0, 0, 0, 0.04);
        }
        
        .sketch-paper::after {
            content: '';
            position: absolute;
            inset: 0;
            background-image: 
                repeating-linear-gradient(45deg, 
                    transparent, 
                    transparent 10px, 
                    rgba(232, 226, 216, 0.03) 10px, 
                    rgba(232, 226, 216, 0.03) 20px);
            border-radius: 0.5rem;
            pointer-events: none;
        }
        
        /* Mobile-specific styles */
        @media (max-width: 768px) {
            /* Hide animated hero section on mobile */
            #home {
                display: none !important;
            }
            
            /* Make Real-Time Theory Testing the first visible section */
            #journey {
                padding-top: 7rem !important; /* Account for nav (64px) + research notice (~48px) */
            }
            
            /* Ensure main content starts below fixed headers */
            main {
                padding-top: 7rem !important; /* Match the journey padding */
            }
            
            /* Fix header navigation on mobile */
            nav {
                padding: 0 0.5rem;
            }
            
            .sketch-frame {
                padding: 0.5rem !important;
            }
            
            .sketch-paper {
                padding: 0.25rem !important;
            }
            
            .sketch-frame img {
                height: 3rem !important;
            }
            
            /* Fix research notice spacing on mobile */
            .research-notice {
                padding: 0.5rem 1rem;
                font-size: 12px;
            }
            
            /* Improve mobile typography */
            h3.text-4xl {
                font-size: 1.875rem !important; /* text-3xl */
            }
            
            h3.text-5xl {
                font-size: 2.25rem !important; /* text-4xl */
            }
            
            .text-lg {
                font-size: 1rem !important;
            }
            
            /* Fix theory testing demo box on mobile */
            .grid.grid-cols-1.lg\\:grid-cols-2 {
                grid-template-columns: 1fr !important;
            }
            
            /* Einstein detail elements on mobile */
            #einstein-asymmetric-detail,
            #einstein-connection-detail,
            #einstein-field-detail {
                font-size: 0.75rem !important;
            }
            
            /* Adjust padding for mobile */
            .px-4, .px-6, .px-8 {
                padding-left: 1rem !important;
                padding-right: 1rem !important;
            }
            
            .py-20 {
                padding-top: 3rem !important;
                padding-bottom: 3rem !important;
            }
            
            /* Fix canvas containers on mobile */
            canvas {
                max-width: 100% !important;
                height: auto !important;
            }
            
            /* Hide non-essential animations on mobile */
            .gravitational-text {
                animation: none !important;
            }
            
            .gravitational-pulse {
                animation: none !important;
            }
            
            /* Fix modal on mobile */
            #setupModal .max-w-3xl {
                max-width: calc(100vw - 2rem) !important;
                margin: 1rem !important;
            }
            
            /* Improve button spacing on mobile */
            .flex.gap-6 {
                gap: 1rem !important;
                flex-direction: column !important;
            }
            
            .w-64 {
                width: 100% !important;
            }
            
            /* Fix code blocks on mobile */
            .code-block, pre {
                font-size: 0.75rem !important;
                padding: 1rem !important;
                white-space: pre-wrap !important;
            }
            

            
            /* Make validation visualizations responsive */
            #validationGauntletCanvas,
            #theoryEngineCanvas {
                height: 300px !important;
            }
        }
        
        /* Additional mobile improvements */
        @media (max-width: 640px) {
            /* Even smaller adjustments for very small screens */
            h3.text-4xl {
                font-size: 1.5rem !important;
            }
            
            h3.text-5xl {
                font-size: 1.875rem !important;
            }
            
            .text-2xl {
                font-size: 1.25rem !important;
            }
            
            /* Stack buttons vertically on very small screens */
            .flex.items-center.justify-center.gap-6 {
                flex-direction: column !important;
            }
            
            /* Full width install command on mobile */
            .max-w-3xl {
                max-width: 100% !important;
            }
        }
    </style>
</head>
<body class="text-ink antialiased bg-paper">

    <!-- Setup Modal -->
    <div id="setupModal" class="fixed inset-0 z-50 hidden">
        <!-- Backdrop -->
        <div class="absolute inset-0 bg-ink/70 backdrop-blur-sm" onclick="closeSetupModal()"></div>
        
        <!-- Modal Content -->
        <div class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-full max-w-3xl max-h-[80vh] overflow-y-auto">
            <div class="bg-paper rounded-2xl p-8 shadow-2xl border border-code-border">
                <!-- Close button -->
                <button onclick="closeSetupModal()" class="absolute top-4 right-4 text-muted hover:text-ink transition">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
                
                <h2 class="text-3xl font-bold text-accent mb-6">Quick Start Installation</h2>
                
                <div class="space-y-6">
                    <!-- One-line install -->
                    <div>
                        <h3 class="text-xl font-bold text-ink mb-2">One-Line Installation</h3>
                        <div class="relative group">
                            <div class="bg-code-bg rounded-lg border border-code-border hover:border-accent/50 transition-all overflow-hidden">
                                <div class="flex items-stretch">
                                    <div class="flex-1 p-4">
                                        <code id="modal-install-command" class="text-ink font-mono text-sm break-all select-all">curl -fsSL https://albert.so/install | bash</code>
                                    </div>
                                    <button 
                                        onclick="copyModalCommand()" 
                                        class="px-4 text-muted hover:text-accent hover:bg-accent/5 transition-all group-hover:text-accent border-l border-code-border flex items-center justify-center"
                                        title="Copy to clipboard"
                                    >
                                        <svg id="modal-copy-icon" class="w-5 h-5 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
                                        </svg>
                                        <svg id="modal-check-icon" class="w-5 h-5 hidden text-success flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                                        </svg>
                                    </button>
                                </div>
                            </div>
                            <div id="modal-copy-tooltip" class="absolute -top-10 right-0 bg-ink text-paper text-xs px-3 py-1 rounded opacity-0 pointer-events-none transition-opacity shadow-lg">
                                Copied to clipboard!
                            </div>
                        </div>
                    </div>
                    
                    <!-- Features -->
                    <div class="grid grid-cols-1 sm:grid-cols-3 gap-4">
                        <div class="flex items-center space-x-2">
                            <svg class="w-5 h-5 text-success flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path>
                            </svg>
                            <span class="text-sm text-ink">Pure Python</span>
                        </div>
                        <div class="flex items-center space-x-2">
                            <svg class="w-5 h-5 text-success flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path>
                            </svg>
                            <span class="text-sm text-ink">PyTorch powered</span>
                        </div>
                        <div class="flex items-center space-x-2">
                            <svg class="w-5 h-5 text-success flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path>
                            </svg>
                            <span class="text-sm text-ink">GPU accelerated</span>
                        </div>
                    </div>
                    
                    <!-- Quick Start Commands -->
                    <div>
                        <h3 class="text-xl font-bold text-ink mb-2">Basic Usage</h3>
                        <div class="bg-code-bg border border-code-border rounded-xl p-4 space-y-3 font-mono text-sm">
                            <div>
                                <span class="text-muted"># Run comprehensive evaluation on all theories</span>
                                <div class="text-accent">albert run</div>
                            </div>
                            <div>
                                <span class="text-muted"># Include experimental candidate theories</span>
                                <div class="text-accent">albert run --candidates</div>
                            </div>
                            <div>
                                <span class="text-muted"># Test a specific theory</span>
                                <div class="text-accent">albert run --theory-filter "MyTheory"</div>
                            </div>
                            <div>
                                <span class="text-muted"># Run with extended integration steps</span>
                                <div class="text-accent">albert run --max-steps 10000</div>
                            </div>
                            <div>
                                <span class="text-muted"># Run pre-flight solver validation tests</span>
                                <div class="text-accent">albert run --test</div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Available Commands -->
                    <div>
                        <h3 class="text-xl font-bold text-ink mb-2">Other Commands</h3>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
                            <div class="bg-code-bg/50 border border-code-border/50 rounded-lg p-3">
                                <div class="font-mono text-sm">
                                    <span class="text-accent">albert discover</span>
                                    <p class="text-xs text-muted mt-1">AI-assisted theory generation</p>
                                </div>
                            </div>
                            
                            <div class="bg-code-bg/50 border border-code-border/50 rounded-lg p-3">
                                <div class="font-mono text-sm">
                                    <span class="text-accent">albert setup</span>
                                    <p class="text-xs text-muted mt-1">Configure environment and API keys</p>
                                </div>
                            </div>
                            
                            <div class="bg-code-bg/50 border border-code-border/50 rounded-lg p-3">
                                <div class="font-mono text-sm">
                                    <span class="text-accent">albert validate</span>
                                    <p class="text-xs text-muted mt-1">Test a specific theory file</p>
                                </div>
                            </div>
                            
                            <div class="bg-code-bg/50 border border-code-border/50 rounded-lg p-3">
                                <div class="font-mono text-sm">
                                    <span class="text-accent">albert run-advanced</span>
                                    <p class="text-xs text-muted mt-1">Parameter sweeps and optimization</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Documentation Link -->
                    <div class="mt-6 pt-6 border-t border-code-border text-center">
                        <p class="text-sm text-muted mb-2">For detailed documentation and advanced options:</p>
                        <a href="documentation.html" class="text-accent hover:text-accent/80 font-semibold text-sm inline-flex items-center gap-2">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"></path>
                            </svg>
                            View Full Documentation
                        </a>
                    </div>
                    
                
                </div>
            </div>
        </div>
    </div>

    <!-- Navigation -->
    <nav class="fixed top-0 left-0 right-0 bg-paper/95 backdrop-blur-sm shadow-md z-40">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex items-center justify-between h-16">
                <div class="flex items-center">
                    <div class="sketch-frame p-2 rounded-xl border border-code-border/30 hover:shadow-[0_6px_20px_rgba(26,58,138,0.12)] transition-all duration-300 group">
                        <!-- Inner frame with vintage paper effect -->
                        <div class="sketch-paper rounded-lg p-1.5">
                            <img src="sketch.png" alt="Albert Einstein Sketch" class="h-16 w-auto filter contrast-110 brightness-98 sepia-[0.1] group-hover:contrast-120 group-hover:sepia-[0.15] transition-all duration-300 relative z-10">
                        </div>
                        <!-- Subtle corner accents - like old photo corners -->
                        <div class="absolute top-1 left-1 w-3 h-3 border-t-2 border-l-2 border-accent/15 rounded-tl-lg group-hover:border-accent/25 transition-colors"></div>
                        <div class="absolute top-1 right-1 w-3 h-3 border-t-2 border-r-2 border-accent/15 rounded-tr-lg group-hover:border-accent/25 transition-colors"></div>
                        <div class="absolute bottom-1 left-1 w-3 h-3 border-b-2 border-l-2 border-accent/15 rounded-bl-lg group-hover:border-accent/25 transition-colors"></div>
                        <div class="absolute bottom-1 right-1 w-3 h-3 border-b-2 border-r-2 border-accent/15 rounded-br-lg group-hover:border-accent/25 transition-colors"></div>
                        <!-- Vintage stamp effect on hover -->
                        <div class="absolute -bottom-1 -right-1 opacity-0 group-hover:opacity-100 transition-opacity duration-300">
                            <div class="text-[8px] text-accent/40 font-mono transform rotate-[-5deg]">1955</div>
                        </div>
                    </div>
                </div>
                <div class="hidden md:flex items-center space-x-4">
                    <button onclick="openSetupModal()" class="bg-accent hover:bg-accent/90 text-white px-6 py-2 rounded-lg font-semibold transition shadow-sm">
                        Setup
                    </button>
                    
                    <!-- GitHub with stars -->
                    <a href="https://github.com/pimdewitte/albert" target="_blank" class="group relative flex items-center space-x-2 bg-paper hover:bg-code-bg border border-code-border px-4 py-2 rounded-lg transition shadow-sm">
                        <svg class="w-5 h-5 text-ink" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M12 0c-6.626 0-12 5.373-12 12c0 5.08 3.29 9.39 7.86 10.91.58.11.79-.25.79-.56 0-.28-.01-1.02-.02-2-3.2.7-3.88-1.54-3.88-1.54-.53-1.34-1.3-1.7-1.3-1.7-1.06-.72.08-.71.08-.71 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
                        </svg>
                        <span class="text-sm font-mono text-ink">â˜… 5 (new)</span>
                        <!-- Tooltip -->
                        <span class="absolute -bottom-8 left-1/2 transform -translate-x-1/2 bg-ink text-paper text-xs px-2 py-1 rounded opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none whitespace-nowrap">
                            Star on GitHub
                        </span>
                    </a>
                    
                    <!-- Discord -->
                    <a href="https://discord.gg/tnPhwxr6qZ" target="_blank" class="group relative flex items-center bg-paper hover:bg-code-bg border border-code-border p-2 rounded-lg transition shadow-sm">
                        <svg class="w-5 h-5 text-accent" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M20.317 4.37a19.791 19.791 0 0 0-4.885-1.515a.074.074 0 0 0-.079.037c-.21.375-.444.864-.608 1.25a18.27 18.27 0 0 0-5.487 0a12.64 12.64 0 0 0-.617-1.25a.077.077 0 0 0-.079-.037A19.736 19.736 0 0 0 3.677 4.37a.07.07 0 0 0-.032.027C.533 9.046-.32 13.58.099 18.057a.082.082 0 0 0 .031.057a19.9 19.9 0 0 0 5.993 3.03a.078.078 0 0 0 .084-.028a14.09 14.09 0 0 0 1.226-1.994a.076.076 0 0 0-.041-.106a13.107 13.107 0 0 1-1.872-.892a.077.077 0 0 1-.008-.128a10.2 10.2 0 0 0 .372-.292a.074.074 0 0 1 .077-.01c3.928 1.793 8.18 1.793 12.062 0a.074.074 0 0 1 .078.01c.12.098.246.198.373.292a.077.077 0 0 1-.006.127a12.299 12.299 0 0 1-1.873.892a.077.077 0 0 0-.041.107c.36.698.772 1.362 1.225 1.993a.076.076 0 0 0 .084.028a19.839 19.839 0 0 0 6.002-3.03a.077.077 0 0 0 .032-.054c.5-5.177-.838-9.674-3.549-13.66a.061.061 0 0 0-.031-.03zM8.02 15.33c-1.183 0-2.157-1.085-2.157-2.419c0-1.333.956-2.419 2.157-2.419c1.21 0 2.176 1.096 2.157 2.42c0 1.333-.956 2.418-2.157 2.418zm7.975 0c-1.183 0-2.157-1.085-2.157-2.419c0-1.333.955-2.419 2.157-2.419c1.21 0 2.176 1.096 2.157 2.42c0 1.333-.946 2.418-2.157 2.418z"/>
                        </svg>
                        <!-- Tooltip -->
                        <span class="absolute -bottom-8 left-1/2 transform -translate-x-1/2 bg-ink text-paper text-xs px-2 py-1 rounded opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none whitespace-nowrap">
                            Join Community
                        </span>
                    </a>
                </div>
                <div class="md:hidden flex items-center space-x-2">
                    <button onclick="openSetupModal()" class="bg-accent hover:bg-accent/90 text-white px-4 py-1.5 rounded-lg font-semibold transition shadow-sm text-sm">
                        Setup
                    </button>
                    
                    <!-- GitHub with stars (mobile) -->
                    <a href="https://github.com/pimdewitte/albert" target="_blank" class="flex items-center space-x-1 bg-paper hover:bg-code-bg border border-code-border px-3 py-1.5 rounded-lg transition shadow-sm">
                        <svg class="w-4 h-4 text-ink" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M12 0c-6.626 0-12 5.373-12 12c0 5.08 3.29 9.39 7.86 10.91.58.11.79-.25.79-.56 0-.28-.01-1.02-.02-2-3.2.7-3.88-1.54-3.88-1.54-.53-1.34-1.3-1.7-1.3-1.7-1.06-.72.08-.71.08-.71 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
                        </svg>
                        <span class="text-xs font-mono text-ink">NEW</span>
                    </a>
                    
                    <!-- Discord (mobile) -->
                    <a href="https://discord.gg/tnPhwxr6qZ" target="_blank" class="flex items-center bg-paper hover:bg-code-bg border border-code-border p-1.5 rounded-lg transition shadow-sm">
                        <svg class="w-4 h-4 text-accent" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M20.317 4.37a19.791 19.791 0 0 0-4.885-1.515a.074.074 0 0 0-.079.037c-.21.375-.444.864-.608 1.25a18.27 18.27 0 0 0-5.487 0a12.64 12.64 0 0 0-.617-1.25a.077.077 0 0 0-.079-.037A19.736 19.736 0 0 0 3.677 4.37a.07.07 0 0 0-.032.027C.533 9.046-.32 13.58.099 18.057a.082.082 0 0 0 .031.057a19.9 19.9 0 0 0 5.993 3.03a.078.078 0 0 0 .084-.028a14.09 14.09 0 0 0 1.226-1.994a.076.076 0 0 0-.041-.106a13.107 13.107 0 0 1-1.872-.892a.077.077 0 0 1-.008-.128a10.2 10.2 0 0 0 .372-.292a.074.074 0 0 1 .077-.01c3.928 1.793 8.18 1.793 12.062 0a.074.074 0 0 1 .078.01c.12.098.246.198.373.292a.077.077 0 0 1-.006.127a12.299 12.299 0 0 1-1.873.892a.077.077 0 0 0-.041.107c.36.698.772 1.362 1.225 1.993a.076.076 0 0 0 .084.028a19.839 19.839 0 0 0 6.002-3.03a.077.077 0 0 0 .032-.054c.5-5.177-.838-9.674-3.549-13.66a.061.061 0 0 0-.031-.03zM8.02 15.33c-1.183 0-2.157-1.085-2.157-2.419c0-1.333.956-2.419 2.157-2.419c1.21 0 2.176 1.096 2.157 2.42c0 1.333-.956 2.418-2.157 2.418zm7.975 0c-1.183 0-2.157-1.085-2.157-2.419c0-1.333.955-2.419 2.157-2.419c1.21 0 2.176 1.096 2.157 2.42c0 1.333-.946 2.418-2.157 2.418z"/>
                        </svg>
                    </a>
                </div>
            </div>
        </div>
    </nav>

    <!-- Research Preview Notice -->
    <div class="research-notice fixed top-16 left-0 right-0 bg-warning/10 border-b border-warning/20 py-3 px-4 sm:px-6 lg:px-8 z-30" style="background: linear-gradient(135deg, rgba(250, 248, 243, 0.95) 0%, rgba(250, 248, 243, 0.92) 30%, rgba(250, 248, 243, 0.94) 70%, rgba(250, 248, 243, 0.95) 100%), linear-gradient(rgba(251, 191, 36, 0.25), rgba(251, 191, 36, 0.25)) !important; border: none !important; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12), inset 0 1px 0 rgba(255, 255, 255, 0.25), inset 0 -1px 0 rgba(0, 0, 0, 0.05) !important;">
        <div class="max-w-7xl mx-auto flex items-center justify-center gap-3">
            <svg class="w-5 h-5 text-warning flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"/>
            </svg>
            <p class="text-sm text-ink font-medium text-center">
                <strong>Research Preview:</strong> This is an early research preview of Albert. While the code is openly available, it has only been shared with a select group of researchers and early testers.
            </p>
        </div>
    </div>



    <!-- Main Content -->
    <main class="pt-16 md:pt-16">
        
        <!-- Mobile-only content wrapper -->
        <div class="block md:hidden">
            <!-- This div ensures proper spacing on mobile when animated section is hidden -->
        </div>
        
        <!-- Homepage Section with Spacetime Background -->
        <section id="home" class="min-h-screen flex items-center justify-center px-4 sm:px-6 lg:px-8 relative overflow-hidden">
            <!-- Spacetime Curvature Visualization Background -->
            <canvas id="spacetimeCanvas" class="absolute inset-0 w-full h-full z-0" style="cursor: crosshair;"></canvas>
            
            <div class="max-w-7xl mx-auto text-center relative z-10 non-interactive">
                
                <h1 class="text-4xl sm:text-6xl lg:text-8xl font-bold mb-8 fade-in font-display">
                    <span class="text-accent">Introducing Albert</span>
                    <span class="text-muted block text-2xl sm:text-3xl lg:text-4xl mt-4">  A Differential PyTorch Physics Research Engine </span>
                </h1>
                
    
                     <!-- Quick Start One-Line Setup (Trustworthy Professional Design) -->
                <div class="bg-paper rounded-2xl p-8 mb-12 max-w-3xl mx-auto shadow-lg border border-muted/20 gravitational-text interactive" style="padding: 2rem 3.236rem; animation-delay: 1.5s; animation-duration: 10s;">
                    <div class="flex items-center justify-between mb-6">
                   
                        <div class="flex items-center space-x-3">
                            <svg class="w-5 h-5 text-accent" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M2.166 4.999A11.954 11.954 0 0010 1.944 11.954 11.954 0 0017.834 5c.11.65.166 1.32.166 2.001 0 5.225-3.34 9.67-8 11.317C5.34 16.67 2 12.225 2 7c0-.682.057-1.35.166-2.001zm11.541 3.708a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path>
                            </svg>
                            <span class="text-sm text-muted font-medium">Albert is 100% open source and you can audit everything you're installing!</span>
                        </div>
                    </div>
                    
                    <div class="relative group">
                        <div class="bg-code-bg rounded-lg border border-code-border hover:border-accent/50 transition-all overflow-hidden">
                            <div class="flex items-stretch">
                                <div class="flex-1 p-3 sm:p-4 space-y-1">
                                    <div id="homepage-install-command" class="font-mono text-base sm:text-lg whitespace-nowrap">
                                        <span class="select-all"><span class="text-accent">curl -fsSL</span> <span class="text-ink">https://albert.so/install</span> <span class="text-muted">| bash</span></span>
                                    </div>
                                </div>
                                <button 
                                    onclick="copyHomepageCommand()" 
                                    class="px-4 text-muted hover:text-accent hover:bg-accent/5 transition-all group-hover:text-accent border-l border-code-border flex items-center justify-center"
                                    title="Copy to clipboard"
                                >
                                    <svg id="homepage-copy-icon" class="w-5 h-5 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
                                    </svg>
                                    <svg id="homepage-check-icon" class="w-5 h-5 hidden text-success flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                                    </svg>
                                </button>
                            </div>
                        </div>
                        
                        <!-- Tooltip -->
                        <div id="homepage-copy-tooltip" class="absolute -top-10 right-0 bg-ink text-paper text-xs px-3 py-1 rounded opacity-0 pointer-events-none transition-opacity shadow-lg">
                            Copied to clipboard!
                        </div>
                    </div>
                    
                    <!-- Trust indicators -->
                    <div class="mt-6 grid grid-cols-1 sm:grid-cols-3 gap-4" style="gap: 1.618rem;">
                        <div class="flex items-center space-x-2">
                            <svg class="w-5 h-5 text-success flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path>
                            </svg>
                            <span class="text-sm text-ink">PyTorch Based</span>
                        </div>
                        <div class="flex items-center space-x-2">
                            <svg class="w-5 h-5 text-success flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path>
                            </svg>
                            <span class="text-sm text-ink">Optional GPU Acceleration</span>
                        </div>
                        <div class="flex items-center space-x-2">
                            <svg class="w-5 h-5 text-success flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path>
                            </svg>
                            <span class="text-sm text-ink">No root required</span>
                        </div>
                    </div>
                    
                    <!-- Additional trust elements -->
                    <div class="mt-6 pt-6 border-t border-code-border flex items-center justify-between">
                        <div class="flex items-center space-x-4">
                            <a href="https://github.com/pimdewitte/albert" class="text-sm text-accent hover:text-accent/80 flex items-center space-x-1">
                                <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24">
                                    <path d="M12 .5C5.73.5.5 5.73.5 12c0 5.08 3.29 9.39 7.86 10.91.58.11.79-.25.79-.56 0-.28-.01-1.02-.02-2-3.2.7-3.88-1.54-3.88-1.54-.53-1.34-1.3-1.7-1.3-1.7-1.06-.72.08-.71.08-.71 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
                                </svg>
                                <span>View source code</span>
                            </a>
                    
            
                        </div>
                        <div class="flex items-center space-x-2">
                            <span class="text-xs text-muted">Latest version: v1.2.0</span>
                        </div>
                    </div>
                </div>
                
                <div class="flex items-center justify-center gap-6 mt-8">
                    <a href="documentation.html" 
                       class="bg-accent hover:bg-accent/90 text-white text-lg px-6 py-3 rounded-lg font-semibold transition transform hover:scale-105 shadow-sm interactive w-64 h-14 flex items-center justify-center gap-2">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 17v-2m3 2v-4m3 4v-6m2 10H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                        </svg>
                        View Docs
                    </a>
                    <a href="../latest_run/latest_report.html" 
                       class="bg-success hover:bg-success/90 text-white text-lg px-6 py-3 rounded-lg font-semibold transition transform hover:scale-105 shadow-sm interactive w-64 h-14 flex items-center justify-center gap-2">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                        </svg>
                        Latest Report
                    </a>
                    <a href="../latest_run/trajectory_viewers/unified_multi_particle_viewer_advanced.html" 
                       class="bg-quantum hover:bg-quantum/90 text-white text-lg px-6 py-3 rounded-lg font-semibold transition transform hover:scale-105 shadow-sm interactive w-64 h-14 flex items-center justify-center gap-2">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 01-9 9m9-9a9 9 0 00-9-9m9 9H3m9 9a9 9 0 01-9-9m9 9c1.657 0 3-4.03 3-9s-1.343-9-3-9m0 18c-1.657 0-3-4.03-3-9s1.343-9 3-9m-9 9a9 9 0 019-9"></path>
                        </svg>
                         3D Visualizer
                    </a>
                </div>
                

                
                
            </div>
        </section>

        <!-- The Emotional Journey Begins -->
        <section id="journey" class="relative">
                    <!-- Chapter 2: Real-Time Theory Testing -->
        <div class="min-h-screen px-4 sm:px-6 lg:px-8 relative overflow-hidden bg-paper pt-8 md:pt-0">
                <div class="max-w-7xl mx-auto">
                    
                    <!-- Section Header -->
                    <div class="text-center mb-8 md:mb-12">
                        <h3 class="text-5xl sm:text-6xl lg:text-5xl font-display font-bold text-accent mb-4 md:mb-6">
                          A Simple CLI Entrypoint for Humans and Agents
                        </h3>
                    </div>
                    
                    <!-- CLI Demo Video -->
                    <div class="mb-16 max-w-7xl mx-auto">
                        <div class="relative bg-gradient-to-br from-accent/5 to-quantum/5 rounded-3xl p-1 shadow-2xl">
                            <div class="bg-black rounded-3xl overflow-hidden">
                                <!-- Terminal-style header -->
                                <div class="bg-gray-800 px-4 py-2 flex items-center gap-2">
                                    <div class="flex gap-1.5">
                                        <div class="w-3 h-3 bg-red-500 rounded-full"></div>
                                        <div class="w-3 h-3 bg-yellow-500 rounded-full"></div>
                                        <div class="w-3 h-3 bg-green-500 rounded-full"></div>
                                    </div>
                                    <span class="text-gray-400 text-sm font-mono ml-2">albert demo</span>
                                </div>
                                <!-- Video container with 2.33:1 aspect ratio -->
                                <div class="relative" style="padding-bottom: 42.9%;">
                                    <video 
                                        id="demoVideo"
                                        class="absolute inset-0 w-full h-full"
                                        src="demo.mp4"
                                        muted
                                        loop
                                        playsinline
                                        preload="metadata"
                                        controls
                                    >
                                        Your browser does not support the video tag.
                                    </video>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Theory Engine Visualization - Full Width -->
                    <div class="mb-20">
                        <div class="bg-white rounded-3xl shadow-2xl p-4 md:p-8 border border-code-border/30">
                            <canvas id="theoryEngineCanvas" width="1200" height="800" class="w-full"></canvas>
                        </div>
                     
                    </div>

                </div>
            </section>
            
    


            <!-- Chapter 6: A Validation Framework for Fundamental Physics -->
            <div class="px-4 sm:px-6 lg:px-8 py-20 relative overflow-hidden bg-paper">
                <div class="container mx-auto">
                    <h2 class="text-4xl lg:text-6xl font-display font-bold text-center text-accent mb-12">
                         Bridging Fundamental Physics and Machine Learning
                    </h2>
                    
                    <!-- Two Column Layout: Text and Video -->
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-12 items-center max-w-7xl mx-auto mb-16">
                        <!-- Text Content -->
                        <div class="space-y-6">
                            <p class="text-xl font-serif text-ink leading-relaxed">
                                Albert enables a new paradigm: learning from verifiable physics simulations to create high-quality training data. 
                                By implementing theories as computational modelsâ€”metric tensors and field equationsâ€”our solvers generate trajectories 
                                that are guaranteed to follow the laws of physics. This creates a unique opportunity to train AI systems on 
                                data that is both physically correct and computationally verified, bridging the gap between theoretical physics 
                                and machine learning through differentiable simulations in PyTorch.
                            </p>
                            
                            <p class="text-xl font-serif text-ink leading-relaxed">
                                The framework's differentiable nature means every simulation becomes a potential training example, where 
                                gradient-based optimization can learn from the physics itself. This approach transforms how we create 
                                datasets for physics AIâ€”instead of relying on limited experimental data, we can generate unlimited training 
                                examples from theories that have been validated against observations. Albert provides the infrastructure 
                                to turn validated physical models into the foundation for next-generation physics learning systems.
                            </p>
                        </div>
                        
                        <!-- 3D Video -->
                        <div class="relative">
                            <div class="bg-white rounded-3xl shadow-2xl p-4 border border-accent/20 overflow-hidden">
                                <video 
                                    class="w-full h-auto rounded-2xl"
                                    autoplay 
                                    loop 
                                    muted 
                                    playsinline
                                    controls
                                >
                                    <source src="3d.mp4" type="video/mp4">
                                    Your browser does not support the video tag.
                                </video>
                            </div>
                            <div class="absolute -z-10 top-8 right-8 w-full h-full bg-gradient-to-br from-quantum/20 to-accent/20 rounded-3xl blur-3xl"></div>
                        </div>
                    </div>

                    
                    <!-- Understanding Validators -->
                    <div class="bg-white rounded-3xl shadow-xl p-8 border border-accent/10 max-w-6xl mx-auto mt-12">
                        <h3 class="text-2xl font-bold text-accent mb-6">Understanding the Validation Framework</h3>
                        <p class="text-lg font-serif text-ink mb-6">
                            When a newly introduced theory is implemented computationally, it must pass through sophisticated tests that verify its adherence to known physics. Think of validators as automated 
                            experts, each specialized in checking specific aspects of physical law compliance.
                        </p>
                        <p class="text-lg font-serif text-ink mb-6">
                            The validation process follows a systematic progression: First, <strong>constraint validators</strong> ensure 
                            basic mathematical consistencyâ€”conservation of energy, angular momentum, and proper metric signatures. 
                            Next, <strong>classical validators</strong> verify agreement with well-established phenomena like Mercury's 
                            perihelion precession and light deflection by the Sun. Finally, <strong>quantum validators</strong> test 
                            predictions against modern experiments involving quantum corrections and high-energy physics. Finally it goes through a set of <b>predictions</b>, which are open research questions like the Muon G-2 anomaly, to see if the theory can make predictions on unsolved problems. Observations are expected to pass. As well as constraints. Predictions are not. 
                        </p>
                        <p class="text-lg font-serif text-ink mb-6">
                            Each validator not only checks for correctness but also measures precision. A theory might correctly predict 
                            Mercury's orbit but with insufficient accuracy, or it might conserve energy only approximately. The framework 
                            tracks these nuances, building a comprehensive profile of each theory's strengths and limitations. This 
                            multi-stage validation ensures that any theory emerging from the gauntlet has been thoroughly vetted against 
                            both theoretical requirements and experimental observations.
                        </p>
                    </div>

                    <!-- Energy Calculation Example -->
                    <div class="bg-white rounded-3xl shadow-xl p-8 border border-accent/10 max-w-6xl mx-auto mt-12">
                        <h3 class="text-2xl font-bold text-accent mb-6">Example: How Energy Conservation Validation Works</h3>
                        <p class="text-lg font-serif text-ink mb-6">
                            Here's a concrete example of how validators analyze solver output to verify physical conservation laws:
                        </p>
                        <div class="bg-paper rounded-2xl p-6 border border-code-border overflow-x-auto">
                            <div class="mermaid">
graph LR
    subgraph Input["Input Data"]
        Traj["Trajectory<br/>(t, r, Ï†)"]
        Theory["Theory<br/>(Metric g_Î¼Î½)"]
    end
    
    subgraph EnergyCalc["Energy Calculation at Each Point"]
        Vel["Velocity Components<br/>u_t = dt/dÏ„<br/>u_Ï† = dÏ†/dÏ„"]
        Metric["Metric Components<br/>g_tt, g_tp, g_pp"]
        Energy["Energy<br/>E = -(g_ttÂ·u_t + g_tpÂ·u_Ï†)"]
        Vel --> Energy
        Metric --> Energy
    end
    
    subgraph Analysis["Statistical Analysis"]
        Mean["Mean Energy<br/>Î¼(E)"]
        StdDev["Std Deviation<br/>Ïƒ(E)"]
        Error["Relative Error<br/>Îµ = Ïƒ(E)/|Î¼(E)|"]
        Mean --> Error
        StdDev --> Error
    end
    
    subgraph Comparison["Theory Comparison"]
        T1["Theory A<br/>Îµ = 1e-7<br/>âœ“ PASS"]
        T2["Theory B<br/>Îµ = 1e-4<br/>âœ“ PASS"]
        T3["Theory C<br/>Îµ = 0.1<br/>âœ— FAIL"]
        Rank["Ranking:<br/>A > B > C"]
        T1 --> Rank
        T2 --> Rank
        T3 --> Rank
    end
    
    Traj --> Vel
    Theory --> Metric
    Energy --> Mean
    Energy --> StdDev
    Error --> T1
    Error --> T2
    Error --> T3
    
    classDef inputBox fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px
    classDef calcBox fill:#e3f2fd,stroke:#1976d2,stroke-width:2px
    classDef analysisBox fill:#fff3e0,stroke:#f57c00,stroke-width:2px
    classDef passBox fill:#c8e6c9,stroke:#388e3c,stroke-width:2px
    classDef failBox fill:#ffcdd2,stroke:#d32f2f,stroke-width:2px
    
    class Traj,Theory inputBox
    class Vel,Metric,Energy calcBox
    class Mean,StdDev,Error analysisBox
    class T1,T2 passBox
    class T3 failBox
                                    </div>
                                </div>
                        <p class="text-base text-muted mt-4 italic text-center">
                            The validator continuously monitors conserved quantities throughout the trajectory, 
                            ensuring numerical integration preserves the physics
                        </p>
                        </div>
                 
                  
                </div>
            </div>



             <!-- Chapter 5: The Theory Engine -->
             <div class="min-h-screen px-4 sm:px-6 lg:px-8 py-20 relative overflow-hidden bg-paper">
                <div class="max-w-7xl mx-auto">
                   
                  
                    
                    <!-- Section 1: Standard Model Support (Expandable) -->
                    <div class="mb-20">
                        <div class="max-w-5xl mx-auto">
                            <!-- Collapsible Header -->
                            <div class="bg-gradient-to-r from-quantum/5 to-accent/5 rounded-2xl shadow-lg border border-quantum/20 overflow-hidden">
                                <button onclick="toggleStandardModelSection()" class="w-full px-8 py-6 flex items-center justify-between hover:bg-quantum/5 transition-colors group">
                                    <div class="flex items-center gap-4">
                                        <h4 class="text-3xl font-bold text-quantum">Standard Model Integration</h4>
                                        <div class="flex items-center space-x-2 bg-warning/10 border border-warning/30 rounded-lg px-3 py-1">
                                            <svg class="w-4 h-4 text-warning" fill="currentColor" viewBox="0 0 20 20">
                                                <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"/>
                                            </svg>
                                            <span class="text-xs font-medium text-ink">Experimental Quantum Features</span>
                                        </div>
                                    </div>
                                    <div class="flex items-center gap-3">
                                        <span class="text-sm text-muted group-hover:text-quantum transition-colors">
                                            Click to explore quantum-gravity interface
                                        </span>
                                        <svg id="sm-chevron" class="w-6 h-6 text-quantum transform transition-transform duration-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                                        </svg>
                                    </div>
                                </button>
                                
                                <!-- Collapsible Content -->
                                <div id="sm-content" class="overflow-hidden transition-all duration-500" style="max-height: 0;">
                                    <div class="px-8 py-6 bg-gradient-to-b from-transparent to-quantum/5">
                                        <div class="bg-white rounded-2xl shadow-lg p-8 border border-code-border mb-8">
                                            <h5 class="text-2xl font-bold text-accent mb-4">Technical Implementation</h5>
                                            <p class="text-lg font-serif text-ink mb-4">
                                                Albert embeds the complete Standard Model physics through QED Lagrangians, 
                                                enabling precision tests at the quantum-gravitational interface. Every theory 
                                                must couple correctly to fermions and gauge bosons.
                                            </p>

                                            
                                            <!-- Real Implementation Example: Kerr -->
                                            <div class="mt-6">
                                                <h5 class="text-xl font-bold text-success mb-4">Real Implementation: Kerr Black Holes</h5>
                                                <pre class="text-xs font-mono overflow-x-auto bg-code-bg rounded-lg p-4 border border-code-border">
<span class="text-accent">from</span> physics_agent.theories.kerr <span class="text-accent">import</span> KerrMetric

<span class="text-accent">class</span> <span class="text-warning">KerrMetric</span>(<span class="text-warning">GravitationalTheory</span>):
    <span class="text-muted">"""Rotating black hole solution with angular momentum"""</span>
    
    <span class="text-accent">def</span> <span class="text-success">get_metric</span>(self, r, theta, M, a):
        <span class="text-muted"># Kerr metric in Boyer-Lindquist coordinates</span>
        rs = 2 * G * M / c**2
        rho2 = r**2 + a**2 * cos(theta)**2
        delta = r**2 - rs * r + a**2
        sigma2 = (r**2 + a**2)**2 - a**2 * delta * sin(theta)**2
        
        <span class="text-muted"># Metric components (diagonal + frame-dragging)</span>
        g_tt = -(1 - rs * r / rho2)
        g_rr = rho2 / delta  
        g_Î¸Î¸ = rho2
        g_Ï†Ï† = sigma2 * sin(theta)**2 / rho2
        g_tÏ† = -rs * r * a * sin(theta)**2 / rho2  <span class="text-muted"># Frame-dragging!</span>
        
        <span class="text-accent">return</span> g_tt, g_rr, g_Î¸Î¸, g_Ï†Ï†, g_tÏ†

<span class="text-muted"># Test extreme Kerr (a = 0.998M) against observations</span>
kerr = <span class="text-warning">KerrMetric</span>()
results = kerr.validate_black_hole_shadow(M87_data)
<span class="text-accent">assert</span> results['shadow_radius'] == 42.0 Â± 3.0  <span class="text-success">âœ“ Î¼as</span>
<span class="text-accent">assert</span> results['asymmetry'] < 0.1             <span class="text-success">âœ“</span>
<span class="text-accent">assert</span> results['ISCO_radius'] == 1.235 * rs   <span class="text-success">âœ“</span>
                                                </pre>
                                            </div>
                                            
                                            <!-- Experimental Quantum Features -->
                                            <div class="mt-8 bg-warning/10 rounded-lg p-4 border border-warning/30">
                                                <h5 class="text-lg font-bold text-warning mb-3">âš ï¸ Experimental: Quantum Corrections</h5>
                                                <p class="text-sm text-ink mb-4">
                                                    The following features are experimental and may change. They represent ongoing research
                                                    into quantum gravity effects near black holes.
                                                </p>
                                                <pre class="text-xs font-mono overflow-x-auto bg-code-bg rounded-lg p-4 border border-code-border">
<span class="text-muted"># EXPERIMENTAL: Quantum corrections to Kerr metric</span>
<span class="text-accent">from</span> physics_agent.quantum.corrections <span class="text-accent">import</span> HawkingRadiation, QuantumHorizon

<span class="text-accent">class</span> <span class="text-warning">QuantumKerr</span>(<span class="text-warning">KerrMetric</span>):
    <span class="text-muted">"""Kerr metric with quantum gravity corrections (EXPERIMENTAL)"""</span>
    
    <span class="text-accent">def</span> <span class="text-success">__init__</span>(self, enable_hawking=True, quantum_hair=False):
        super().__init__()
        self.â„ = 1.054571817e-34  <span class="text-muted"># Planck's constant</span>
        self.l_p = torch.sqrt(self.â„ * G / c**3)  <span class="text-muted"># Planck length</span>
        
    <span class="text-accent">def</span> <span class="text-success">get_quantum_corrections</span>(self, r, M, a):
        <span class="text-muted"># Quantum corrections near horizon (r â†’ r+)</span>
        r_plus = M + torch.sqrt(M**2 - a**2)
        
        <span class="text-muted"># Leading order quantum correction</span>
        Î´g_tt = self.â„ / (M * r**3) * torch.exp(-(r - r_plus) / self.l_p)
        
        <span class="text-muted"># Hawking temperature</span>
        Îº = (r_plus - M) / (2 * M * r_plus)  <span class="text-muted"># Surface gravity</span>
        T_H = self.â„ * Îº / (2 * Ï€ * k_B)     <span class="text-muted"># ~ 10^-8 K for stellar BH</span>
        
        <span class="text-accent">return</span> Î´g_tt, T_H

<span class="text-muted"># WARNING: These corrections are ~ 10^-70 for astrophysical black holes!</span>
<span class="text-muted"># Only potentially observable for primordial black holes with M ~ 10^15 g</span>
                                                </pre>
                                            </div>
                                            
                                            <p class="text-sm text-muted mt-6 mb-4">
                                                Standard Model integration allows testing unified theories against QED precision 
                                                measurements with up to 13 significant figures of accuracy. Quantum gravity effects
                                                remain orders of magnitude below current observational thresholds.
                                            </p>
                                            
                                            <!-- Quantum Validator Spotlight - Atomic Clock Test -->
                                            <div class="mt-8">
                                                <div class="bg-gradient-to-r from-quantum/10 to-accent/10 rounded-3xl p-1">
                                                    <div class="bg-white rounded-3xl p-8 md:p-12">
                                                        <h4 class="text-3xl font-bold text-center mb-12 bg-gradient-to-r from-quantum to-accent bg-clip-text text-transparent">
                                                            Quantum Precision: The Atomic Clock Test
                                                        </h4>
                                                        
                                                        <div class="grid grid-cols-1 lg:grid-cols-2 gap-12 items-center">
                                                            <div class="order-2 lg:order-1">
                                                                <div class="space-y-6">
                                                                    <p class="text-xl font-serif text-ink leading-relaxed">
                                                                        Optical atomic clocks are humanity's most precise instruments. In 2018, 
                                                                        scientists measured time's flow between two clocks just 33 cm apart.
                                                                    </p>
                                                                    
                                                                    <!-- Interactive measurement display -->
                                                                    <div class="group bg-gradient-to-br from-code-bg to-paper rounded-2xl p-6 border border-code-border/50 hover:border-quantum/50 transition-all cursor-pointer" onclick="toggleClockDetails()">
                                                                        <div class="flex items-center justify-between mb-4">
                                                                            <h5 class="font-bold text-lg">Experimental Parameters</h5>
                                                                            <div class="text-quantum text-sm">Hover for details</div>
                                                                        </div>
                                                                        
                                                                        <div class="grid grid-cols-2 gap-4">
                                                                            <div class="bg-white/50 rounded-lg p-3 group-hover:bg-white/80 transition-colors">
                                                                                <div class="text-2xl font-mono font-bold text-accent">1.121</div>
                                                                                <div class="text-sm text-muted">PHz frequency</div>
                                                                            </div>
                                                                            <div class="bg-white/50 rounded-lg p-3 group-hover:bg-white/80 transition-colors">
                                                                                <div class="text-2xl font-mono font-bold text-quantum">0.33</div>
                                                                                <div class="text-sm text-muted">meters apart</div>
                                                                            </div>
                                                                        </div>
                                                                        
                                                                        <div id="clock-details" class="mt-4 overflow-hidden transition-all duration-300" style="max-height: 0;">
                                                                            <div class="pt-4 border-t border-code-border/30">
                                                                                <div class="bg-success/10 rounded-lg p-3 mb-3">
                                                                                    <div class="text-sm font-mono text-success">âœ“ Measured: (3.61 Â± 1.60) Ã— 10â»Â¹â·</div>
                                                                                </div>
                                                                                <p class="text-sm text-muted">
                                                                                    This measurement tests gravitational time dilation with 
                                                                                    extraordinary precisionâ€”demonstrating the framework's ability to validate theories against cutting-edge experiments.
                                                                                </p>
                                                                            </div>
                                                                        </div>
                                                                    </div>
                                                                    
                                                                    <div class="bg-warning/10 border border-warning/30 rounded-xl p-4">
                                                                        <p class="text-sm font-medium text-warning mb-1">Why This Matters</p>
                                                                        <p class="text-sm text-ink">
                                                                            Every theory must predict this shift to 17 decimal places, 
                                                                            testing where Einstein meets quantum mechanics.
                                                                        </p>
                                                                    </div>
                                                                </div>
                                                            </div>
                                                            
                                                            <div class="order-1 lg:order-2 flex justify-center">
                                                                <div class="bg-code-bg rounded-2xl p-4 shadow-lg border border-code-border/50">
                                                                    <canvas id="quantumValidatorCanvas" width="450" height="350" class="w-full max-w-md"></canvas>
                                                                </div>
                                                            </div>
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                            
                                            <a href="documentation.html" target="_blank" class="inline-flex items-center space-x-2 bg-accent hover:bg-accent/90 text-white px-4 py-2 rounded-lg font-semibold transition shadow-sm mt-8">
                                                <span>View Documentation</span>
                                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"></path>
                                                </svg>
                                            </a>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                   
                    <!-- Comprehensive Test Suite -->
                    <div class="mb-20 max-w-7xl mx-auto">
                        <h2 class="text-4xl lg:text-5xl font-display font-bold text-center text-accent mb-12">
                            Full Set of Tests & Benchmarks
                        </h2>
                        
                        <p class="text-xl font-serif text-ink text-center mb-12 max-w-4xl mx-auto">
                            Albert validates theories against 14 rigorous tests spanning classical to quantum regimes. 
                            Each test compares theoretical predictions with state-of-the-art experimental measurements 
                            or theoretical benchmarks.
                        </p>
                        
                        <!-- Test Categories Grid -->
                        <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-12">
                            
                            <!-- Observational Tests -->
                            <div class="bg-white rounded-3xl shadow-xl p-8 border border-accent/20">
                                <h3 class="text-2xl font-bold text-accent mb-6 flex items-center gap-3">
                                    <svg class="w-8 h-8 text-accent" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path>
                                    </svg>
                                    Analytical Validators (7 tests)
                                </h3>
                                
                                <div class="space-y-4">
                                    <!-- Mercury Precession -->
                                    <div class="border border-code-border rounded-xl p-4 hover:border-accent/50 transition-colors">
                                        <div class="flex justify-between items-start mb-2">
                                            <h4 class="font-bold text-ink">Mercury Perihelion Advance</h4>
                                            <span class="text-xs bg-success/10 text-success px-2 py-1 rounded-full">Classical</span>
                                        </div>
                                        <p class="text-sm text-muted mb-2">Tests gravitational field in weak-field regime</p>
                                        <div class="bg-code-bg rounded-lg p-3 font-mono text-xs">
                                            <div>SOTA: <span class="text-accent">42.98 Â± 0.04</span> arcsec/century</div>
                                            <div>Source: Radar ranging (Park et al. 2017)</div>
                                        </div>
                                    </div>
                                    
                                    <!-- Light Deflection -->
                                    <div class="border border-code-border rounded-xl p-4 hover:border-accent/50 transition-colors">
                                        <div class="flex justify-between items-start mb-2">
                                            <h4 class="font-bold text-ink">Solar Light Deflection</h4>
                                            <span class="text-xs bg-success/10 text-success px-2 py-1 rounded-full">Classical</span>
                                        </div>
                                        <p class="text-sm text-muted mb-2">Validates metric spatial curvature effects</p>
                                        <div class="bg-code-bg rounded-lg p-3 font-mono text-xs">
                                            <div>SOTA: <span class="text-accent">1.7512 Â± 0.0016</span> arcsec</div>
                                            <div>Source: VLBI (Shapiro et al. 2004, PRL)</div>
                                        </div>
                                    </div>
                                    
                                    <!-- PPN Parameters -->
                                    <div class="border border-code-border rounded-xl p-4 hover:border-accent/50 transition-colors">
                                        <div class="flex justify-between items-start mb-2">
                                            <h4 class="font-bold text-ink">PPN Parameters (Î³, Î²)</h4>
                                            <span class="text-xs bg-success/10 text-success px-2 py-1 rounded-full">Classical</span>
                                        </div>
                                        <p class="text-sm text-muted mb-2">Parameterized post-Newtonian formalism tests</p>
                                        <div class="bg-code-bg rounded-lg p-3 font-mono text-xs">
                                            <div>Î³: <span class="text-accent">1.000021 Â± 0.000023</span> (Cassini)</div>
                                            <div>Î²: <span class="text-accent">1.0000 Â± 0.00003</span> (Lunar Laser Ranging)</div>
                                        </div>
                                    </div>
                                    
                                    <!-- Photon Sphere -->
                                    <div class="border border-code-border rounded-xl p-4 hover:border-accent/50 transition-colors">
                                        <div class="flex justify-between items-start mb-2">
                                            <h4 class="font-bold text-ink">Photon Sphere</h4>
                                            <span class="text-xs bg-success/10 text-success px-2 py-1 rounded-full">Classical</span>
                                        </div>
                                        <p class="text-sm text-muted mb-2">Light ring radius around black holes</p>
                                        <div class="bg-code-bg rounded-lg p-3 font-mono text-xs">
                                            <div>SOTA: <span class="text-accent">1.5 r_s</span> (Schwarzschild)</div>
                                            <div>Shadow: <span class="text-accent">5.196 r_s</span> diameter</div>
                                        </div>
                                    </div>
                                    
                                    <!-- COW Interferometry -->
                                    <div class="border border-code-border rounded-xl p-4 hover:border-accent/50 transition-colors">
                                        <div class="flex justify-between items-start mb-2">
                                            <h4 class="font-bold text-ink">COW Neutron Interferometry</h4>
                                            <span class="text-xs bg-quantum/10 text-quantum px-2 py-1 rounded-full">Quantum</span>
                                        </div>
                                        <p class="text-sm text-muted mb-2">Gravitational phase shift of neutron waves</p>
                                        <div class="bg-code-bg rounded-lg p-3 font-mono text-xs">
                                            <div>SOTA: <span class="text-accent">2.70 Â± 0.21</span> radians</div>
                                            <div>Source: Colella et al. (1975), PRL</div>
                                        </div>
                                    </div>
                                    
                                    <!-- PSR J0740 -->
                                    <div class="border border-code-border rounded-xl p-4 hover:border-accent/50 transition-colors">
                                        <div class="flex justify-between items-start mb-2">
                                            <h4 class="font-bold text-ink">PSR J0740+6620</h4>
                                            <span class="text-xs bg-success/10 text-success px-2 py-1 rounded-full">Classical</span>
                                        </div>
                                        <p class="text-sm text-muted mb-2">Shapiro delay in massive pulsar system</p>
                                        <div class="bg-code-bg rounded-lg p-3 font-mono text-xs">
                                            <div>Mass: <span class="text-accent">2.08 Â± 0.07</span> Mâ˜‰</div>
                                            <div>Source: Fonseca et al. (2021), ApJL</div>
                                        </div>
                                    </div>
                                    
                                    <!-- Gravitational Waves -->
                                    <div class="border border-code-border rounded-xl p-4 hover:border-accent/50 transition-colors">
                                        <div class="flex justify-between items-start mb-2">
                                            <h4 class="font-bold text-ink">Gravitational Waves</h4>
                                            <span class="text-xs bg-success/10 text-success px-2 py-1 rounded-full">Classical</span>
                                        </div>
                                        <p class="text-sm text-muted mb-2">Post-Newtonian waveform analysis</p>
                                        <div class="bg-code-bg rounded-lg p-3 font-mono text-xs">
                                            <div>SOTA: <span class="text-accent">LIGO-Virgo</span> waveforms</div>
                                            <div>Source: Abbott et al. (2016-2024)</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Prediction Tests -->
                            <div class="bg-white rounded-3xl shadow-xl p-8 border border-quantum/20">
                                <h3 class="text-2xl font-bold text-quantum mb-6 flex items-center gap-3">
                                    <svg class="w-8 h-8 text-quantum" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"></path>
                                    </svg>
                                    Solver-Based Tests (7 tests)
                                </h3>
                                
                                <div class="space-y-4">
                                    <!-- Trajectory vs Kerr -->
                                    <div class="border border-code-border rounded-xl p-4 hover:border-quantum/50 transition-colors">
                                        <div class="flex justify-between items-start mb-2">
                                            <h4 class="font-bold text-ink">Trajectory vs. Kerr</h4>
                                            <span class="text-xs bg-success/10 text-success px-2 py-1 rounded-full">Classical</span>
                                        </div>
                                        <p class="text-sm text-muted mb-2">1000-step geodesic integration comparison</p>
                                        <div class="bg-code-bg rounded-lg p-3 font-mono text-xs">
                                            <div>SOTA: <span class="text-accent">Kerr metric</span> baseline</div>
                                            <div>Metric: Loss function over trajectory</div>
                                        </div>
                                    </div>
                                    
                                    <!-- Circular Orbit -->
                                    <div class="border border-code-border rounded-xl p-4 hover:border-quantum/50 transition-colors">
                                        <div class="flex justify-between items-start mb-2">
                                            <h4 class="font-bold text-ink">Circular Orbit Period</h4>
                                            <span class="text-xs bg-success/10 text-success px-2 py-1 rounded-full">Classical</span>
                                        </div>
                                        <p class="text-sm text-muted mb-2">Tests Kepler's third law in strong field</p>
                                        <div class="bg-code-bg rounded-lg p-3 font-mono text-xs">
                                            <div>SOTA: <span class="text-accent">GR prediction</span></div>
                                            <div>Uses: RK4 geodesic solver</div>
                                        </div>
                                    </div>
                                    
                                    <!-- Quantum Geodesic Sim -->
                                    <div class="border border-code-border rounded-xl p-4 hover:border-quantum/50 transition-colors">
                                        <div class="flex justify-between items-start mb-2">
                                            <h4 class="font-bold text-ink">Quantum Geodesic Simulation</h4>
                                            <span class="text-xs bg-quantum/10 text-quantum px-2 py-1 rounded-full">Quantum</span>
                                        </div>
                                        <p class="text-sm text-muted mb-2">2-qubit quantum path simulation</p>
                                        <div class="bg-code-bg rounded-lg p-3 font-mono text-xs">
                                            <div>Tests: <span class="text-accent">Quantum corrections</span></div>
                                            <div>Method: Quantum circuit simulation</div>
                                        </div>
                                    </div>
                                    
                                    <!-- CMB Power Spectrum -->
                                    <div class="border border-code-border rounded-xl p-4 hover:border-quantum/50 transition-colors">
                                        <div class="flex justify-between items-start mb-2">
                                            <h4 class="font-bold text-ink">CMB Power Spectrum</h4>
                                            <span class="text-xs bg-warning/10 text-warning px-2 py-1 rounded-full">Cosmological</span>
                                        </div>
                                        <p class="text-sm text-muted mb-2">Low-â„“ anomaly and Sachs-Wolfe plateau</p>
                                        <div class="bg-code-bg rounded-lg p-3 font-mono text-xs">
                                            <div>SOTA: Î›CDM <span class="text-accent">Ï‡Â²/dof ~ 1.02</span></div>
                                            <div>Source: Planck 2018 + low-â„“ anomaly</div>
                                        </div>
                                    </div>
                                    
                                    <!-- Primordial GWs -->
                                    <div class="border border-code-border rounded-xl p-4 hover:border-quantum/50 transition-colors">
                                        <div class="flex justify-between items-start mb-2">
                                            <h4 class="font-bold text-ink">Primordial Gravitational Waves</h4>
                                            <span class="text-xs bg-warning/10 text-warning px-2 py-1 rounded-full">Cosmological</span>
                                        </div>
                                        <p class="text-sm text-muted mb-2">Tensor-to-scalar ratio constraints</p>
                                        <div class="bg-code-bg rounded-lg p-3 font-mono text-xs">
                                            <div>SOTA: r < <span class="text-accent">0.032</span> (95% CL)</div>
                                            <div>Source: BICEP/Keck + Planck 2023</div>
                                            <div>Future: CMB-S4 target r ~ 0.001</div>
                                        </div>
                                    </div>
                                    
                                    <!-- g-2 Muon -->
                                    <div class="border border-code-border rounded-xl p-4 hover:border-quantum/50 transition-colors">
                                        <div class="flex justify-between items-start mb-2">
                                            <h4 class="font-bold text-ink">Muon g-2 Anomaly</h4>
                                            <span class="text-xs bg-quantum/10 text-quantum px-2 py-1 rounded-full">Quantum</span>
                                        </div>
                                        <p class="text-sm text-muted mb-2">Anomalous magnetic moment precision test</p>
                                        <div class="bg-code-bg rounded-lg p-3 font-mono text-xs">
                                            <div>Experiment: <span class="text-accent">0.00116592059(22)</span></div>
                                            <div>Theory: <span class="text-accent">0.00116591783(48)</span></div>
                                            <div>Source: Theory Initiative 2020</div>
                                        </div>
                                    </div>
                                    
                                    <!-- Scattering Amplitude -->
                                    <div class="border border-code-border rounded-xl p-4 hover:border-quantum/50 transition-colors">
                                        <div class="flex justify-between items-start mb-2">
                                            <h4 class="font-bold text-ink">eâºeâ» Scattering</h4>
                                            <span class="text-xs bg-quantum/10 text-quantum px-2 py-1 rounded-full">Quantum</span>
                                        </div>
                                        <p class="text-sm text-muted mb-2">High-energy scattering at Z pole</p>
                                        <div class="bg-code-bg rounded-lg p-3 font-mono text-xs">
                                            <div>Ïƒ(eâºeâ»â†’Î¼âºÎ¼â»): <span class="text-accent">1.477 Â± 0.005</span> nb</div>
                                            <div>Source: LEP @ 91.2 GeV (Z pole)</div>
                                        </div>
                                    </div>

                                </div>
                            </div>
                        </div>

                    </div>

                
                    
                    <!-- Call to Action - More Prominent -->
                    <div class="text-center">
                        <div class="inline-flex flex-col sm:flex-row gap-4">
                            
                            <a href="documentation.html" target="_blank" class="group inline-flex items-center space-x-3 bg-white hover:bg-paper border-2 border-accent text-accent px-8 py-4 rounded-xl font-semibold text-lg transition-all transform hover:scale-105 shadow-lg hover:shadow-xl">
                                <span>Read Docs</span>
                                <svg class="w-5 h-5 group-hover:translate-x-1 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                                </svg>
                            </a>
                            
                            <a href="../latest_run/latest_report.html" target="_blank" class="group inline-flex items-center space-x-3 bg-quantum hover:bg-quantum/90 text-white px-8 py-4 rounded-xl font-semibold text-lg transition-all transform hover:scale-105 shadow-lg hover:shadow-xl">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 17v1a1 1 0 001 1h4a1 1 0 001-1v-1m3-3.45V9.86c0-.97-.78-1.76-1.75-1.76H15l-1-3.24a1 1 0 00-.95-.68h-2.1a1 1 0 00-.95.68L9 8.1H7.75C6.78 8.1 6 8.89 6 9.86v3.69m12-3.45h.01M6 13.1h.01"></path>
                                </svg>
                                <span>View Latest Results</span>
                            </a>
                        </div>
                    </div>
                </div>
            </div>
    </main>

    <!-- Footer -->
    <footer class="bg-paper border-t border-code-border mt-16">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-16">
            <div class="text-center">
                <!-- Footer Einstein image -->
                
                <p class="text-sm text-muted italic font-serif">
                    "The important thing is not to stop questioning. Curiosity has its own reason for existing."
                </p>
                <p class="text-xs text-muted mt-2">â€” Albert Einstein</p>
                <div class="mt-8 text-xs text-muted">
                    <p>MIT Licensed â€¢ Open Source â€¢ Built with â¤ï¸ for physics</p>
                    <p class="mt-2">Â© 2025 Pim de Witte</p>
                </div>
            </div>
        </div>
    </footer>

    <!-- Animation Scripts -->
    <script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script>
        // Global color palette for canvas drawings
        const colors = {
            ink: '#2D2D2D',
            paper: '#FAF8F3',
            accent: '#1A3A8A',
            muted: '#8B7355',
            success: '#556B2F',
            danger: '#B91C1C',
            warning: '#D97706',
            quantum: '#059669',
            extreme: '#7C3AED',
            canvasBg: '#FAF8F3',
            canvasStroke: '#E5E7EB',
            codeBg: '#FAF8F3',
            codeBorder: '#E8E2D8'
        };
        
        // Smooth scrolling for navigation
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });
        
        // Counting Animation for statistics
        function animateCounters() {
            const counters = document.querySelectorAll('.counting-animation');
            
            const observerOptions = {
                threshold: 0.5,
                rootMargin: '0px'
            };
            
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const counter = entry.target;
                        const target = parseInt(counter.getAttribute('data-target'));
                        const duration = 2000; // 2 seconds
                        const start = 0;
                        const increment = target / (duration / 16); // 60fps
                        
                        let current = start;
                        const timer = setInterval(() => {
                            current += increment;
                            if (current >= target) {
                                current = target;
                                clearInterval(timer);
                            }
                            counter.textContent = Math.floor(current).toLocaleString();
                        }, 16);
                        
                        observer.unobserve(counter);
                    }
                });
            }, observerOptions);
            
            counters.forEach(counter => observer.observe(counter));
        }
        
        // Initialize counting animations
        setTimeout(animateCounters, 500);
        
        // Einstein's equations section removed - now using HTML interactive version
        // (Canvas code removed - replaced with simpler HTML row-based interaction)


        
        // Unification Journey Animation
        const unificationCanvas = document.getElementById('unificationCanvas');
        if (unificationCanvas) {
            const ctx = unificationCanvas.getContext('2d');
            let animationTime = 0;
            let particles = [];
            
            // Create two groups of particles - GR and QM
            for (let i = 0; i < 100; i++) {
                // General Relativity particles (left side)
                particles.push({
                    x: Math.random() * 300 + 50,
                    y: Math.random() * 400 + 200,
                    vx: Math.random() * 2 - 1,
                    vy: Math.random() * 2 - 1,
                    type: 'GR',
                    color: '#1A3A8A',
                    size: Math.random() * 3 + 2
                });
                
                // Quantum Mechanics particles (right side)
                particles.push({
                    x: Math.random() * 300 + 850,
                    y: Math.random() * 400 + 200,
                    vx: Math.random() * 2 - 1,
                    vy: Math.random() * 2 - 1,
                    type: 'QM',
                    color: '#10b981',
                    size: Math.random() * 3 + 2,
                    phase: Math.random() * Math.PI * 2
                });
            }
            
            function drawUnification() {
                ctx.clearRect(0, 0, unificationCanvas.width, unificationCanvas.height);
                
                // Background
                ctx.fillStyle = colors.paper;
                ctx.fillRect(0, 0, unificationCanvas.width, unificationCanvas.height);
                
                // Title
                ctx.font = 'bold 32px Playfair Display, serif';
                ctx.fillStyle = '#1A3A8A';
                ctx.textAlign = 'center';
                ctx.fillText('The Journey to Unification', unificationCanvas.width/2, 50);
                
                // Progress bars
                const barY = 100;
                const barHeight = 30;
                const barSpacing = 50;
                
                // Classical Gravity - Complete
                ctx.fillStyle = '#E5E7EB';
                ctx.fillRect(200, barY, 800, barHeight);
                ctx.fillStyle = '#10b981';
                ctx.fillRect(200, barY, 800, barHeight);
                
                ctx.font = '16px EB Garamond, serif';
                ctx.fillStyle = '#2D2D2D';
                ctx.textAlign = 'left';
                ctx.fillText('ðŸ“ Classical Gravity', 50, barY + 20);
                ctx.textAlign = 'right';
                ctx.fillText('âœ“ ACHIEVED', 1050, barY + 20);
                
                // Quantum Integration - In Progress
                const quantumProgress = 0.75 + Math.sin(animationTime * 0.02) * 0.05;
                ctx.fillStyle = '#E5E7EB';
                ctx.fillRect(200, barY + barSpacing, 800, barHeight);
                ctx.fillStyle = '#f59e0b';
                ctx.fillRect(200, barY + barSpacing, 800 * quantumProgress, barHeight);
                
                ctx.textAlign = 'left';
                ctx.fillText('âš›ï¸ Quantum Integration', 50, barY + barSpacing + 20);
                ctx.textAlign = 'right';
                ctx.fillText('â†’ IN PROGRESS', 1050, barY + barSpacing + 20);
                
                // Complete Unification - Future
                const unificationProgress = 0.35 + Math.sin(animationTime * 0.01) * 0.02;
                ctx.fillStyle = '#E5E7EB';
                ctx.fillRect(200, barY + barSpacing * 2, 800, barHeight);
                ctx.fillStyle = '#1A3A8A';
                ctx.fillRect(200, barY + barSpacing * 2, 800 * unificationProgress, barHeight);
                
                ctx.textAlign = 'left';
                ctx.fillText('â™¾ï¸ Complete Unification', 50, barY + barSpacing * 2 + 20);
                ctx.textAlign = 'right';
                ctx.fillText('âš¡ NEXT MILESTONE', 1050, barY + barSpacing * 2 + 20);
                
                // Particle visualization
                const centerX = unificationCanvas.width / 2;
                const mergeProgress = Math.max(0, (animationTime - 300) / 300);
                
                particles.forEach(p => {
                    // Update position
                    p.x += p.vx;
                    p.y += p.vy;
                    
                    // Attraction to center after some time
                    if (animationTime > 300) {
                        const dx = centerX - p.x;
                        const dy = 400 - p.y;
                        p.vx += dx * 0.0001 * mergeProgress;
                        p.vy += dy * 0.0001 * mergeProgress;
                        p.vx *= 0.99;
                        p.vy *= 0.99;
                    }
                    
                    // Quantum particles have wave behavior
                    if (p.type === 'QM') {
                        p.y += Math.sin(p.phase + animationTime * 0.05) * 0.5;
                    }
                    
                    // Draw particle
                    ctx.globalAlpha = 0.6;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                });
                
                // Labels
                if (animationTime < 300) {
                    ctx.font = '20px Playfair Display, serif';
                    ctx.fillStyle = '#1A3A8A';
                    ctx.textAlign = 'center';
                    ctx.fillText('General Relativity', 200, 350);
                    
                    ctx.fillStyle = '#10b981';
                    ctx.fillText('Quantum Mechanics', 1000, 350);
                } else {
                    // Unified label
                    const unifiedAlpha = Math.min((animationTime - 300) / 100, 1);
                    ctx.globalAlpha = unifiedAlpha;
                    ctx.font = '24px Playfair Display, serif';
                    ctx.fillStyle = '#8B5CF6';
                    ctx.textAlign = 'center';
                    ctx.fillText('Unified Theory', centerX, 350);
                    ctx.globalAlpha = 1;
                }
                
                // Recent breakthroughs
                if (animationTime > 400) {
                    const breakthroughAlpha = Math.min((animationTime - 400) / 100, 1);
                    ctx.globalAlpha = breakthroughAlpha;
                    
                    ctx.font = '14px JetBrains Mono, monospace';
                    ctx.fillStyle = '#556B2F';
                    ctx.textAlign = 'left';
                    
                    const codeY = 550;
                    ctx.fillText('âœ“ Quantum Lagrangian: base_theory.py:L287', 100, codeY);
                    ctx.fillText('âœ“ Path integrals: quantum_path_integrator.py', 100, codeY + 25);
                    ctx.fillText('âœ“ Renormalizability: validations/renormalizability.py', 100, codeY + 50);
                    
                    ctx.fillStyle = '#3B82F6';
                    ctx.textAlign = 'right';
                    ctx.fillText('â†’ Entropy gravity (2025)', 1100, codeY);
                    ctx.fillText('â†’ Gauge unification 10Â¹â¶ GeV', 1100, codeY + 25);
                    ctx.fillText('â†’ Black hole information', 1100, codeY + 50);
                    
                    ctx.globalAlpha = 1;
                }
                
                animationTime++;
                requestAnimationFrame(drawUnification);
            }
            
            drawUnification();
        }
        
        // Copy install command function
        function copyInstallCommand() {
            const command = document.getElementById('install-command').textContent;
            navigator.clipboard.writeText(command).then(() => {
                // Show check icon
                document.getElementById('copy-icon').classList.add('hidden');
                document.getElementById('check-icon').classList.remove('hidden');
                
                // Show tooltip
                const tooltip = document.getElementById('copy-tooltip');
                tooltip.classList.remove('opacity-0');
                
                // Reset after 2 seconds
                setTimeout(() => {
                    document.getElementById('copy-icon').classList.remove('hidden');
                    document.getElementById('check-icon').classList.add('hidden');
                    tooltip.classList.add('opacity-0');
                }, 2000);
            });
        }

        // Copy homepage command function
        function copyHomepageCommand() {
            const command = 'curl -fsSL https://albert.so/install | bash';
            navigator.clipboard.writeText(command).then(() => {
                // Show check icon
                document.getElementById('homepage-copy-icon').classList.add('hidden');
                document.getElementById('homepage-check-icon').classList.remove('hidden');
                
                // Show tooltip
                const tooltip = document.getElementById('homepage-copy-tooltip');
                tooltip.classList.remove('opacity-0');
                
                // Reset after 2 seconds
                setTimeout(() => {
                    document.getElementById('homepage-copy-icon').classList.remove('hidden');
                    document.getElementById('homepage-check-icon').classList.add('hidden');
                    tooltip.classList.add('opacity-0');
                }, 2000);
            });
        }
        
        // Setup modal functions
        function openSetupModal() {
            document.getElementById('setupModal').classList.remove('hidden');
            document.body.style.overflow = 'hidden'; // Prevent body scroll
        }
        
        function closeSetupModal() {
            document.getElementById('setupModal').classList.add('hidden');
            document.body.style.overflow = ''; // Restore body scroll
        }
        
        // Close modal on Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeSetupModal();
            }
        });
        

        
        // Animate counter
        let albertCount = 500;
        const counterElement = document.getElementById('albert-counter');
        
        setInterval(() => {
            // Simulate random changes
            const change = Math.floor(Math.random() * 5) - 2;
            albertCount = Math.max(1, albertCount + change);
            if (counterElement) counterElement.textContent = albertCount;
        }, 3000);
        
        // 6D Solver Visualization - Simple Explanation
        const solver6DCanvas = document.getElementById('solver6DShowcase');
        if (solver6DCanvas) {
            const ctx = solver6DCanvas.getContext('2d');
            let animationTime = 0;
            let particles4D = [];
            let particles6D = [];
            
            // Initialize particles
            for (let i = 0; i < 5; i++) {
                // 4D particle (breaks when spinning)
                particles4D.push({
                    x: 300,
                    y: 300,
                    angle: (Math.PI * 2 / 5) * i,
                    radius: 100,
                    broken: false
                });
                
                // 6D particle (handles everything)
                particles6D.push({
                    x: 900,
                    y: 300,
                    vx: 0,
                    vy: 0,
                    angle: (Math.PI * 2 / 5) * i,
                    radius: 100
                });
            }
            
            function draw6DSolver() {
                ctx.clearRect(0, 0, solver6DCanvas.width, solver6DCanvas.height);
                
                // Background
                                    ctx.fillStyle = colors.canvasBg;
                ctx.fillRect(0, 0, solver6DCanvas.width, solver6DCanvas.height);
                
                // Title
                ctx.font = 'bold 28px Playfair Display, serif';
                ctx.fillStyle = '#1A3A8A';
                ctx.textAlign = 'center';
                ctx.fillText('Why We Need 6 Dimensions Instead of 4', solver6DCanvas.width/2, 40);
                
                // Left side - 4D Traditional
                ctx.font = 'bold 20px Playfair Display, serif';
                ctx.fillStyle = '#dc2626';
                ctx.fillText('4D: Position + Time', 300, 90);
                
                // Draw rotating black hole (4D)
                ctx.strokeStyle = '#dc2626';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(300, 300, 120, 0, Math.PI * 2);
                ctx.stroke();
                
                // Central mass
                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.arc(300, 300, 30, 0, Math.PI * 2);
                ctx.fill();
                
                // Particles in 4D
                particles4D.forEach((p, i) => {
                    p.angle += 0.02;
                    p.x = 300 + Math.cos(p.angle) * p.radius;
                    p.y = 300 + Math.sin(p.angle) * p.radius;
                    
                    // Break when spinning fast (after some time)
                    if (animationTime > 200 && animationTime < 400) {
                        p.radius += Math.random() * 2 - 1;
                        p.broken = true;
                    }
                    
                    ctx.fillStyle = p.broken ? '#dc2626' : '#3b82f6';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 8, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                // Error message for 4D
                if (animationTime > 200 && animationTime < 400) {
                    ctx.font = 'bold 18px JetBrains Mono, monospace';
                    ctx.fillStyle = '#dc2626';
                    ctx.fillText('âŒ SYMMETRY BROKEN!', 300, 450);
                    ctx.font = '14px EB Garamond, serif';
                    ctx.fillText('Cannot handle rotation + gravity', 300, 480);
                }
                
                // Right side - 6D Solution
                ctx.font = 'bold 20px Playfair Display, serif';
                ctx.fillStyle = '#10b981';
                ctx.fillText('6D: Position + Velocity', 900, 90);
                
                // Draw rotating black hole (6D)
                ctx.strokeStyle = '#10b981';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(900, 300, 120, 0, Math.PI * 2);
                ctx.stroke();
                
                // Spiral to show frame dragging
                ctx.strokeStyle = '#10b98133';
                ctx.lineWidth = 1;
                for (let r = 30; r < 120; r += 15) {
                    ctx.beginPath();
                    for (let angle = 0; angle < Math.PI * 4; angle += 0.1) {
                        const x = 900 + Math.cos(angle + animationTime * 0.01) * (r + angle * 2);
                        const y = 300 + Math.sin(angle + animationTime * 0.01) * (r + angle * 2);
                        if (angle === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.stroke();
                }
                
                // Central mass
                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.arc(900, 300, 30, 0, Math.PI * 2);
                ctx.fill();
                
                // Particles in 6D - smooth orbits
                particles6D.forEach((p, i) => {
                    // Update velocity based on physics
                    const dx = 900 - p.x;
                    const dy = 300 - p.y;
                    const r = Math.sqrt(dx * dx + dy * dy);
                    
                    // Gravity + frame dragging
                    p.vx += (dx / r) * 0.5;
                    p.vy += (dy / r) * 0.5;
                    
                    // Add tangential velocity (frame dragging)
                    p.vx += -dy / r * 0.1;
                    p.vy += dx / r * 0.1;
                    
                    // Damping
                    p.vx *= 0.98;
                    p.vy *= 0.98;
                    
                    // Update position
                    p.x += p.vx;
                    p.y += p.vy;
                    
                    // Draw particle
                    ctx.fillStyle = '#10b981';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Velocity vector
                    ctx.strokeStyle = '#10b98166';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.lineTo(p.x + p.vx * 10, p.y + p.vy * 10);
                    ctx.stroke();
                });
                
                // Success message for 6D
                ctx.font = 'bold 18px JetBrains Mono, monospace';
                ctx.fillStyle = '#10b981';
                ctx.fillText('âœ“ HANDLES EVERYTHING!', 900, 450);
                ctx.font = '14px EB Garamond, serif';
                ctx.fillText('Rotation, asymmetry, quantum effects', 900, 480);
                
                // Bottom explanation
                ctx.font = '16px EB Garamond, serif';
                ctx.fillStyle = '#8B7355';
                ctx.textAlign = 'center';
                ctx.fillText('Traditional methods assume constant energy/momentum. Reality doesn\'t care about our assumptions.', solver6DCanvas.width/2, 550);
                
                // Reset particles periodically
                if (animationTime > 500) {
                    animationTime = 0;
                    particles4D.forEach((p, i) => {
                        p.angle = (Math.PI * 2 / 5) * i;
                        p.radius = 100;
                        p.broken = false;
                    });
                    particles6D.forEach((p, i) => {
                        p.x = 900 + Math.cos((Math.PI * 2 / 5) * i) * 100;
                        p.y = 300 + Math.sin((Math.PI * 2 / 5) * i) * 100;
                        p.vx = 0;
                        p.vy = 0;
                    });
                }
                
                animationTime++;
                requestAnimationFrame(draw6DSolver);
            }
            
            draw6DSolver();
        }
        
        // Theory Engine Visualization - Multi-Step Testing Process
        const theoryEngineCanvas = document.getElementById('theoryEngineCanvas');
        if (theoryEngineCanvas) {
            const ctx = theoryEngineCanvas.getContext('2d');
            let animationTime = 0;
            let codeLines = [];
            let trajectory = [];
            let kerrTrajectory = [];
            let loss = null;
            let verdict = null;
            
            // Initialize trajectories
            function initTrajectories() {
                trajectory = [];
                kerrTrajectory = [];
                // Generate test trajectory
                for (let i = 0; i < 200; i++) {
                    const angle = i * 0.1;
                    const r = 150 + Math.sin(angle * 0.3) * 20 + Math.random() * 5;
                    trajectory.push({ angle, r });
                    // Kerr baseline (more stable)
                    const kerrR = 150 + Math.sin(angle * 0.3) * 15;
                    kerrTrajectory.push({ angle, r: kerrR });
                }
            }
            initTrajectories();
            
            // Theory code that will be typed
            const step1Code = [
                '# Example: Modified gravity with additional parameter',
                '',
                'def metric_tensor(self, r, M):',
                '    # Start with Einstein\'s solution',
                '    rs = 2 * G * M / c**2',
                '    ',
                '    # Add modification term',
                '    correction = alpha * (rs/r)**2',
                '    ',
                '    g_tt = -(1 - rs/r + correction)',
                '    g_rr = 1 / (1 - rs/r + correction)',
                '    ',
                '    return g_tt, g_rr, g_Î¸Î¸, g_Ï†Ï†'
            ];
            
            function drawTheoryEngine() {
                ctx.clearRect(0, 0, theoryEngineCanvas.width, theoryEngineCanvas.height);
                
                // Background
                ctx.fillStyle = colors.canvasBg;
                ctx.fillRect(0, 0, theoryEngineCanvas.width, theoryEngineCanvas.height);
                
                // Title
                ctx.font = 'bold 28px Playfair Display, serif';
                ctx.fillStyle = colors.accent;
                ctx.textAlign = 'center';
                ctx.fillText('Theory Implementations', theoryEngineCanvas.width/2, 40);
                
                // Subtitle
                ctx.font = '16px EB Garamond, serif';
                ctx.fillStyle = colors.muted;
                ctx.fillText('Comparing gravitational theories against black hole orbits', theoryEngineCanvas.width/2, 70);
                
                // Two panels side by side
                const leftPanelX = 50;
                const rightPanelX = 650;
                const panelY = 100;
                const panelWidth = 500;
                const panelHeight = 600;
                
                // Left panel - Trajectory visualization
                ctx.fillStyle = colors.codeBg;
                ctx.fillRect(leftPanelX, panelY, panelWidth, panelHeight);
                ctx.strokeStyle = colors.codeBorder;
                ctx.lineWidth = 2;
                ctx.strokeRect(leftPanelX, panelY, panelWidth, panelHeight);
                
                ctx.font = '20px Playfair Display, serif';
                ctx.fillStyle = colors.accent;
                ctx.textAlign = 'center';
                ctx.fillText('Black Hole Trajectory Simulation', leftPanelX + panelWidth/2, panelY + 35);
                
                // Draw visualizations based on current step
                const centerX = leftPanelX + panelWidth/2;
                const centerY = panelY + panelHeight/2 + 20;
                    // STEP 1: Classical black hole trajectory test
                    // Black hole
                    const blackHoleRadius = 25;
                    ctx.fillStyle = colors.ink;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, blackHoleRadius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Event horizon
                    ctx.strokeStyle = colors.danger + '60';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, blackHoleRadius * 2, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Draw Kerr baseline trajectory
                    ctx.strokeStyle = colors.muted;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    const kerrSteps = Math.min(animationTime * 0.8, kerrTrajectory.length); // Slower
                    for (let i = 0; i < kerrSteps; i++) {
                        const point = kerrTrajectory[i];
                        const x = centerX + Math.cos(point.angle) * point.r * 0.8;
                        const y = centerY + Math.sin(point.angle) * point.r * 0.8;
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.stroke();
                    
                    // Draw test theory trajectory
                    ctx.strokeStyle = colors.accent;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    const steps = Math.min(animationTime * 0.8, trajectory.length); // Slower
                    for (let i = 0; i < steps; i++) {
                        const point = trajectory[i];
                        const x = centerX + Math.cos(point.angle) * point.r * 0.8;
                        const y = centerY + Math.sin(point.angle) * point.r * 0.8;
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.stroke();
                    
                    // Legend
                    ctx.font = '14px EB Garamond, serif';
                    ctx.fillStyle = colors.muted;
                    ctx.textAlign = 'left';
                    ctx.fillText('â€” Kerr (baseline)', leftPanelX + 20, panelY + panelHeight - 40);
                    ctx.fillStyle = colors.accent;
                    ctx.fillText('â€” Test theory', leftPanelX + 20, panelY + panelHeight - 20);

                
                // Right panel - Code generation
                ctx.fillStyle = colors.codeBg;
                ctx.fillRect(rightPanelX, panelY, panelWidth, panelHeight);
                ctx.strokeStyle = colors.codeBorder;
                ctx.strokeRect(rightPanelX, panelY, panelWidth, panelHeight);
                
                ctx.font = '20px Playfair Display, serif';
                ctx.fillStyle = colors.success;
                ctx.textAlign = 'center';
                ctx.fillText('Generated Metric Tensor', rightPanelX + panelWidth/2, panelY + 35);
                
                // Type out code
                ctx.font = '14px JetBrains Mono, monospace';
                ctx.textAlign = 'left';
                const codeY = panelY + 70;
                const lineHeight = 22;
                
                // Select code based on current step
                const codeToShow = step1Code;
                
                // Calculate how many lines to show - faster typing
                const charsPerFrame = 1.5;
                const totalChars = Math.max(0, animationTime * charsPerFrame);
                let charCount = 0;
                
                // Syntax highlighting helper
                function getLineColor(line) {
                    if (line.trim().startsWith('#')) return colors.muted;
                    if (line.includes('def ') || line.includes('return')) return colors.accent;
                    if (line.includes('Einstein') || line.includes('quantum')) return colors.quantum;
                    if (line.includes('â„') || line.includes('Î±') || line.includes('Ïˆ') || line.includes('âˆ‡')) return colors.warning;
                    if (line.includes('g_') || line.includes('Q =') || line.includes('phase')) return colors.success;
                    return colors.ink;
                }
                
                for (let i = 0; i < codeToShow.length; i++) {
                    const line = codeToShow[i];
                    const y = codeY + i * lineHeight;
                    
                    if (charCount + line.length <= totalChars) {
                        // Full line with syntax highlighting
                        ctx.fillStyle = getLineColor(line);
                        ctx.fillText(line, rightPanelX + 20, y);
                        charCount += line.length;
                    } else if (charCount < totalChars) {
                        // Partial line
                        const charsToShow = totalChars - charCount;
                        ctx.fillStyle = getLineColor(line);
                        ctx.fillText(line.substring(0, charsToShow), rightPanelX + 20, y);
                        
                        // Cursor
                        if (animationTime % 30 < 15) {
                            const cursorX = rightPanelX + 20 + ctx.measureText(line.substring(0, charsToShow)).width;
                            ctx.fillRect(cursorX, y - 15, 2, 18);
                        }
                        break;
                    }
                }
                
                // Loss calculation and verdict (appears after code is typed)
                const resultTiming = 300;
                if (animationTime > resultTiming) {
                    
                    // Calculate results
                    if (!loss) {
                        // Classical trajectory comparison
                        let sumSquaredDiff = 0;
                        const compareSteps = Math.min(trajectory.length, kerrTrajectory.length);
                        for (let i = 0; i < compareSteps; i++) {
                            const diff = trajectory[i].r - kerrTrajectory[i].r;
                            sumSquaredDiff += diff * diff;
                        }
                        loss = (sumSquaredDiff / compareSteps).toFixed(4);
                        verdict = loss < 50 ? 'PASS' : 'FAIL';
                    }
                    
                    // Draw results box
                    const resultsY = panelY + panelHeight - 180;
                    const bgColor = verdict === 'PASS' ? colors.success + '20' : colors.danger + '20';
                    const borderColor = verdict === 'PASS' ? colors.success : colors.danger;
                    
                    ctx.fillStyle = bgColor;
                    ctx.fillRect(rightPanelX + 20, resultsY, panelWidth - 40, 150);
                    ctx.strokeStyle = borderColor;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(rightPanelX + 20, resultsY, panelWidth - 40, 150);
                    
                    // Results text
                    ctx.font = 'bold 18px EB Garamond, serif';
                    ctx.fillStyle = colors.ink;
                    ctx.textAlign = 'center';
                    ctx.fillText('Classical Test Results', rightPanelX + panelWidth/2, resultsY + 30);
                    
                    ctx.font = '16px JetBrains Mono, monospace';
                    ctx.fillStyle = colors.ink;
                    ctx.fillText(`MSE Loss: ${loss}`, rightPanelX + panelWidth/2, resultsY + 60);
                    
                    ctx.font = 'bold 24px Playfair Display, serif';
                    ctx.fillStyle = verdict === 'PASS' ? colors.success : colors.danger;
                    ctx.fillText(`Verdict: ${verdict}`, rightPanelX + panelWidth/2, resultsY + 100);
                    
                    ctx.font = '14px EB Garamond, serif';
                    ctx.fillStyle = colors.muted;
                    ctx.fillText(verdict === 'PASS' ? 'Theory matches classical limit' : 'Excessive deviation detected', 
                                rightPanelX + panelWidth/2, resultsY + 130);
                }
                
                // Progress indicator
                ctx.font = '14px EB Garamond, serif';
                ctx.fillStyle = colors.muted;
                ctx.textAlign = 'center';
                const progress = Math.min(100, (animationTime / 4));
                ctx.fillText(`Progress: ${progress.toFixed(0)}%`, theoryEngineCanvas.width/2, theoryEngineCanvas.height - 20);
                
                // Update animation
                animationTime++;
                
                // Reset after animation completes
                if (animationTime > 500) {
                    animationTime = 0;
                    loss = null;
                    verdict = null;
                    initTrajectories(); // Reset with new random variations
                }
                
                requestAnimationFrame(drawTheoryEngine);
            }
            
            drawTheoryEngine();
        }
        
        // Validation Gauntlet Visualization
        const validationGauntletCanvas = document.getElementById('validationGauntletCanvas');
        if (validationGauntletCanvas) {
            const ctx = validationGauntletCanvas.getContext('2d');
            let animationTime = 0;
            let theories = [];
            let failedTheories = [];
            
            // Initialize theories - only 8 for easier tracking
            const particleTypes = [
                {name: 'Photon', color: '#D97706', symbol: 'Î³'},
                {name: 'Electron', color: '#059669', symbol: 'eâ»'},
                {name: 'Proton', color: '#556B2F', symbol: 'pâº'},
                {name: 'Neutron', color: '#8B7355', symbol: 'n'},
                {name: 'Neutrino', color: '#7C3AED', symbol: 'Î½'},
                {name: 'Muon (Not yet implemented)', color: '#1A3A8A', symbol: 'Î¼'},
                {name: 'Tau (Not yet implemented)', color: '#B91C1C', symbol: 'Ï„'},
                {name: 'Higgs (Not yet implemented)', color: '#10b981', symbol: 'H'}
    
            ];
            
            // Assign to theories - spawning from further left since stage moved to x:100
            for (let i = 0; i < 8; i++) {
                theories.push({
                    id: i,
                    x: -150 - (i * 30),  // Further left to match new Generated Theory position
                    y: 80 + (i % 3) * 20,
                    status: 'pending',
                    failReason: null,
                    tests: 0,
                    opacity: 1,
                    label: `T${i + 1}`,
                    particle: particleTypes[i]  // New: assign particle type
                });
            }
            
            function drawValidationGauntlet() {
                ctx.clearRect(0, 0, validationGauntletCanvas.width, validationGauntletCanvas.height);
                
                // Background
                ctx.fillStyle = colors.canvasBg;
                ctx.fillRect(0, 0, validationGauntletCanvas.width, validationGauntletCanvas.height);
                
                // Title
                ctx.font = 'bold 24px Playfair Display, serif';
                ctx.fillStyle = colors.accent;
                ctx.textAlign = 'center';
                ctx.fillText('Every proposal goes through a set of validators', validationGauntletCanvas.width/2, 30);
                
                // Draw the gauntlet stages
                const stages = [
                    { name: 'Generated Theory', x: 100, color: colors.muted, icon: 'ðŸ§¬' },
                    { name: 'Constraints', x: 400, color: colors.warning },
                    { name: 'Classical', x: 600, color: colors.accent },
                    { name: 'Exit', x: 1000, color: colors.success }
                ];
                
                // Draw connections
                ctx.strokeStyle = colors.codeBorder;
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(stages[0].x, 80);
                ctx.lineTo(stages[stages.length - 1].x, 80);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Draw stages
                stages.forEach(stage => {
                    // Stage circle
                    ctx.fillStyle = stage.color;
                    ctx.beginPath();
                    ctx.arc(stage.x, 80, 25, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw icon if present
                    if (stage.icon) {
                        ctx.font = '20px serif';
                        ctx.fillStyle = colors.paper;
                        ctx.textAlign = 'center';
                        ctx.fillText(stage.icon, stage.x, 88);
                    }
                    
                    // Stage label with background for visibility
                    const labelWidth = stage.name === 'Generated Theory' ? 110 : 80;
                    ctx.fillStyle = colors.paper + 'E0';
                    ctx.fillRect(stage.x - labelWidth/2, 115, labelWidth, 20);
                    
                    ctx.font = '14px EB Garamond, serif';
                    ctx.fillStyle = colors.ink;
                    ctx.textAlign = 'center';
                    ctx.fillText(stage.name, stage.x, 130);
                });
                
                // Update and draw theories
                theories.forEach((theory, index) => {
                    // Move theory through gauntlet - slower for tracking
                    if (theory.status === 'pending' && animationTime > theory.id * 20) {
                        theory.x += 1.5; // Slower movement
                        
                        // Check stage transitions
                        if (theory.x > 400 && theory.tests === 0) {
                            theory.tests = 1;
                            // Different failure reasons based on particle type
                            if (theory.label !== 'T1' && (theory.label === 'T2' || theory.label === 'T5')) {
                                theory.status = 'failed';
                                theory.failReason = 'Energy not conserved';
                                theory.failStage = 'Constraints';
                                failedTheories.push(theory);
                            }
                        } else if (theory.x > 600 && theory.tests === 1) {
                            theory.tests = 2;
                            // Different particles fail at different stages
                            if (theory.label !== 'T1' && (theory.label === 'T3' || theory.label === 'T6' || theory.label === 'T8')) {
                                theory.status = 'failed';
                                theory.failReason = 'Mercury precession wrong';
                                theory.failStage = 'Classical';
                                failedTheories.push(theory);
                            }
                        } else if (theory.x > 800 && theory.tests === 2) {
                            theory.tests = 3;
                            // All remaining particles (except T1) fail quantum tests
                            if (theory.label !== 'T1') {
                                theory.status = 'failed';
                                theory.failReason = theory.label === 'T4' ? '';
                                theory.failStage = 'Quantum';
                                failedTheories.push(theory);
                            }
                        } else if (theory.x > 1000 && theory.status === 'pending') {
                            theory.status = 'passed';
                        }
                    }
                    
                    // Fall if failed, but stop at bottom
                    if (theory.status === 'failed') {
                        const targetY = 320;
                        if (theory.y < targetY) {
                            theory.y += 3;
                        } else {
                            theory.y = targetY;
                            // Fade out slowly
                            if (theory.opacity > 0.3) {
                                theory.opacity -= 0.01;
                            }
                        }
                    }
                    
                    // Draw theory
                    ctx.save();
                    ctx.globalAlpha = theory.opacity;
                    
                    // Particle circle - bigger for visibility
                    ctx.fillStyle = theory.particle ? theory.particle.color : 
                                  (theory.status === 'failed' ? colors.danger :
                                    theory.status === 'passed' ? colors.success : 
                                    colors.accent);
                    ctx.beginPath();
                    ctx.arc(theory.x, theory.y, 12, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // White border for contrast
                    ctx.strokeStyle = colors.paper;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Label inside particle
                    ctx.fillStyle = colors.paper;
                    ctx.font = 'bold 10px JetBrains Mono, monospace';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(theory.label, theory.x, theory.y);
                    
                    // Show fail reason - keep visible even after falling
                    if (theory.status === 'failed') {
                        ctx.fillStyle = colors.paper + 'E0';
                        const textWidth = ctx.measureText(theory.failReason).width;
                        ctx.fillRect(theory.x + 15, theory.y - 10, textWidth + 6, 20);
                        
                        ctx.font = '12px JetBrains Mono, monospace';
                        ctx.fillStyle = colors.danger;
                        ctx.textAlign = 'left';
                        ctx.fillText(theory.failReason, theory.x + 18, theory.y);
                    }
                    
                    // Highlight T1 (Photon) with a subtle glow when it's about to succeed
                    if (theory.label === 'T1' && theory.x > 700 && theory.status === 'pending') {
                        ctx.strokeStyle = colors.quantum + '40';
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.arc(theory.x, theory.y, 18, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // Small indicator that this one will pass
                        ctx.font = '10px EB Garamond, serif';
                        ctx.fillStyle = colors.success;
                        ctx.textAlign = 'center';
                        ctx.fillText('â†’', theory.x - 25, theory.y);
                    }
                    
                    // Add particle type label below
                    ctx.fillStyle = colors.ink;
                    ctx.font = '10px JetBrains Mono, monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(theory.particle.symbol, theory.x, theory.y + 20);
                    
                    ctx.restore();
                });
                
                // Draw failed theories graveyard
                ctx.fillStyle = colors.danger + '10';
                ctx.fillRect(0, 300, validationGauntletCanvas.width, 100);
                
                // Graveyard label
                ctx.font = '14px EB Garamond, serif';
                ctx.fillStyle = colors.muted;
                ctx.textAlign = 'left';
                ctx.fillText('Failed Theories Graveyard', 50, 320);
                
                // Particle type legend on the right
                ctx.fillStyle = colors.paper + 'F0';
                ctx.fillRect(validationGauntletCanvas.width - 220, 150, 200, 240);
                ctx.strokeStyle = colors.codeBorder;
                ctx.lineWidth = 1;
                ctx.strokeRect(validationGauntletCanvas.width - 220, 150, 200, 240);
                
                ctx.font = 'bold 14px EB Garamond, serif';
                ctx.fillStyle = colors.ink;
                ctx.textAlign = 'center';
                ctx.fillText('Particle Types', validationGauntletCanvas.width - 120, 175);
                
                ctx.font = '12px EB Garamond, serif';
                ctx.textAlign = 'left';
                
                // Draw particle legend
                particleTypes.forEach((particle, i) => {
                    const y = 200 + i * 22;
                    
                    // Particle circle
                    ctx.fillStyle = particle.color;
                    ctx.beginPath();
                    ctx.arc(validationGauntletCanvas.width - 190, y, 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Particle symbol and name
                    ctx.fillStyle = colors.ink;
                    ctx.font = 'bold 11px JetBrains Mono, monospace';
                    ctx.fillText(particle.symbol, validationGauntletCanvas.width - 165, y + 3);
                    ctx.font = '11px EB Garamond, serif';
                    ctx.fillText(particle.name, validationGauntletCanvas.width - 140, y + 3);
                });
                
                // Note about test results
                ctx.fillStyle = colors.muted;
                ctx.font = 'italic 11px EB Garamond, serif';
                ctx.textAlign = 'center';
                ctx.fillText('Testing from @particles.json', validationGauntletCanvas.width - 120, 370);
                
                // Reset when all theories processed
                if (theories.every(t => t.status !== 'pending' || t.x > validationGauntletCanvas.width)) {
                    theories = [];
                    for (let i = 0; i < 8; i++) {
                        theories.push({
                            id: i,
                            x: -50 - (i * 30),
                            y: 80 + (i % 3) * 20,
                            status: 'pending',
                            failReason: null,
                            tests: 0,
                            opacity: 1,
                            label: `T${i + 1}`,
                            particle: particleTypes[i]  // New: assign particle type
                        });
                    }
                    // Keep only recent failed theories
                    if (failedTheories.length > 30) {
                        failedTheories = failedTheories.slice(-30);
                    }
                }
                
                animationTime++;
                requestAnimationFrame(drawValidationGauntlet);
            }
            
            drawValidationGauntlet();
        }

        // Spacetime Curvature Visualization
        const spacetimeCanvas = document.getElementById('spacetimeCanvas');
        const isMobile = window.innerWidth <= 768;
        
        // Skip canvas animation on mobile for performance
        if (spacetimeCanvas && !isMobile) {
            const spacetimeCtx = spacetimeCanvas.getContext('2d');
            let animationTime = 0;
            let scrollProgress = 0;
            let targetScrollProgress = 0;
            let mouseX = -100;
            let mouseY = -100;
            let ripples = [];
            
            function resizeSpacetimeCanvas() {
                spacetimeCanvas.width = window.innerWidth;
                spacetimeCanvas.height = window.innerHeight;
            }
            resizeSpacetimeCanvas();
            window.addEventListener('resize', resizeSpacetimeCanvas);
            
            // Update scroll progress
            function updateScrollProgress() {
                const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                const documentHeight = document.documentElement.scrollHeight - window.innerHeight;
                targetScrollProgress = Math.min(1, scrollTop / documentHeight);
            }
            window.addEventListener('scroll', updateScrollProgress);
            updateScrollProgress();
            
            // Mouse tracking
            let prevMouseX = -100;
            let prevMouseY = -100;
            let mouseVelocityX = 0;
            let mouseVelocityY = 0;
            
            spacetimeCanvas.addEventListener('mousemove', (e) => {
                const rect = spacetimeCanvas.getBoundingClientRect();
                const newMouseX = e.clientX - rect.left;
                const newMouseY = e.clientY - rect.top;
                
                if (prevMouseX > 0 && prevMouseY > 0) {
                    mouseVelocityX = newMouseX - prevMouseX;
                    mouseVelocityY = newMouseY - prevMouseY;
                }
                
                prevMouseX = mouseX;
                prevMouseY = mouseY;
                mouseX = newMouseX;
                mouseY = newMouseY;
                
                const speed = Math.sqrt(mouseVelocityX * mouseVelocityX + mouseVelocityY * mouseVelocityY);
                
                if (speed > 2 && Math.random() < 0.15) {
                    const angle = Math.atan2(mouseVelocityY, mouseVelocityX);
                    const distance = 30;
                    const rippleX = mouseX + Math.cos(angle) * distance;
                    const rippleY = mouseY + Math.sin(angle) * distance;
                    
                    ripples.push({
                        x: rippleX,
                        y: rippleY,
                        radius: 0,
                        maxRadius: 150 + speed * 5,
                        strength: 0.4 + Math.min(speed * 0.02, 0.4),
                        speed: 2 + speed * 0.1,
                        decay: 0.98,
                        directionX: mouseVelocityX / speed,
                        directionY: mouseVelocityY / speed
                    });
                }
            });
            
            spacetimeCanvas.addEventListener('mouseleave', () => {
                mouseX = -100;
                mouseY = -100;
            });
            
            spacetimeCanvas.addEventListener('click', (e) => {
                const rect = spacetimeCanvas.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const clickY = e.clientY - rect.top;
                
                ripples.push({
                    x: clickX,
                    y: clickY,
                    radius: 0,
                    maxRadius: 300,
                    strength: 0.8,
                    speed: 2.5,
                    decay: 0.97
                });
                
                if (ripples.length > 10) {
                    ripples = ripples.slice(-10);
                }
            });
            
            function updatePositions() {
                scrollProgress += (targetScrollProgress - scrollProgress) * 0.1;
                
                ripples = ripples.filter(ripple => {
                    ripple.radius += ripple.speed;
                    ripple.strength *= ripple.decay;
                    return ripple.strength > 0.02 && ripple.radius < ripple.maxRadius;
                });
                
                if (ripples.length > 5) {
                    ripples.sort((a, b) => b.strength - a.strength);
                    ripples = ripples.slice(0, 5);
                }
            }
            
            function calculateWarp(x, y) {
                let warpX = 0;
                let warpY = 0;
                
                const centerX = spacetimeCanvas.width / 2;
                const centerY = spacetimeCanvas.height * 1.2;
                const dx = x - centerX;
                const dy = y - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                const breathingIntensity = 30 + scrollProgress * 50;
                const breathingWarp = Math.sin(animationTime * 0.002) * breathingIntensity;
                const radialBreathing = (1 - Math.min(1, distance / 1000)) * breathingWarp;
                
                if (distance > 0) {
                    warpX += (dx / distance) * radialBreathing * 0.3;
                    warpY += (dy / distance) * radialBreathing * 0.3;
                    
                    if (scrollProgress > 0.001) {
                        const scrollIntensity = 1200 * Math.pow(scrollProgress, 0.8);
                        const maxDistance = 2000;
                        const normalizedDistance = Math.min(distance / maxDistance, 1);
                        const falloff = Math.pow(1 - normalizedDistance, 1.2);
                        const warpStrength = scrollIntensity * falloff;
                        const angle = Math.atan2(dy, dx);
                        const radialPull = warpStrength * 1.5;
                        warpX = -Math.cos(angle) * radialPull;
                        warpY = -Math.sin(angle) * radialPull;
                    }
                }
                
                if (mouseX > 0 && mouseY > 0) {
                    const mouseDx = x - mouseX;
                    const mouseDy = y - mouseY;
                    const mouseDistance = Math.sqrt(mouseDx * mouseDx + mouseDy * mouseDy);
                    if (mouseDistance > 0 && mouseDistance < 80) {
                        const mouseWarp = (1 - mouseDistance / 80) * 10;
                        warpX += (mouseDx / mouseDistance) * mouseWarp;
                        warpY += (mouseDy / mouseDistance) * mouseWarp;
                    }
                }
                
                ripples.forEach(ripple => {
                    const rippleDx = x - ripple.x;
                    const rippleDy = y - ripple.y;
                    const rippleDistance = Math.sqrt(rippleDx * rippleDx + rippleDy * rippleDy);
                    
                    const waveWidth = 20; // More frequent ripples
                    if (rippleDistance > ripple.radius - waveWidth && rippleDistance < ripple.radius + waveWidth) {
                        const ripplePhase = (rippleDistance - ripple.radius) / waveWidth;
                        const rippleStrength = Math.cos(ripplePhase * Math.PI) * ripple.strength * 30;
                        
                        if (rippleDistance > 0 && ripple.strength > 0.02) {
                            const radialFactor = 0.7;
                            const directionalFactor = 0.3;
                            const radialX = (rippleDx / rippleDistance) * rippleStrength * radialFactor;
                            const radialY = (rippleDy / rippleDistance) * rippleStrength * radialFactor;
                            let dirX = 0, dirY = 0;
                            if (ripple.directionX && ripple.directionY) {
                                dirX = ripple.directionX * rippleStrength * directionalFactor;
                                dirY = ripple.directionY * rippleStrength * directionalFactor;
                            }
                            warpX += radialX + dirX;
                            warpY += radialY + dirY;
                        }
                    }
                });
                
                return { warpX, warpY };
            }
            
            // Wave propagation state
            let wavePhase = 0;
            let waveStrength = 0;
            let wavePhase2 = 0;
            let waveOriginX = 0;
            let waveOriginY = 0;
            let rippleTime = 0;
            let activeRipple = null;
            
            function drawSpacetimeGrid() {
                const gridSize = 40;
                const edgeExtension = 400;
                const centerX = spacetimeCanvas.width / 2;
                const gridOffsetX = (centerX % gridSize) - gridSize / 2;
                
                // Smooth continuous wave animation
                wavePhase += 0.015;
                wavePhase2 += 0.008;
                rippleTime += 0.02;
                
                // Create smooth, continuous wave strength variations
                const wave1 = Math.sin(wavePhase * 0.3) * 0.5 + 0.5;
                const wave2 = Math.sin(wavePhase2 * 0.2) * 0.5 + 0.5;
                waveStrength = (wave1 * 0.7 + wave2 * 0.3) * 0.3; // Base wave strength
                
                // Slowly moving wave origin for more organic feel
                waveOriginX = centerX + Math.sin(wavePhase * 0.1) * 200;
                waveOriginY = spacetimeCanvas.height / 2 + Math.cos(wavePhase * 0.15) * 100;
                
                // Ripple effect every 5 seconds
                if (rippleTime > 5 && !activeRipple) {
                    rippleTime = 0; // Reset timer
                    activeRipple = {
                        x: centerX + (Math.random() - 0.5) * 400,
                        y: spacetimeCanvas.height / 2 + (Math.random() - 0.5) * 200,
                        radius: 0,
                        maxRadius: 600,
                        speed: 3,
                        strength: 1
                    };
                }
                
                if (activeRipple) {
                    activeRipple.radius += activeRipple.speed;
                    activeRipple.strength = 1 - (activeRipple.radius / activeRipple.maxRadius);
                    if (activeRipple.radius > activeRipple.maxRadius) {
                        activeRipple = null;
                    }
                }
                
                // Vertical grid lines
                for (let x = -edgeExtension + gridOffsetX; x <= spacetimeCanvas.width + edgeExtension; x += gridSize) {
                    spacetimeCtx.beginPath();
                    let firstPoint = true;
                    
                    // Calculate distance from wave origin for radial wave effect
                    const distFromWave = Math.sqrt(Math.pow(x - waveOriginX, 2) + Math.pow(spacetimeCanvas.height/2 - waveOriginY, 2));
                    const waveRadial = Math.sin(distFromWave * 0.015 - wavePhase * 2) * 0.5 + 0.5; // More frequent waves
                    
                    // Calculate base grid line brightness
                    const baseBrightness = 0.1; // Slightly brighter base
                    
                    // Add smooth wave effect
                    const waveEffect = waveStrength * waveRadial * 0.15; // More visible waves
                    let brightness = baseBrightness + waveEffect;
                    
                    // Check for ripple effect
                    let rippleGlow = 0;
                    if (activeRipple) {
                        const rippleDist = Math.sqrt(Math.pow(x - activeRipple.x, 2) + Math.pow(spacetimeCanvas.height/2 - activeRipple.y, 2));
                        const rippleWidth = 30; // Tighter ripple bands
                        if (Math.abs(rippleDist - activeRipple.radius) < rippleWidth) {
                            const ripplePhase = 1 - Math.abs(rippleDist - activeRipple.radius) / rippleWidth;
                            rippleGlow = ripplePhase * activeRipple.strength * 0.3;
                            brightness += rippleGlow;
                        }
                    }
                    
                    // More blue color with ripple glow
                    const blueAmount = 0.4 + waveEffect * 0.2 + rippleGlow * 0.3; // 40-70% blue
                    const grayAmount = 1 - blueAmount;
                    spacetimeCtx.strokeStyle = `rgba(${45 * grayAmount + 26 * blueAmount}, ${45 * grayAmount + 58 * blueAmount}, ${45 * grayAmount + 138 * blueAmount}, ${brightness})`;
                    spacetimeCtx.lineWidth = 1 + waveEffect * 0.5 + rippleGlow * 1.5; // Glow on ripple
                    
                    for (let y = -edgeExtension; y <= spacetimeCanvas.height + edgeExtension; y += 10) {
                        const { warpX, warpY } = calculateWarp(x, y);
                        const finalX = x + warpX;
                        const finalY = y + warpY;
                        
                        if (finalX < -edgeExtension * 2 || finalX > spacetimeCanvas.width + edgeExtension * 2 || 
                            finalY < -edgeExtension * 2 || finalY > spacetimeCanvas.height + edgeExtension * 2) {
                            continue;
                        }
                        
                        if (firstPoint) {
                            spacetimeCtx.moveTo(finalX, finalY);
                            firstPoint = false;
                        } else {
                            spacetimeCtx.lineTo(finalX, finalY);
                        }
                    }
                    spacetimeCtx.stroke();
                }
                
                const centerY = spacetimeCanvas.height / 2;
                const gridOffsetY = (centerY % gridSize) - gridSize / 2;
                
                // Horizontal grid lines
                for (let y = -edgeExtension + gridOffsetY; y <= spacetimeCanvas.height + edgeExtension; y += gridSize) {
                    spacetimeCtx.beginPath();
                    let firstPoint = true;
                    
                    // Calculate distance from wave origin for radial wave effect
                    const distFromWave = Math.sqrt(Math.pow(spacetimeCanvas.width/2 - waveOriginX, 2) + Math.pow(y - waveOriginY, 2));
                    const waveRadial = Math.sin(distFromWave * 0.005 - wavePhase * 2 + Math.PI/4) * 0.5 + 0.5; // Phase offset for variety
                    
                    // Calculate base grid line brightness
                    const baseBrightness = 0.1; // Slightly brighter base
                    
                    // Add smooth wave effect
                    const waveEffect = waveStrength * waveRadial * 0.15; // More visible waves
                    let brightness = baseBrightness + waveEffect;
                    
                    // Check for ripple effect
                    let rippleGlow = 0;
                    if (activeRipple) {
                        const rippleDist = Math.sqrt(Math.pow(spacetimeCanvas.width/2 - activeRipple.x, 2) + Math.pow(y - activeRipple.y, 2));
                        const rippleWidth = 30; // Tighter ripple bands
                        if (Math.abs(rippleDist - activeRipple.radius) < rippleWidth) {
                            const ripplePhase = 1 - Math.abs(rippleDist - activeRipple.radius) / rippleWidth;
                            rippleGlow = ripplePhase * activeRipple.strength * 0.3;
                            brightness += rippleGlow;
                        }
                    }
                    
                    // More blue color with ripple glow
                    const blueAmount = 0.4 + waveEffect * 0.2 + rippleGlow * 0.3; // 40-70% blue
                    const grayAmount = 1 - blueAmount;
                    spacetimeCtx.strokeStyle = `rgba(${45 * grayAmount + 26 * blueAmount}, ${45 * grayAmount + 58 * blueAmount}, ${45 * grayAmount + 138 * blueAmount}, ${brightness})`;
                    spacetimeCtx.lineWidth = 1 + waveEffect * 0.5 + rippleGlow * 1.5; // Glow on ripple
                    
                    for (let x = -edgeExtension; x <= spacetimeCanvas.width + edgeExtension; x += 10) {
                        const { warpX, warpY } = calculateWarp(x, y);
                        const finalX = x + warpX;
                        const finalY = y + warpY;
                        
                        if (finalX < -edgeExtension * 2 || finalX > spacetimeCanvas.width + edgeExtension * 2 || 
                            finalY < -edgeExtension * 2 || finalY > spacetimeCanvas.height + edgeExtension * 2) {
                            continue;
                        }
                        
                        if (firstPoint) {
                            spacetimeCtx.moveTo(finalX, finalY);
                            firstPoint = false;
                        } else {
                            spacetimeCtx.lineTo(finalX, finalY);
                        }
                    }
                    spacetimeCtx.stroke();
                }
                
                // Draw light effects at grid intersections - especially during ripples
                if (waveStrength > 0.05 || activeRipple) {
                    // Draw on every 2nd intersection
                    for (let x = -edgeExtension + gridOffsetX; x <= spacetimeCanvas.width + edgeExtension; x += gridSize * 2) {
                        for (let y = -edgeExtension + gridOffsetY; y <= spacetimeCanvas.height + edgeExtension; y += gridSize * 2) {
                            const { warpX, warpY } = calculateWarp(x, y);
                            const finalX = x + warpX;
                            const finalY = y + warpY;
                            
                            // Calculate distance from wave origin
                            const dist = Math.sqrt(Math.pow(finalX - waveOriginX, 2) + Math.pow(finalY - waveOriginY, 2));
                            const radialFactor = Math.exp(-dist * dist / (300000)); // Gaussian falloff
                            
                            // Base pulse intensity
                            const pulseBase = Math.sin(dist * 0.01 - wavePhase * 3) * 0.5 + 0.5;
                            let pulseIntensity = waveStrength * radialFactor * pulseBase * 0.1;
                            
                            // Ripple glow at intersections
                            if (activeRipple) {
                                const rippleDist = Math.sqrt(Math.pow(finalX - activeRipple.x, 2) + Math.pow(finalY - activeRipple.y, 2));
                                const rippleWidth = 80;
                                if (Math.abs(rippleDist - activeRipple.radius) < rippleWidth) {
                                    const ripplePhase = 1 - Math.abs(rippleDist - activeRipple.radius) / rippleWidth;
                                    const rippleIntensity = ripplePhase * activeRipple.strength * 0.6;
                                    pulseIntensity = Math.max(pulseIntensity, rippleIntensity);
                                    
                                    // Brighter blue during ripple - REMOVED for cleaner wave effect
                                    // if (rippleIntensity > 0.1) {
                                    //     spacetimeCtx.fillStyle = `rgba(59, 130, 246, ${rippleIntensity * 0.7})`;
                                    //     spacetimeCtx.beginPath();
                                    //     spacetimeCtx.arc(finalX, finalY, 2 + rippleIntensity * 6, 0, Math.PI * 2);
                                    //     spacetimeCtx.fill();
                                    // }
                                }
                            }
                            
                            // Regular subtle glow - REMOVED for cleaner wave effect
                            // if (pulseIntensity > 0.02 && !activeRipple) {
                            //     spacetimeCtx.fillStyle = `rgba(26, 58, 138, ${pulseIntensity})`;
                            //     spacetimeCtx.beginPath();
                            //     spacetimeCtx.arc(finalX, finalY, 1 + pulseIntensity * 4, 0, Math.PI * 2);
                            //     spacetimeCtx.fill();
                            // }
                        }
                    }
                }
            }
            
            function drawCursor() {
      
                if (mouseX > 0 && mouseY > 0) {
                    spacetimeCtx.strokeStyle = 'rgba(45, 45, 45, 0.15)';
                    spacetimeCtx.lineWidth = 1;
                    spacetimeCtx.beginPath();
                    spacetimeCtx.arc(mouseX, mouseY, 20, 0, Math.PI * 2);
                    spacetimeCtx.stroke();
                    
                    spacetimeCtx.beginPath();
                    spacetimeCtx.arc(mouseX, mouseY, 5, 0, Math.PI * 2);
                    spacetimeCtx.fillStyle = 'rgba(45, 45, 45, 0.25)';
                    spacetimeCtx.fill();
                }
            }
            
            function animateSpacetime() {
                animationTime++;
                
                spacetimeCtx.fillStyle = colors.paper;
                spacetimeCtx.fillRect(0, 0, spacetimeCanvas.width, spacetimeCanvas.height);
                
                updatePositions();
                drawSpacetimeGrid();
                drawCursor();
                
                const fadeHeight = 200;
                const fadeStart = spacetimeCanvas.height - fadeHeight;
                
                // Convert paper color to RGB values for gradient
                const paperRGB = '250, 248, 243'; // This should match colors.paper (#FAF8F3)
                const gradient = spacetimeCtx.createLinearGradient(0, fadeStart, 0, spacetimeCanvas.height + 50);
                gradient.addColorStop(0, `rgba(${paperRGB}, 0)`);
                gradient.addColorStop(0.5, `rgba(${paperRGB}, 0.5)`);
                gradient.addColorStop(0.8, `rgba(${paperRGB}, 0.9)`);
                gradient.addColorStop(1, `rgba(${paperRGB}, 1)`);
                
                spacetimeCtx.fillStyle = gradient;
                spacetimeCtx.fillRect(0, fadeStart, spacetimeCanvas.width, fadeHeight + 50);
                
                requestAnimationFrame(animateSpacetime);
            }
            
            animateSpacetime();
        }

        // Add this function after the existing copyInstallCommand() function (around line 2270):

        function copyModalCommand() {
            const command = document.getElementById('modal-install-command').textContent;
            navigator.clipboard.writeText(command).then(() => {
                // Show check icon
                document.getElementById('modal-copy-icon').classList.add('hidden');
                document.getElementById('modal-check-icon').classList.remove('hidden');
                
                // Show tooltip
                const tooltip = document.getElementById('modal-copy-tooltip');
                tooltip.classList.remove('opacity-0');
                
                // Reset after 2 seconds
                setTimeout(() => {
                    document.getElementById('modal-copy-icon').classList.remove('hidden');
                    document.getElementById('modal-check-icon').classList.add('hidden');
                    tooltip.classList.add('opacity-0');
                }, 2000);
            });
        }
        
        // Toggle Mathematical Foundation details
        function toggleMathDetails() {
            const details = document.getElementById('math-details');
            const chevron = document.getElementById('math-chevron');
            
            if (details.style.maxHeight === '0px' || !details.style.maxHeight) {
                details.style.maxHeight = details.scrollHeight + 'px';
                chevron.style.transform = 'rotate(180deg)';
            } else {
                details.style.maxHeight = '0px';
                chevron.style.transform = 'rotate(0deg)';
            }
        }
        
        // Toggle Clock experiment details
        function toggleClockDetails() {
            const details = document.getElementById('clock-details');
            
            if (details.style.maxHeight === '0px' || !details.style.maxHeight) {
                details.style.maxHeight = details.scrollHeight + 'px';
            } else {
                details.style.maxHeight = '0px';
            }
        }
        
        // Toggle Einstein note details
        function toggleEinsteinDetail(id) {
            const details = document.getElementById(id + '-detail');
            const allDetails = document.querySelectorAll('[id$="-detail"]');
            
            // Hide all other details
            allDetails.forEach(detail => {
                if (detail.id !== id + '-detail' && detail.id.includes('einstein-')) {
                    detail.classList.add('hidden');
                }
            });
            
            // Toggle the clicked detail
            details.classList.toggle('hidden');
        }
        
        // Toggle UGM section
        function toggleUGMSection() {
            const content = document.getElementById('ugm-content');
            const chevron = document.getElementById('ugm-chevron');
            
            if (content.style.maxHeight === '0px' || content.style.maxHeight === '') {
                // Open the section
                content.style.maxHeight = content.scrollHeight + 'px';
                chevron.style.transform = 'rotate(180deg)';
            } else {
                // Close the section
                content.style.maxHeight = '0';
                chevron.style.transform = 'rotate(0deg)';
            }
        }
        
        // Toggle Standard Model section
        function toggleStandardModelSection() {
            const content = document.getElementById('sm-content');
            const chevron = document.getElementById('sm-chevron');
            
            if (content.style.maxHeight === '0px' || content.style.maxHeight === '') {
                // Open the section
                content.style.maxHeight = content.scrollHeight + 'px';
                chevron.style.transform = 'rotate(180deg)';
            } else {
                // Close the section
                content.style.maxHeight = '0';
                chevron.style.transform = 'rotate(0deg)';
            }
        }
        
        // Toggle Physics Engine section
        function togglePhysicsEngineSection() {
            const content = document.getElementById('physics-engine-content');
            const chevron = document.getElementById('physics-engine-chevron');
            
            if (content.style.maxHeight === '0px' || content.style.maxHeight === '') {
                // Open the section
                content.style.maxHeight = content.scrollHeight + 'px';
                chevron.style.transform = 'rotate(180deg)';
            } else {
                // Close the section
                content.style.maxHeight = '0';
                chevron.style.transform = 'rotate(0deg)';
            }
        }
        
        // Toggle Future Vision section
        function toggleFutureVisionSection() {
            const content = document.getElementById('future-vision-content');
            const chevron = document.getElementById('future-vision-chevron');
            
            if (content.style.maxHeight === '0px' || content.style.maxHeight === '') {
                // Open the section
                content.style.maxHeight = content.scrollHeight + 'px';
                chevron.style.transform = 'rotate(180deg)';
            } else {
                // Close the section
                content.style.maxHeight = '0';
                chevron.style.transform = 'rotate(0deg)';
            }
        }
        
        // Toggle clock details
        function toggleClockDetails() {
            const details = document.getElementById('clock-details');
            if (details.style.maxHeight === '0px' || details.style.maxHeight === '') {
                details.style.maxHeight = details.scrollHeight + 'px';
            } else {
                details.style.maxHeight = '0';
            }
        }
        
        // Quantum Validator Visualization
        const quantumValidatorCanvas = document.getElementById('quantumValidatorCanvas');
        if (quantumValidatorCanvas) {
            const ctx = quantumValidatorCanvas.getContext('2d');
            let animationTime = 0;
            
            function drawQuantumValidator() {
                ctx.clearRect(0, 0, quantumValidatorCanvas.width, quantumValidatorCanvas.height);
                
                // Background
                ctx.fillStyle = colors.canvasBg;
                ctx.fillRect(0, 0, quantumValidatorCanvas.width, quantumValidatorCanvas.height);
                
                // Draw atomic clock setup
                const centerX = quantumValidatorCanvas.width / 2;
                const bottomY = quantumValidatorCanvas.height - 40;
                const topY = 60;
                const heightDiff = bottomY - topY;
                
                // Ground level
                ctx.strokeStyle = colors.codeBorder;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(20, bottomY);
                ctx.lineTo(quantumValidatorCanvas.width - 20, bottomY);
                ctx.stroke();
                
                // Height marker
                ctx.strokeStyle = colors.muted;
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.moveTo(40, topY);
                ctx.lineTo(40, bottomY);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Height label
                ctx.font = '12px JetBrains Mono, monospace';
                ctx.fillStyle = colors.muted;
                ctx.textAlign = 'center';
                ctx.save();
                ctx.translate(25, (topY + bottomY) / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText('33 cm', 0, 0);
                ctx.restore();
                
                // Lower clock
                const clockRadius = 30;
                ctx.fillStyle = colors.codeBg;
                ctx.strokeStyle = colors.accent;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(centerX, bottomY - clockRadius - 10, clockRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                // Upper clock
                ctx.fillStyle = colors.codeBg;
                ctx.strokeStyle = colors.quantum;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(centerX, topY + clockRadius + 10, clockRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                // Clock faces (simplified)
                ctx.fillStyle = colors.ink;
                ctx.font = '16px JetBrains Mono, monospace';
                ctx.textAlign = 'center';
                ctx.fillText('âš›', centerX, bottomY - clockRadius - 5);
                ctx.fillText('âš›', centerX, topY + clockRadius + 15);
                
                // Gravitational field lines (subtle)
                ctx.strokeStyle = colors.codeBorder + '40';
                ctx.lineWidth = 1;
                for (let i = 0; i < 5; i++) {
                    const y = bottomY - i * 40;
                    const curve = Math.sin(animationTime * 0.02) * 5;
                    ctx.beginPath();
                    ctx.moveTo(60, y);
                    ctx.quadraticCurveTo(centerX + curve, y - 10, quantumValidatorCanvas.width - 60, y);
                    ctx.stroke();
                }
                
                // Frequency shift visualization
                const waveStartX = centerX + clockRadius + 40;
                const waveEndX = quantumValidatorCanvas.width - 40;
                const waveWidth = waveEndX - waveStartX;
                
                // Lower clock wave (reference)
                ctx.strokeStyle = colors.accent;
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let x = 0; x <= waveWidth; x++) {
                    const phase = x * 0.05 + animationTime * 0.05;
                    const y = bottomY - clockRadius - 10 + Math.sin(phase) * 15;
                    if (x === 0) {
                        ctx.moveTo(waveStartX + x, y);
                    } else {
                        ctx.lineTo(waveStartX + x, y);
                    }
                }
                ctx.stroke();
                
                // Upper clock wave (shifted)
                ctx.strokeStyle = colors.quantum;
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let x = 0; x <= waveWidth; x++) {
                    // Slightly higher frequency due to gravitational time dilation
                    const phase = x * 0.0501 + animationTime * 0.0501; // 0.02% shift
                    const y = topY + clockRadius + 10 + Math.sin(phase) * 15;
                    if (x === 0) {
                        ctx.moveTo(waveStartX + x, y);
                    } else {
                        ctx.lineTo(waveStartX + x, y);
                    }
                }
                ctx.stroke();
                
                // Phase difference indicator
                if (animationTime > 60) {
                    const phaseX = waveStartX + waveWidth * 0.7;
                    
                    // Vertical line showing phase shift
                    ctx.strokeStyle = colors.warning;
                    ctx.lineWidth = 1;
                    ctx.setLineDash([2, 2]);
                    ctx.beginPath();
                    ctx.moveTo(phaseX, topY + clockRadius + 25);
                    ctx.lineTo(phaseX, bottomY - clockRadius - 25);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Label
                    ctx.font = '11px EB Garamond, serif';
                    ctx.fillStyle = colors.warning;
                    ctx.textAlign = 'left';
                    ctx.fillText('Î”f/f = 3.61Ã—10â»Â¹â·', phaseX + 10, (topY + bottomY) / 2);
                }
                
                // Labels
                ctx.font = '12px EB Garamond, serif';
                ctx.fillStyle = colors.ink;
                ctx.textAlign = 'center';
                ctx.fillText('Lower clock', centerX, bottomY + 25);
                ctx.fillText('Upper clock', centerX, topY - 10);
                
                animationTime++;
                requestAnimationFrame(drawQuantumValidator);
            }
            
            drawQuantumValidator();
        }
        
        // Demo Video Autoplay on Scroll
        document.addEventListener('DOMContentLoaded', function() {
            const video = document.getElementById('demoVideo');
            if (!video) return;
            
            // Create intersection observer for autoplay
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        // Video is in viewport - play it
                        video.play().catch(e => {
                            console.log('Autoplay prevented:', e);
                        });
                    } else {
                        // Video is out of viewport - pause it
                        video.pause();
                    }
                });
            }, {
                threshold: 0.5 // Trigger when 50% of video is visible
            });
            
            // Start observing the video
            observer.observe(video);
            
            // Add smooth fade-in effect when video loads
            video.addEventListener('loadeddata', function() {
                video.style.opacity = '0';
                video.style.transition = 'opacity 0.5s ease-in-out';
                setTimeout(() => {
                    video.style.opacity = '1';
                }, 100);
            });
        });

        // Cache Flow Diagram
        const cacheCanvas = document.getElementById('cacheFlowDiagram');
        if (cacheCanvas) {
            const cacheCtx = cacheCanvas.getContext('2d');
            
            // Set canvas size for high DPI displays
            const dpr = window.devicePixelRatio || 1;
            cacheCanvas.width = 1000 * dpr;
            cacheCanvas.height = 300 * dpr;
            cacheCanvas.style.width = '1000px';
            cacheCanvas.style.height = '300px';
            cacheCtx.scale(dpr, dpr);
            
            // Animation variables
            let cacheAnimFrame = 0;
            const particles = [];
            
            // Define flow stages with colors matching the site theme
            const colors = {
                accent: '#0066cc',
                success: '#22c55e',
                warning: '#ff6600',
                muted: '#6b7280',
                quantum: '#8b5cf6',
                bg: '#f9fafb'
            };
            
            const stages = [
                { id: 'request', x: 100, y: 150, width: 140, height: 60, label: 'Trajectory\nRequest', color: colors.accent },
                { id: 'hash', x: 300, y: 150, width: 140, height: 60, label: 'Parameter\nHashing', color: colors.quantum },
                { id: 'lookup', x: 500, y: 150, width: 140, height: 60, label: 'Cache\nLookup', color: colors.muted },
                { id: 'hit', x: 700, y: 80, width: 120, height: 50, label: ' Hit\n', color: colors.success },
                { id: 'miss', x: 700, y: 220, width: 120, height: 50, label: 'Calculate', color: colors.warning },
                { id: 'result', x: 880, y: 150, width: 100, height: 60, label: 'Return\nResult', color: colors.accent }
            ];
            
            // Draw flow diagram
            function drawCacheFlow() {
                // Clear canvas with subtle background
                cacheCtx.fillStyle = colors.bg;
                cacheCtx.fillRect(0, 0, 1000, 300);
                
                // Draw connections with softer lines
                cacheCtx.strokeStyle = '#e5e7eb';
                cacheCtx.lineWidth = 1.5;
                
                // Request -> Hash
                drawArrow(240, 180, 300, 180);
                
                // Hash -> Lookup
                drawArrow(440, 180, 500, 180);
                
                // Lookup -> Hit (curved up)
                cacheCtx.beginPath();
                cacheCtx.moveTo(640, 180);
                cacheCtx.quadraticCurveTo(670, 150, 700, 105);
                cacheCtx.stroke();
                drawArrowHead(700, 105, -Math.PI/4);
                
                // Lookup -> Miss (curved down)
                cacheCtx.beginPath();
                cacheCtx.moveTo(640, 180);
                cacheCtx.quadraticCurveTo(670, 210, 700, 245);
                cacheCtx.stroke();
                drawArrowHead(700, 245, Math.PI/4);
                
                // Hit -> Result
                cacheCtx.beginPath();
                cacheCtx.moveTo(820, 105);
                cacheCtx.quadraticCurveTo(850, 120, 880, 180);
                cacheCtx.stroke();
                drawArrowHead(880, 180, Math.PI/6);
                
                // Miss -> Result (with compute step)
                cacheCtx.beginPath();
                cacheCtx.moveTo(820, 245);
                cacheCtx.quadraticCurveTo(850, 230, 880, 180);
                cacheCtx.stroke();
                drawArrowHead(880, 180, -Math.PI/6);
                
                // Draw stages
                stages.forEach(stage => {
                    // Subtle shadow (rounded)
                    const shadowOffset = 2;
                    const shadowRadius = 8;
                    cacheCtx.fillStyle = 'rgba(0,0,0,0.05)';
                    cacheCtx.beginPath();
                    cacheCtx.moveTo(stage.x + shadowRadius + shadowOffset, stage.y + shadowOffset);
                    cacheCtx.lineTo(stage.x + stage.width - shadowRadius + shadowOffset, stage.y + shadowOffset);
                    cacheCtx.quadraticCurveTo(stage.x + stage.width + shadowOffset, stage.y + shadowOffset, stage.x + stage.width + shadowOffset, stage.y + shadowRadius + shadowOffset);
                    cacheCtx.lineTo(stage.x + stage.width + shadowOffset, stage.y + stage.height - shadowRadius + shadowOffset);
                    cacheCtx.quadraticCurveTo(stage.x + stage.width + shadowOffset, stage.y + stage.height + shadowOffset, stage.x + stage.width - shadowRadius + shadowOffset, stage.y + stage.height + shadowOffset);
                    cacheCtx.lineTo(stage.x + shadowRadius + shadowOffset, stage.y + stage.height + shadowOffset);
                    cacheCtx.quadraticCurveTo(stage.x + shadowOffset, stage.y + stage.height + shadowOffset, stage.x + shadowOffset, stage.y + stage.height - shadowRadius + shadowOffset);
                    cacheCtx.lineTo(stage.x + shadowOffset, stage.y + shadowRadius + shadowOffset);
                    cacheCtx.quadraticCurveTo(stage.x + shadowOffset, stage.y + shadowOffset, stage.x + shadowRadius + shadowOffset, stage.y + shadowOffset);
                    cacheCtx.closePath();
                    cacheCtx.fill();
                    
                    // Box with border style for some elements
                    const radius = 8;
                    
                    // Draw rounded rectangle
                    cacheCtx.beginPath();
                    cacheCtx.moveTo(stage.x + radius, stage.y);
                    cacheCtx.lineTo(stage.x + stage.width - radius, stage.y);
                    cacheCtx.quadraticCurveTo(stage.x + stage.width, stage.y, stage.x + stage.width, stage.y + radius);
                    cacheCtx.lineTo(stage.x + stage.width, stage.y + stage.height - radius);
                    cacheCtx.quadraticCurveTo(stage.x + stage.width, stage.y + stage.height, stage.x + stage.width - radius, stage.y + stage.height);
                    cacheCtx.lineTo(stage.x + radius, stage.y + stage.height);
                    cacheCtx.quadraticCurveTo(stage.x, stage.y + stage.height, stage.x, stage.y + stage.height - radius);
                    cacheCtx.lineTo(stage.x, stage.y + radius);
                    cacheCtx.quadraticCurveTo(stage.x, stage.y, stage.x + radius, stage.y);
                    cacheCtx.closePath();
                    
                    if (stage.id === 'lookup' || stage.id === 'hash') {
                        // Border style
                        cacheCtx.fillStyle = '#ffffff';
                        cacheCtx.fill();
                        cacheCtx.strokeStyle = stage.color;
                        cacheCtx.lineWidth = 2;
                        cacheCtx.stroke();
                    } else {
                        // Filled style with lower opacity
                        cacheCtx.fillStyle = stage.color + '15'; // Add transparency
                        cacheCtx.fill();
                        cacheCtx.strokeStyle = stage.color;
                        cacheCtx.lineWidth = 1.5;
                        cacheCtx.stroke();
                    }
                    
                    // Text with appropriate color
                    cacheCtx.fillStyle = (stage.id === 'lookup' || stage.id === 'hash') ? stage.color : '#374151';
                    cacheCtx.font = '600 13px -apple-system, BlinkMacSystemFont, sans-serif';
                    cacheCtx.textAlign = 'center';
                    cacheCtx.textBaseline = 'middle';
                    
                    const lines = stage.label.split('\\n');
                    const lineHeight = 18;
                    const startY = stage.y + stage.height/2 - (lines.length - 1) * lineHeight/2;
                    
                    lines.forEach((line, i) => {
                        cacheCtx.fillText(line, stage.x + stage.width/2, startY + i * lineHeight);
                    });
                });
                
                // Draw animated particles
                updateParticles();
                particles.forEach(particle => {
                    cacheCtx.fillStyle = particle.color + '80'; // Add transparency
                    cacheCtx.beginPath();
                    cacheCtx.arc(particle.x, particle.y, 3, 0, Math.PI * 2);
                    cacheCtx.fill();
                });
                
                // Add subtle labels
                cacheCtx.fillStyle = '#9ca3af';
                cacheCtx.font = '11px -apple-system, BlinkMacSystemFont, sans-serif';
                cacheCtx.textAlign = 'center';
                
                // Hit rate label
                cacheCtx.fillText('Param hash lookup', 760, 55);
                
                // Miss compute label
                cacheCtx.fillText('Full computation', 760, 285);
                
                cacheAnimFrame++;
            }
            
            function drawArrow(x1, y1, x2, y2) {
                cacheCtx.beginPath();
                cacheCtx.moveTo(x1, y1);
                cacheCtx.lineTo(x2, y2);
                cacheCtx.stroke();
                
                const angle = Math.atan2(y2 - y1, x2 - x1);
                drawArrowHead(x2, y2, angle);
            }
            
            function drawArrowHead(x, y, angle) {
                const headLength = 8;
                cacheCtx.beginPath();
                cacheCtx.moveTo(x, y);
                cacheCtx.lineTo(x - headLength * Math.cos(angle - Math.PI/6), y - headLength * Math.sin(angle - Math.PI/6));
                cacheCtx.moveTo(x, y);
                cacheCtx.lineTo(x - headLength * Math.cos(angle + Math.PI/6), y - headLength * Math.sin(angle + Math.PI/6));
                cacheCtx.stroke();
            }
            
            function updateParticles() {
                // Add new particles periodically
                if (cacheAnimFrame % 60 === 0) {
                    const isHit = Math.random() > 0.05; // 95% hit rate
                    particles.push({
                        x: 100,
                        y: 180,
                        targetPath: isHit ? 'hit' : 'miss',
                        progress: 0,
                        color: isHit ? colors.success : colors.warning
                    });
                }
                
                // Update existing particles
                particles.forEach((particle, index) => {
                    particle.progress += 0.015;
                    
                    if (particle.progress < 0.25) {
                        // Request -> Hash
                        particle.x = 100 + (300 - 100) * (particle.progress * 4);
                        particle.y = 180;
                    } else if (particle.progress < 0.5) {
                        // Hash -> Lookup
                        const t = (particle.progress - 0.25) * 4;
                        particle.x = 300 + (500 - 300) * t;
                        particle.y = 180;
                    } else if (particle.progress < 0.75) {
                        // Lookup -> Hit/Miss
                        const t = (particle.progress - 0.5) * 4;
                        if (particle.targetPath === 'hit') {
                            particle.x = 500 + 200 * t;
                            particle.y = 180 - 75 * t;
                        } else {
                            particle.x = 500 + 200 * t;
                            particle.y = 180 + 65 * t;
                        }
                    } else if (particle.progress < 1) {
                        // Hit/Miss -> Result
                        const t = (particle.progress - 0.75) * 4;
                        if (particle.targetPath === 'hit') {
                            particle.x = 700 + 180 * t;
                            particle.y = 105 + 75 * t;
                        } else {
                            particle.x = 700 + 180 * t;
                            particle.y = 245 - 65 * t;
                        }
                    } else {
                        // Remove completed particles
                        particles.splice(index, 1);
                    }
                });
            }
            
            // Animation loop
            function animateCacheFlow() {
                drawCacheFlow();
                requestAnimationFrame(animateCacheFlow);
            }
            
            animateCacheFlow();
        }
    </script>

</body>
</html> 
