<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>System Architecture - Albert Framework</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        h1, h2, h3 {
            color: #1976d2;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .subtitle {
            font-size: 1.2em;
            color: #666;
            margin-bottom: 30px;
        }
        
        .architecture-container {
            background: white;
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            margin-bottom: 40px;
        }
        
        #main-diagram {
            width: 100%;
            height: 600px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
        }
        
        .component-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 30px;
            margin-top: 40px;
        }
        
        .component-card {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 8px;
            border-left: 4px solid #1976d2;
        }
        
        .component-card h3 {
            margin-top: 0;
            color: #1976d2;
        }
        
        .data-flow {
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            margin-bottom: 30px;
        }
        
        .flow-step {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
            transition: all 0.3s ease;
        }
        
        .flow-step:hover {
            background: #e3f2fd;
            transform: translateX(10px);
        }
        
        .step-number {
            background: #1976d2;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-right: 20px;
            flex-shrink: 0;
        }
        
        .layer-diagram {
            background: white;
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            margin-bottom: 30px;
        }
        
        #layer-visualization {
            width: 100%;
            height: 400px;
        }
        
        .performance-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }
        
        .metric-box {
            background: linear-gradient(135deg, #1976d2 0%, #42a5f5 100%);
            color: white;
            padding: 25px;
            border-radius: 8px;
            text-align: center;
        }
        
        .metric-value {
            font-size: 2.5em;
            font-weight: bold;
            display: block;
            margin-bottom: 5px;
        }
        
        .metric-label {
            opacity: 0.9;
        }
        
        code {
            background-color: #f5f5f5;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }
        
        .interactive-hint {
            background: #e3f2fd;
            color: #1565c0;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .module-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .module-item {
            background: #e8f5e9;
            padding: 15px;
            border-radius: 6px;
            text-align: center;
            font-weight: 500;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .module-item:hover {
            background: #c8e6c9;
            transform: scale(1.05);
        }
        
        .connection-line {
            stroke: #1976d2;
            stroke-width: 2;
            fill: none;
            stroke-dasharray: 5,5;
            animation: dash 20s linear infinite;
        }
        
        @keyframes dash {
            to {
                stroke-dashoffset: -1000;
            }
        }
    </style>
</head>
<body>
    <h1>Albert Framework Architecture</h1>
    <p class="subtitle">Complete System Design and Data Flow</p>
    
    <div class="architecture-container">
        <h2>Interactive System Architecture</h2>
        <div class="interactive-hint">
            üñ±Ô∏è Click on components to see detailed information
        </div>
        <canvas id="main-diagram"></canvas>
    </div>

    <div class="data-flow">
        <h2>Data Processing Pipeline</h2>
        <div class="flow-step">
            <div class="step-number">1</div>
            <div>
                <h4>Theory Definition</h4>
                <p>Gravitational theories are defined as Python classes inheriting from <code>GravitationalTheory</code>. Each theory implements metric tensor g_ŒºŒΩ, Christoffel symbols Œì^Œº_Œ±Œ≤, and optional quantum corrections.</p>
            </div>
        </div>
        
        <div class="flow-step">
            <div class="step-number">2</div>
            <div>
                <h4>Geodesic Integration</h4>
                <p>The <code>GeodesicIntegrator</code> solves the geodesic equation using 8th-order Dormand-Prince method with adaptive timestep control. Supports both timelike and null geodesics.</p>
            </div>
        </div>
        
        <div class="flow-step">
            <div class="step-number">3</div>
            <div>
                <h4>Trajectory Caching</h4>
                <p>Computed trajectories are cached using HDF5 format with compression. Cache keys include theory parameters, initial conditions, and numerical precision settings.</p>
            </div>
        </div>
        
        <div class="flow-step">
            <div class="step-number">4</div>
            <div>
                <h4>Validation Suite</h4>
                <p>Multi-layered validation including analytical tests, numerical convergence, quantum corrections, and experimental comparison. Results are aggregated into comprehensive scores.</p>
            </div>
        </div>
        
        <div class="flow-step">
            <div class="step-number">5</div>
            <div>
                <h4>Visualization & Analysis</h4>
                <p>Results are visualized using interactive 3D trajectory viewers, performance dashboards, and comparative analysis tools. Supports WebGPU-accelerated rendering.</p>
            </div>
        </div>
    </div>

    <div class="layer-diagram">
        <h2>System Layers</h2>
        <canvas id="layer-visualization"></canvas>
    </div>

    <div class="component-details">
        <div class="component-card">
            <h3>Theory Engine Core</h3>
            <p>Central orchestrator managing theory evaluation, trajectory computation, and validation workflows.</p>
            <div class="module-grid">
                <div class="module-item">TheoryEngine</div>
                <div class="module-item">GravitationalTheory</div>
                <div class="module-item">QuantumCorrections</div>
                <div class="module-item">ValidationManager</div>
            </div>
        </div>
        
        <div class="component-card">
            <h3>Numerical Solvers</h3>
            <p>High-precision integrators for geodesic equations and field evolution.</p>
            <div class="module-grid">
                <div class="module-item">GeodesicIntegrator</div>
                <div class="module-item">AdaptiveRK8</div>
                <div class="module-item">SymplecticIntegrator</div>
                <div class="module-item">ConstraintMonitor</div>
            </div>
        </div>
        
        <div class="component-card">
            <h3>Cache System</h3>
            <p>Intelligent caching layer for trajectory data and intermediate results.</p>
            <div class="module-grid">
                <div class="module-item">TrajectoryCache</div>
                <div class="module-item">HDF5Backend</div>
                <div class="module-item">CacheManager</div>
                <div class="module-item">CompressionEngine</div>
            </div>
        </div>
        
        <div class="component-card">
            <h3>Validation Framework</h3>
            <p>Comprehensive testing infrastructure for theory validation.</p>
            <div class="module-grid">
                <div class="module-item">AnalyticalValidator</div>
                <div class="module-item">NumericalValidator</div>
                <div class="module-item">QuantumValidator</div>
                <div class="module-item">ExperimentalValidator</div>
            </div>
        </div>
    </div>

    <div class="performance-metrics">
        <div class="metric-box">
            <span class="metric-value">10‚Åª¬π¬≤</span>
            <span class="metric-label">Numerical Precision</span>
        </div>
        <div class="metric-box">
            <span class="metric-value">8th</span>
            <span class="metric-label">Integration Order</span>
        </div>
        <div class="metric-box">
            <span class="metric-value">32</span>
            <span class="metric-label">Parallel Theories</span>
        </div>
        <div class="metric-box">
            <span class="metric-value">5.7√ó</span>
            <span class="metric-label">Cache Speedup</span>
        </div>
    </div>

    <script>
        // Main architecture diagram
        const canvas = document.getElementById('main-diagram');
        const ctx = canvas.getContext('2d');
        canvas.width = canvas.offsetWidth;
        canvas.height = 600;

        // Component definitions
        const components = [
            {
                name: 'Theory Definitions',
                x: 100,
                y: 100,
                width: 200,
                height: 80,
                color: '#4caf50',
                details: 'Python classes defining gravitational theories'
            },
            {
                name: 'Theory Engine',
                x: 400,
                y: 100,
                width: 200,
                height: 80,
                color: '#1976d2',
                details: 'Core orchestration and management'
            },
            {
                name: 'Geodesic Integrator',
                x: 700,
                y: 100,
                width: 200,
                height: 80,
                color: '#ff9800',
                details: 'High-precision numerical integration'
            },
            {
                name: 'Cache System',
                x: 250,
                y: 250,
                width: 200,
                height: 80,
                color: '#9c27b0',
                details: 'HDF5-based trajectory caching'
            },
            {
                name: 'Validation Suite',
                x: 550,
                y: 250,
                width: 200,
                height: 80,
                color: '#f44336',
                details: 'Comprehensive testing framework'
            },
            {
                name: 'Visualization',
                x: 400,
                y: 400,
                width: 200,
                height: 80,
                color: '#00bcd4',
                details: 'Interactive 3D viewers and analysis'
            }
        ];

        // Connection definitions
        const connections = [
            {from: 0, to: 1},
            {from: 1, to: 2},
            {from: 1, to: 3},
            {from: 1, to: 4},
            {from: 2, to: 3},
            {from: 2, to: 4},
            {from: 3, to: 5},
            {from: 4, to: 5}
        ];

        // Particle system for data flow animation
        const particles = [];
        class Particle {
            constructor(fromComp, toComp) {
                this.from = fromComp;
                this.to = toComp;
                this.progress = 0;
                this.speed = 0.005 + Math.random() * 0.005;
            }
            
            update() {
                this.progress += this.speed;
                if (this.progress > 1) {
                    this.progress = 0;
                }
            }
            
            draw() {
                const x = this.from.x + this.from.width/2 + 
                         (this.to.x + this.to.width/2 - this.from.x - this.from.width/2) * this.progress;
                const y = this.from.y + this.from.height/2 + 
                         (this.to.y + this.to.height/2 - this.from.y - this.from.height/2) * this.progress;
                
                ctx.fillStyle = '#ffc107';
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Create particles for each connection
        connections.forEach(conn => {
            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    particles.push(new Particle(components[conn.from], components[conn.to]));
                }, i * 500);
            }
        });

        // Mouse interaction
        let hoveredComponent = null;
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            hoveredComponent = null;
            components.forEach(comp => {
                if (x >= comp.x && x <= comp.x + comp.width &&
                    y >= comp.y && y <= comp.y + comp.height) {
                    hoveredComponent = comp;
                    canvas.style.cursor = 'pointer';
                    return;
                }
            });
            
            if (!hoveredComponent) {
                canvas.style.cursor = 'default';
            }
        });

        canvas.addEventListener('click', (e) => {
            if (hoveredComponent) {
                alert(hoveredComponent.name + '\n\n' + hoveredComponent.details);
            }
        });

        function drawArchitecture() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw connections
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 2;
            connections.forEach(conn => {
                const from = components[conn.from];
                const to = components[conn.to];
                ctx.beginPath();
                ctx.moveTo(from.x + from.width/2, from.y + from.height/2);
                ctx.lineTo(to.x + to.width/2, to.y + to.height/2);
                ctx.stroke();
            });
            
            // Draw components
            components.forEach(comp => {
                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.1)';
                ctx.fillRect(comp.x + 4, comp.y + 4, comp.width, comp.height);
                
                // Component box
                ctx.fillStyle = comp === hoveredComponent ? 
                    comp.color + 'dd' : comp.color + 'cc';
                ctx.fillRect(comp.x, comp.y, comp.width, comp.height);
                
                // Border
                ctx.strokeStyle = comp === hoveredComponent ? '#000' : '#fff';
                ctx.lineWidth = comp === hoveredComponent ? 3 : 2;
                ctx.strokeRect(comp.x, comp.y, comp.width, comp.height);
                
                // Text
                ctx.fillStyle = 'white';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(comp.name, comp.x + comp.width/2, comp.y + comp.height/2);
            });
            
            // Update and draw particles
            particles.forEach(particle => {
                particle.update();
                particle.draw();
            });
            
            requestAnimationFrame(drawArchitecture);
        }

        drawArchitecture();

        // Layer visualization
        const layerCanvas = document.getElementById('layer-visualization');
        const layerCtx = layerCanvas.getContext('2d');
        layerCanvas.width = layerCanvas.offsetWidth;
        layerCanvas.height = 400;

        const layers = [
            {name: 'User Interface', color: '#00bcd4', y: 50},
            {name: 'API Layer', color: '#4caf50', y: 120},
            {name: 'Core Engine', color: '#1976d2', y: 190},
            {name: 'Computational Backend', color: '#ff9800', y: 260},
            {name: 'Storage Layer', color: '#9c27b0', y: 330}
        ];

        let layerAnimation = 0;

        function drawLayers() {
            layerCtx.clearRect(0, 0, layerCanvas.width, layerCanvas.height);
            
            layers.forEach((layer, index) => {
                const width = layerCanvas.width - 100;
                const height = 50;
                const x = 50;
                
                // Animated appearance
                const alpha = Math.min(1, layerAnimation - index * 0.2);
                if (alpha > 0) {
                    // Layer box
                    layerCtx.fillStyle = layer.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                    layerCtx.fillRect(x, layer.y, width * alpha, height);
                    
                    // Layer border
                    layerCtx.strokeStyle = layer.color;
                    layerCtx.lineWidth = 2;
                    layerCtx.strokeRect(x, layer.y, width * alpha, height);
                    
                    // Layer text
                    if (alpha > 0.5) {
                        layerCtx.fillStyle = 'white';
                        layerCtx.font = 'bold 16px Arial';
                        layerCtx.textAlign = 'center';
                        layerCtx.textBaseline = 'middle';
                        layerCtx.fillText(layer.name, layerCanvas.width/2, layer.y + height/2);
                    }
                }
                
                // Draw connections between layers
                if (index < layers.length - 1 && alpha > 0.8) {
                    layerCtx.strokeStyle = '#666';
                    layerCtx.lineWidth = 1;
                    layerCtx.setLineDash([5, 5]);
                    layerCtx.beginPath();
                    layerCtx.moveTo(layerCanvas.width/2 - 30, layer.y + height);
                    layerCtx.lineTo(layerCanvas.width/2 - 30, layers[index + 1].y);
                    layerCtx.moveTo(layerCanvas.width/2, layer.y + height);
                    layerCtx.lineTo(layerCanvas.width/2, layers[index + 1].y);
                    layerCtx.moveTo(layerCanvas.width/2 + 30, layer.y + height);
                    layerCtx.lineTo(layerCanvas.width/2 + 30, layers[index + 1].y);
                    layerCtx.stroke();
                    layerCtx.setLineDash([]);
                }
            });
            
            if (layerAnimation < 2) {
                layerAnimation += 0.02;
                requestAnimationFrame(drawLayers);
            }
        }

        drawLayers();
    </script>
</body>
</html>