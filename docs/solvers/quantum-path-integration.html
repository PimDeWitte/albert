<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Path Integration with PennyLane</title>
    <script src="https://unpkg.com/mermaid@10/dist/mermaid.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/components/prism-python.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.28.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: white;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        h1, h2, h3 {
            color: #2c3e50;
        }
        h1 {
            border-bottom: 3px solid #9b59b6;
            padding-bottom: 10px;
            margin-bottom: 30px;
        }
        h2 {
            margin-top: 40px;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 10px;
        }
        .nav-back {
            display: inline-block;
            background-color: #9b59b6;
            color: white;
            padding: 10px 20px;
            text-decoration: none;
            border-radius: 5px;
            margin-bottom: 20px;
            transition: all 0.3s ease;
        }
        .nav-back:hover {
            background-color: #8e44ad;
            transform: translateX(-5px);
        }
        .info-box {
            background-color: #e8f4fd;
            border-left: 4px solid #3498db;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }
        .warning-box {
            background-color: #fef9e7;
            border-left: 4px solid #f39c12;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }
        .method-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }
        .method-card {
            background-color: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
            transition: all 0.3s ease;
        }
        .method-card:hover {
            border-color: #9b59b6;
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        .method-card h3 {
            color: #9b59b6;
            margin-top: 0;
        }
        .code-section {
            background-color: #2d2d2d;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            overflow-x: auto;
        }
        .mermaid-container {
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            overflow-x: auto;
            text-align: center;
        }
        .quantum-features {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin: 30px 0;
        }
        .feature-box {
            background-color: #fff;
            border: 2px solid #9b59b6;
            border-radius: 8px;
            padding: 20px;
        }
        .feature-box h4 {
            color: #9b59b6;
            margin-top: 0;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        th {
            background-color: #9b59b6;
            color: white;
        }
        tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        .implementation-note {
            background-color: #f0e6ff;
            border-left: 4px solid #9b59b6;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }
        .formula {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            text-align: center;
            margin: 15px 0;
            font-size: 16px;
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="nav-back">← Back to Solver Docs</a>
        
        <h1>Quantum Path Integration with PennyLane</h1>
        
        <div class="info-box">
            <h3>Overview</h3>
            <p>The quantum path integrator uses Feynman's path integral formulation to compute quantum trajectories in curved spacetime. It leverages <strong>PennyLane</strong> for quantum circuit simulation and combines multiple approximation methods to handle the computational complexity.</p>
        </div>

        <h2>Architecture Overview</h2>
        
        <div class="mermaid-container">
            <div class="mermaid">
                graph TB
                    subgraph "Quantum Theory Detection"
                        QT[Quantum Theory]
                        QT --> QC{theory.category<br/>== 'quantum'?}
                        QC -->|Yes| QPI[QuantumPathIntegrator]
                        QC -->|No| Classical[Classical Solver]
                    end

                    subgraph "QuantumPathIntegrator Components"
                        QPI --> MC[Monte Carlo<br/>Path Sampling]
                        QPI --> WKB[WKB<br/>Approximation]
                        QPI --> SP[Stationary Phase<br/>Approximation]
                        QPI --> PL[PennyLane<br/>Circuit Simulation]
                    end

                    subgraph "PennyLane Integration"
                        PL --> QC2[Quantum Circuits]
                        PL --> HS[Hamiltonian<br/>Simulation]
                        PL --> QM[Quantum<br/>Measurements]
                    end

                    subgraph "Output"
                        MC --> AMP[Amplitude]
                        WKB --> AMP
                        SP --> AMP
                        AMP --> PROB[Probability<br/>|ψ|²]
                        AMP --> CORR[Quantum<br/>Corrections]
                    end

                    style QPI fill:#9b59b6,stroke:#8e44ad,stroke-width:2px,color:#fff
                    style PL fill:#e74c3c,stroke:#c0392b,stroke-width:2px,color:#fff
            </div>
        </div>

        <h2>Implementation Details</h2>

        <h3>1. QuantumPathIntegrator Class</h3>
        
        <div class="code-section">
            <pre><code class="language-python"># quantum_path_integrator.py:36-65
class QuantumPathIntegrator:
    """
    Main integrator for quantum trajectories via path integral approximation
    
    Implements various approximation methods:
    1. Monte Carlo sampling of paths
    2. Semiclassical WKB approximation
    3. Stationary phase approximation
    """
    
    def __init__(self, theory, enable_quantum: bool = True):
        self.theory = theory
        self.enable_quantum = enable_quantum
        self.hbar = HBAR
        
        # Cache for lambdified Lagrangian functions
        self._lagrangian_func_cache = {}
        
        # Initialize geodesic solver for exact path computation
        self._geodesic_solver = None  # Will be initialized on first use</code></pre>
        </div>

        <h3>2. PennyLane Integration</h3>

        <div class="info-box">
            <h4>QuantumCorrectedGeodesicSolver</h4>
            <p>This solver uses PennyLane's quantum circuit simulation to add quantum corrections to classical geodesics:</p>
        </div>

        <div class="code-section">
            <pre><code class="language-python"># geodesic_integrator.py:1080-1117
class QuantumCorrectedGeodesicSolver(GeneralRelativisticGeodesicSolver):
    """
    Quantum geodesic simulator using PennyLane for state evolution.
    Evolves quantum state according to Hamiltonian derived from Lagrangian.
    """
    
    def __init__(self, model, num_qubits: int = 4, **kwargs):
        super().__init__(model, **kwargs)
        self.num_qubits = num_qubits
        self.dev = qml.device("default.qubit", wires=num_qubits)
        self._hamiltonian_func = self._derive_hamiltonian(model.lagrangian)
        
    def _derive_hamiltonian(self, lagrangian):
        @qml.qnode(self.dev)
        def hamiltonian_circuit(params):
            """Circuit that computes expectation value of Hamiltonian"""
            # Apply rotation gates based on position/momentum
            qml.RY(params[0], wires=0)  # Position encoding
            qml.RZ(params[1], wires=1)  # Momentum encoding
            
            # Entangle qubits for correlation
            qml.CNOT(wires=[0, 1])
            
            # Apply more rotations
            qml.RX(params[0] * params[1], wires=0)
            
            # Measure observable representing energy
            return qml.expval(qml.PauliZ(0) @ qml.PauliZ(1))
        
        return hamiltonian_circuit</code></pre>
        </div>

        <h2>Path Integral Methods</h2>

        <div class="method-grid">
            <div class="method-card">
                <h3>Monte Carlo Sampling</h3>
                <p><strong>Method:</strong> Randomly samples many paths between initial and final states</p>
                <p><strong>Formula:</strong></p>
                <div class="formula">⟨f|i⟩ = ∫ Dq(t) exp(iS[q]/ℏ)</div>
                <p><strong>Use Case:</strong> General quantum systems, high accuracy but computationally intensive</p>
                <p><strong>Implementation:</strong> <code>compute_amplitude_monte_carlo()</code></p>
            </div>

            <div class="method-card">
                <h3>WKB Approximation</h3>
                <p><strong>Method:</strong> Semiclassical approximation valid when action ≫ ℏ</p>
                <p><strong>Formula:</strong></p>
                <div class="formula">ψ ≈ A exp(iS_cl/ℏ)</div>
                <p><strong>Use Case:</strong> High-energy particles, macroscopic objects</p>
                <p><strong>Implementation:</strong> <code>compute_amplitude_wkb()</code></p>
            </div>

            <div class="method-card">
                <h3>Stationary Phase</h3>
                <p><strong>Method:</strong> Evaluates integral around classical path</p>
                <p><strong>Formula:</strong></p>
                <div class="formula">∫ f(x)e^(iS(x)/ℏ) dx ≈ f(x₀)√(2πiℏ/S''(x₀))e^(iS(x₀)/ℏ)</div>
                <p><strong>Use Case:</strong> Near-classical regime, fast approximation</p>
                <p><strong>Implementation:</strong> <code>compute_amplitude_stationary_phase()</code></p>
            </div>

            <div class="method-card">
                <h3>Geodesic Path</h3>
                <p><strong>Method:</strong> Uses classical geodesic as the stationary path</p>
                <p><strong>Formula:</strong></p>
                <div class="formula">δS[q_cl] = 0</div>
                <p><strong>Use Case:</strong> Finding the classical limit</p>
                <p><strong>Implementation:</strong> <code>_compute_geodesic_path()</code></p>
            </div>
        </div>

        <h2>Quantum Features</h2>

        <div class="quantum-features">
            <div class="feature-box">
                <h4>Amplitude Calculation</h4>
                <p>Computes complex amplitude for transitions between quantum states:</p>
                <ul>
                    <li>Position-momentum uncertainty</li>
                    <li>Phase accumulation along paths</li>
                    <li>Interference between paths</li>
                </ul>
            </div>

            <div class="feature-box">
                <h4>Quantum Corrections</h4>
                <p>Adds quantum effects to classical trajectories:</p>
                <ul>
                    <li>Zero-point energy fluctuations</li>
                    <li>Tunneling probabilities</li>
                    <li>Decoherence effects</li>
                </ul>
            </div>
        </div>

        <h2>PennyLane Circuit Components</h2>

        <table>
            <tr>
                <th>Component</th>
                <th>Purpose</th>
                <th>Implementation</th>
            </tr>
            <tr>
                <td>Quantum Device</td>
                <td>Simulates quantum circuits</td>
                <td><code>qml.device("default.qubit", wires=4)</code></td>
            </tr>
            <tr>
                <td>Position Encoding</td>
                <td>Encodes spatial position in qubit rotations</td>
                <td><code>qml.RY(position, wires=0)</code></td>
            </tr>
            <tr>
                <td>Momentum Encoding</td>
                <td>Encodes momentum in qubit phases</td>
                <td><code>qml.RZ(momentum, wires=1)</code></td>
            </tr>
            <tr>
                <td>Entanglement</td>
                <td>Creates quantum correlations</td>
                <td><code>qml.CNOT(wires=[0, 1])</code></td>
            </tr>
            <tr>
                <td>Hamiltonian Measurement</td>
                <td>Extracts energy expectation values</td>
                <td><code>qml.expval(qml.PauliZ(0) @ qml.PauliZ(1))</code></td>
            </tr>
        </table>

        <h2>Usage in Theory Engine</h2>

        <div class="implementation-note">
            <h4>Theory Engine Integration</h4>
            <p>When a quantum theory is detected, the engine can run trajectories with PennyLane:</p>
        </div>

        <div class="code-section">
            <pre><code class="language-python"># theory_engine_core.py:2673-2695
if theory_category == 'quantum' and not args.skip_quantum_pennylane:
    print(f"Computing quantum trajectories with PennyLane solver...")
    
    quantum_particle_results = engine.run_multi_particle_trajectories(
        model, r0_val, effective_steps, effective_dtau.item() * engine.time_scale,
        theory_category=theory_category,
        use_pennylane_quantum=True,  # Use PennyLane-based quantum solver
        quantum_interval=quantum_interval,
        quantum_beta=quantum_beta,
        no_cache=True,  # Always disable cache for quantum
        max_parallel_workers=1,  # Limit parallelism for memory
    )</code></pre>
        </div>

        <h2>Quantum Loss Calculation</h2>

        <div class="info-box">
            <h4>QuantumLossCalculator</h4>
            <p>Specialized loss calculator for comparing quantum predictions with observations:</p>
        </div>

        <div class="code-section">
            <pre><code class="language-python"># quantum_path_integrator.py:799-841
class QuantumLossCalculator:
    """Calculate loss by comparing quantum predictions to observations"""
    
    def compute_pulsar_quantum_loss(self, observed_data, theory_params):
        """Compute loss using pulsar timing data with quantum corrections"""
        
        # Compute quantum transition probability
        prob = self.integrator.compute_transition_probability(
            start, end,
            method='wkb',
            **combined_params
        )
        
        # Quantum correction to delay
        quantum_delay = observed_delay * (1 - prob)
        
        # Loss: squared difference weighted by precision
        loss = ((quantum_delay - observed_delay) / timing_precision) ** 2</code></pre>
        </div>

        <div class="warning-box">
            <h3>Important Notes</h3>
            <ul>
                <li>This is an experimental approximation combining classical geodesics with quantum circuit simulation</li>
                <li>It does not represent a full theory of quantum gravity</li>
                <li>Quantum effects in gravity are extremely small for macroscopic observations</li>
                <li>The PennyLane integration is used for exploring theoretical quantum corrections</li>
            </ul>
        </div>

        <h2>Performance Considerations</h2>

        <table>
            <tr>
                <th>Method</th>
                <th>Computational Cost</th>
                <th>Accuracy</th>
                <th>Best Use Case</th>
            </tr>
            <tr>
                <td>Monte Carlo</td>
                <td>O(N) paths</td>
                <td>High</td>
                <td>Research/validation</td>
            </tr>
            <tr>
                <td>WKB</td>
                <td>O(1)</td>
                <td>Good for S ≫ ℏ</td>
                <td>Macroscopic particles</td>
            </tr>
            <tr>
                <td>Stationary Phase</td>
                <td>O(1)</td>
                <td>Moderate</td>
                <td>Quick estimates</td>
            </tr>
            <tr>
                <td>PennyLane Circuits</td>
                <td>O(2^n) qubits</td>
                <td>Exact (for model)</td>
                <td>Small quantum systems</td>
            </tr>
        </table>
    </div>

    <script>
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            flowchart: {
                curve: 'basis'
            }
        });
    </script>
</body>
</html>