<!DOCTYPE html>
<html>
<head>
    <title>Unified Trajectory Viewer - {{ title }}</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #000;
        }
        
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 5px;
            color: white;
            max-width: 350px;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        #info {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 5px;
            color: white;
            text-align: right;
            font-size: 14px;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            color: #aaa;
        }
        
        select, button, input[type="range"] {
            width: 100%;
            padding: 5px;
            margin-bottom: 5px;
            background: #333;
            color: white;
            border: 1px solid #555;
            border-radius: 3px;
            cursor: pointer;
        }
        
        select:hover, button:hover {
            background: #444;
        }
        
        button.active {
            background: #0066cc;
        }
        
        input[type="range"] {
            -webkit-appearance: none;
            height: 20px;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 15px;
            height: 15px;
            background: #0066cc;
            cursor: pointer;
            border-radius: 50%;
        }
        
        #trajectoryInfo {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #555;
            font-size: 12px;
            color: #aaa;
        }
        
        .legend {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #555;
            font-size: 12px;
        }
        
        .legend-item {
            margin-bottom: 5px;
        }
        
        .legend-color {
            display: inline-block;
            width: 12px;
            height: 12px;
            margin-right: 5px;
            vertical-align: middle;
        }
    </style>
</head>
<body>
    <div id="controls">
        <h3 style="margin-top: 0;">Unified Trajectory Viewer</h3>
        
        <div class="control-group">
            <label>Theory:</label>
            <select id="theorySelect">
                <option value="">Loading theories...</option>
            </select>
        </div>
        
        <div class="control-group">
            <label>Particle:</label>
            <select id="particleSelect">
                <option value="">Select a theory first</option>
            </select>
        </div>
        
        <div class="control-group">
            <label>Camera View:</label>
            <select id="cameraView">
                <option value="thirdPerson">Third Person</option>
                <option value="topView">Top View</option>
                <option value="sideView">Side View</option>
                <option value="followParticle">Follow Particle</option>
                <option value="firstPerson">First Person</option>
            </select>
        </div>
        
        <div class="control-group">
            <label>Animation:</label>
            <button id="playPause">▶️ Play</button>
            <label>Speed: <span id="speedValue">1.0</span>x</label>
            <input type="range" id="speed" min="0.1" max="10" step="0.1" value="1">
            <label>Time: <span id="timeValue">0</span> / <span id="maxTime">0</span></label>
            <input type="range" id="timeScrubber" min="0" max="1000" value="0">
        </div>
        
        <div class="control-group">
            <label>Visibility:</label>
            <button id="toggleGrid" class="active">Grid</button>
            <button id="toggleTrajectory" class="active">Trajectory</button>
            <button id="toggleStars" class="active">Stars</button>
            <button id="toggleISCO" class="active">ISCO</button>
            <button id="togglePhotonSphere" class="active">Photon Sphere</button>
        </div>
        
        <div id="trajectoryInfo"></div>
        
        <div class="legend">
            <div class="legend-item">
                <span class="legend-color" style="background: black; border: 1px solid orange;"></span>
                Event Horizon (r = 2M)
            </div>
            <div class="legend-item">
                <span class="legend-color" style="background: rgba(255, 255, 0, 0.3);"></span>
                Photon Sphere (r = 3M)
            </div>
            <div class="legend-item">
                <span class="legend-color" style="background: rgba(0, 255, 255, 0.3);"></span>
                ISCO (r = 6M)
            </div>
        </div>
    </div>
    
    <div id="info">
        <div>Black Hole Mass: {{ bh_mass_kg }} kg</div>
        <div>Schwarzschild Radius: {{ bh_radius_m }} m</div>
        <div id="currentInfo"></div>
    </div>
    
    <script>
        // Constants
        const c = 299792458; // Speed of light (m/s)
        const G = 6.67430e-11; // Gravitational constant
        const M = {{ bh_mass }}; // Black hole mass in kg
        const Rs = 2 * G * M / (c * c); // Schwarzschild radius in meters
        
        // All trajectory data
        const allTrajectoryData = {{ trajectory_data }};
        
        // Scene setup
        let scene, camera, renderer, controls;
        let blackHole, photonSphere, isco, grid;
        let particleGroup, trajectoryLine;
        let stars = [];
        let isPlaying = false;
        let currentTime = 0;
        let animationSpeed = 1.0;
        let currentTrajectoryData = null;
        let currentTheory = '';
        let currentParticle = '';
        
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000814);
            
            // Camera
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(30, 20, 30);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            
            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.target.set(0, 0, 0);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(50, 50, 50);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            const pointLight = new THREE.PointLight(0xff6600, 1, 100);
            pointLight.position.set(0, 0, 0);
            scene.add(pointLight);
            
            // Create objects
            createBlackHole();
            createGrid();
            createStars();
            
            // Populate theory dropdown
            populateTheoryDropdown();
            
            // Event listeners
            setupEventListeners();
            
            // Start animation
            animate();
        }
        
        function createBlackHole() {
            // Event horizon (r = 2M)
            const bhGeometry = new THREE.SphereGeometry(2, 32, 32);
            const bhMaterial = new THREE.MeshPhongMaterial({
                color: 0x000000,
                emissive: 0x000000,
                specular: 0x000000,
                shininess: 0
            });
            blackHole = new THREE.Mesh(bhGeometry, bhMaterial);
            blackHole.castShadow = true;
            scene.add(blackHole);
            
            // Inner glow
            const innerGlowGeometry = new THREE.SphereGeometry(2.5, 32, 32);
            const innerGlowMaterial = new THREE.MeshBasicMaterial({
                color: 0xff4400,
                transparent: true,
                opacity: 0.4,
                side: THREE.BackSide
            });
            const innerGlow = new THREE.Mesh(innerGlowGeometry, innerGlowMaterial);
            scene.add(innerGlow);
            
            // Outer glow
            const outerGlowGeometry = new THREE.SphereGeometry(3, 32, 32);
            const outerGlowMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0.2,
                side: THREE.BackSide
            });
            const outerGlow = new THREE.Mesh(outerGlowGeometry, outerGlowMaterial);
            scene.add(outerGlow);
            
            // Photon sphere (r = 3M)
            const photonGeometry = new THREE.SphereGeometry(3, 32, 32);
            const photonMaterial = new THREE.MeshBasicMaterial({
                color: 0xffff00,
                transparent: true,
                opacity: 0.1,
                wireframe: true
            });
            photonSphere = new THREE.Mesh(photonGeometry, photonMaterial);
            scene.add(photonSphere);
            
            // ISCO (r = 6M)
            const iscoGeometry = new THREE.TorusGeometry(6, 0.1, 8, 64);
            const iscoMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.5
            });
            isco = new THREE.Mesh(iscoGeometry, iscoMaterial);
            isco.rotation.x = Math.PI / 2;
            scene.add(isco);
            
            // Accretion disk
            const diskGeometry = new THREE.RingGeometry(4, 12, 64);
            const diskMaterial = new THREE.MeshBasicMaterial({
                color: 0xff6600,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            const disk = new THREE.Mesh(diskGeometry, diskMaterial);
            disk.rotation.x = -Math.PI / 2;
            scene.add(disk);
        }
        
        function createGrid() {
            // Create curved spacetime grid
            const gridSize = 50;
            const divisions = 20;
            const gridPoints = [];
            
            // Create grid lines that curve near the black hole
            for (let i = -divisions; i <= divisions; i++) {
                const linePoints = [];
                for (let j = -divisions; j <= divisions; j++) {
                    const x = (i / divisions) * gridSize;
                    const z = (j / divisions) * gridSize;
                    const r = Math.sqrt(x * x + z * z);
                    
                    // Curvature effect - dip near black hole
                    let y = 0;
                    if (r > 2) { // Outside event horizon
                        y = -10 * (2 / r) * Math.exp(-r / 10);
                    }
                    
                    linePoints.push(new THREE.Vector3(x, y, z));
                }
                
                const geometry = new THREE.BufferGeometry().setFromPoints(linePoints);
                const material = new THREE.LineBasicMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.3
                });
                const line = new THREE.Line(geometry, material);
                scene.add(line);
            }
            
            // Create perpendicular lines
            for (let i = -divisions; i <= divisions; i++) {
                const linePoints = [];
                for (let j = -divisions; j <= divisions; j++) {
                    const x = (j / divisions) * gridSize;
                    const z = (i / divisions) * gridSize;
                    const r = Math.sqrt(x * x + z * z);
                    
                    let y = 0;
                    if (r > 2) {
                        y = -10 * (2 / r) * Math.exp(-r / 10);
                    }
                    
                    linePoints.push(new THREE.Vector3(x, y, z));
                }
                
                const geometry = new THREE.BufferGeometry().setFromPoints(linePoints);
                const material = new THREE.LineBasicMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.3
                });
                const line = new THREE.Line(geometry, material);
                scene.add(line);
            }
            
            grid = new THREE.Group();
            scene.children.forEach(child => {
                if (child instanceof THREE.Line && child.material.color.getHex() === 0x00ff00) {
                    grid.add(child);
                }
            });
        }
        
        function createStars() {
            const starGeometry = new THREE.SphereGeometry(0.1, 4, 4);
            const starColors = [0xffffff, 0xffffcc, 0xccccff];
            
            for (let i = 0; i < 5000; i++) {
                const starMaterial = new THREE.MeshBasicMaterial({
                    color: starColors[Math.floor(Math.random() * starColors.length)],
                    emissive: starColors[Math.floor(Math.random() * starColors.length)],
                    emissiveIntensity: 0.8
                });
                
                const star = new THREE.Mesh(starGeometry, starMaterial);
                
                // Random position on sphere
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const r = 200 + Math.random() * 100;
                
                star.position.x = r * Math.sin(phi) * Math.cos(theta);
                star.position.y = r * Math.sin(phi) * Math.sin(theta);
                star.position.z = r * Math.cos(phi);
                
                stars.push(star);
                scene.add(star);
            }
        }
        
        function populateTheoryDropdown() {
            const theorySelect = document.getElementById('theorySelect');
            theorySelect.innerHTML = '';
            
            const theories = Object.keys(allTrajectoryData).sort();
            theories.forEach(theory => {
                const option = document.createElement('option');
                option.value = theory;
                option.textContent = theory.replace(/_/g, ' ');
                theorySelect.appendChild(option);
            });
            
            if (theories.length > 0) {
                theorySelect.value = theories[0];
                onTheoryChange();
            }
        }
        
        function onTheoryChange() {
            const theory = document.getElementById('theorySelect').value;
            const particleSelect = document.getElementById('particleSelect');
            
            if (!theory || !allTrajectoryData[theory]) {
                particleSelect.innerHTML = '<option value="">No theory selected</option>';
                return;
            }
            
            currentTheory = theory;
            const particles = Object.keys(allTrajectoryData[theory]).sort();
            
            particleSelect.innerHTML = '';
            particles.forEach(particle => {
                const option = document.createElement('option');
                option.value = particle;
                option.textContent = particle.charAt(0).toUpperCase() + particle.slice(1);
                particleSelect.appendChild(option);
            });
            
            if (particles.length > 0) {
                particleSelect.value = particles[0];
                onParticleChange();
            }
        }
        
        function onParticleChange() {
            const theory = document.getElementById('theorySelect').value;
            const particle = document.getElementById('particleSelect').value;
            
            if (!theory || !particle || !allTrajectoryData[theory] || !allTrajectoryData[theory][particle]) {
                return;
            }
            
            currentParticle = particle;
            loadTrajectory(allTrajectoryData[theory][particle]);
        }
        
        function loadTrajectory(trajectoryData) {
            currentTrajectoryData = trajectoryData;
            currentTime = 0;
            document.getElementById('timeScrubber').value = 0;
            
            // Remove old trajectory and particles
            if (trajectoryLine) {
                scene.remove(trajectoryLine);
            }
            if (particleGroup) {
                scene.remove(particleGroup);
            }
            
            // Create trajectory line
            const points = [];
            for (let i = 0; i < trajectoryData.r.length; i++) {
                const r = trajectoryData.r[i];
                const theta = trajectoryData.theta[i];
                const phi = trajectoryData.phi[i];
                
                // Convert spherical to Cartesian
                const x = r * Math.sin(theta) * Math.cos(phi);
                const y = r * Math.cos(theta);  // Note: y and z swapped for better view
                const z = r * Math.sin(theta) * Math.sin(phi);
                
                points.push(new THREE.Vector3(x, y, z));
            }
            
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({
                color: getParticleColor(currentParticle),
                transparent: true,
                opacity: 0.6,
                linewidth: 2
            });
            trajectoryLine = new THREE.Line(geometry, material);
            scene.add(trajectoryLine);
            
            // Create particle
            particleGroup = new THREE.Group();
            
            const particleGeometry = new THREE.SphereGeometry(0.8, 16, 16);
            const particleMaterial = new THREE.MeshPhongMaterial({
                color: getParticleColor(currentParticle),
                emissive: getParticleColor(currentParticle),
                emissiveIntensity: 0.5,
                transparent: true,
                opacity: 0.9
            });
            
            const particle = new THREE.Mesh(particleGeometry, particleMaterial);
            particleGroup.add(particle);
            
            // Add particle trail
            const trailGeometry = new THREE.SphereGeometry(0.4, 8, 8);
            const trailMaterial = new THREE.MeshBasicMaterial({
                color: getParticleColor(currentParticle),
                transparent: true,
                opacity: 0.3
            });
            
            for (let i = 0; i < 10; i++) {
                const trail = new THREE.Mesh(trailGeometry, trailMaterial);
                particleGroup.add(trail);
            }
            
            scene.add(particleGroup);
            
            // Update UI
            document.getElementById('maxTime').textContent = trajectoryData.r.length - 1;
            document.getElementById('timeScrubber').max = trajectoryData.r.length - 1;
            
            updateTrajectoryInfo();
        }
        
        function getParticleColor(particle) {
            const colors = {
                electron: 0x00ff00,
                neutrino: 0xff00ff,
                photon: 0xffff00,
                proton: 0xff0000
            };
            return colors[particle] || 0xffffff;
        }
        
        function updateTrajectoryInfo() {
            if (!currentTrajectoryData) return;
            
            const info = document.getElementById('trajectoryInfo');
            const data = currentTrajectoryData;
            
            const rMin = Math.min(...data.r);
            const rMax = Math.max(...data.r);
            const phiRange = Math.max(...data.phi) - Math.min(...data.phi);
            const thetaRange = Math.max(...data.theta) - Math.min(...data.theta);
            
            info.innerHTML = `
                <strong>Trajectory Info:</strong><br>
                Theory: ${currentTheory.replace(/_/g, ' ')}<br>
                Particle: ${currentParticle}<br>
                Points: ${data.r.length}<br>
                r range: ${rMin.toFixed(2)} - ${rMax.toFixed(2)} M<br>
                φ range: ${(phiRange * 180 / Math.PI).toFixed(1)}°<br>
                θ variation: ${(thetaRange * 180 / Math.PI).toFixed(3)}°<br>
                ${thetaRange < 0.01 ? 'Motion: Equatorial plane' : 'Motion: 3D'}
            `;
        }
        
        function updateParticle() {
            if (!particleGroup || !currentTrajectoryData) return;
            
            const idx = Math.floor(currentTime);
            if (idx >= currentTrajectoryData.r.length) return;
            
            const r = currentTrajectoryData.r[idx];
            const theta = currentTrajectoryData.theta[idx];
            const phi = currentTrajectoryData.phi[idx];
            
            // Convert to Cartesian
            const x = r * Math.sin(theta) * Math.cos(phi);
            const y = r * Math.cos(theta);
            const z = r * Math.sin(theta) * Math.sin(phi);
            
            // Update main particle
            particleGroup.children[0].position.set(x, y, z);
            
            // Update trail
            for (let i = 1; i < particleGroup.children.length; i++) {
                const trailIdx = Math.max(0, idx - i * 5);
                const tr = currentTrajectoryData.r[trailIdx];
                const ttheta = currentTrajectoryData.theta[trailIdx];
                const tphi = currentTrajectoryData.phi[trailIdx];
                
                const tx = tr * Math.sin(ttheta) * Math.cos(tphi);
                const ty = tr * Math.cos(ttheta);
                const tz = tr * Math.sin(ttheta) * Math.sin(tphi);
                
                particleGroup.children[i].position.set(tx, ty, tz);
                particleGroup.children[i].material.opacity = 0.3 * (1 - i / 10);
            }
            
            // Update info
            document.getElementById('currentInfo').innerHTML = `
                <strong>Current State:</strong><br>
                Time: ${idx}<br>
                r: ${r.toFixed(2)} M<br>
                θ: ${(theta * 180 / Math.PI).toFixed(1)}°<br>
                φ: ${(phi * 180 / Math.PI).toFixed(1)}°
            `;
        }
        
        function setupEventListeners() {
            document.getElementById('theorySelect').addEventListener('change', onTheoryChange);
            document.getElementById('particleSelect').addEventListener('change', onParticleChange);
            
            document.getElementById('cameraView').addEventListener('change', (e) => {
                const view = e.target.value;
                switch(view) {
                    case 'thirdPerson':
                        camera.position.set(30, 20, 30);
                        controls.target.set(0, 0, 0);
                        break;
                    case 'topView':
                        camera.position.set(0, 50, 0);
                        controls.target.set(0, 0, 0);
                        break;
                    case 'sideView':
                        camera.position.set(50, 0, 0);
                        controls.target.set(0, 0, 0);
                        break;
                    case 'followParticle':
                    case 'firstPerson':
                        // Will be handled in animate()
                        break;
                }
                controls.update();
            });
            
            document.getElementById('playPause').addEventListener('click', () => {
                isPlaying = !isPlaying;
                document.getElementById('playPause').textContent = isPlaying ? '⏸️ Pause' : '▶️ Play';
            });
            
            document.getElementById('speed').addEventListener('input', (e) => {
                animationSpeed = parseFloat(e.target.value);
                document.getElementById('speedValue').textContent = animationSpeed.toFixed(1);
            });
            
            document.getElementById('timeScrubber').addEventListener('input', (e) => {
                currentTime = parseFloat(e.target.value);
                document.getElementById('timeValue').textContent = Math.floor(currentTime);
            });
            
            // Visibility toggles
            document.getElementById('toggleGrid').addEventListener('click', (e) => {
                e.target.classList.toggle('active');
                if (grid) grid.visible = e.target.classList.contains('active');
            });
            
            document.getElementById('toggleTrajectory').addEventListener('click', (e) => {
                e.target.classList.toggle('active');
                if (trajectoryLine) trajectoryLine.visible = e.target.classList.contains('active');
            });
            
            document.getElementById('toggleStars').addEventListener('click', (e) => {
                e.target.classList.toggle('active');
                stars.forEach(star => star.visible = e.target.classList.contains('active'));
            });
            
            document.getElementById('toggleISCO').addEventListener('click', (e) => {
                e.target.classList.toggle('active');
                if (isco) isco.visible = e.target.classList.contains('active');
            });
            
            document.getElementById('togglePhotonSphere').addEventListener('click', (e) => {
                e.target.classList.toggle('active');
                if (photonSphere) photonSphere.visible = e.target.classList.contains('active');
            });
            
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Update animation
            if (isPlaying && currentTrajectoryData) {
                currentTime += animationSpeed;
                if (currentTime >= currentTrajectoryData.r.length - 1) {
                    currentTime = 0;
                }
                document.getElementById('timeScrubber').value = currentTime;
                document.getElementById('timeValue').textContent = Math.floor(currentTime);
            }
            
            // Update particle position
            updateParticle();
            
            // Handle camera views
            const view = document.getElementById('cameraView').value;
            if (particleGroup && particleGroup.children[0]) {
                const particle = particleGroup.children[0];
                
                if (view === 'followParticle') {
                    const offset = new THREE.Vector3(20, 10, 20);
                    camera.position.copy(particle.position).add(offset);
                    controls.target.copy(particle.position);
                } else if (view === 'firstPerson') {
                    // Look ahead in the trajectory
                    const idx = Math.floor(currentTime);
                    const nextIdx = Math.min(idx + 10, currentTrajectoryData.r.length - 1);
                    
                    const r = currentTrajectoryData.r[nextIdx];
                    const theta = currentTrajectoryData.theta[nextIdx];
                    const phi = currentTrajectoryData.phi[nextIdx];
                    
                    const x = r * Math.sin(theta) * Math.cos(phi);
                    const y = r * Math.cos(theta);
                    const z = r * Math.sin(theta) * Math.sin(phi);
                    
                    camera.position.copy(particle.position);
                    camera.lookAt(x, y, z);
                }
            }
            
            // Rotate stars slowly
            stars.forEach((star, i) => {
                const angle = Date.now() * 0.00001 + i * 0.1;
                const r = star.position.length();
                star.position.x = r * Math.sin(angle) * Math.cos(i);
                star.position.z = r * Math.cos(angle) * Math.sin(i);
            });
            
            controls.update();
            renderer.render(scene, camera);
        }
        
        // Initialize
        init();
    </script>
</body>
</html>