<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Multi-Particle Trajectory Viewer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
            max-width: 350px;
            max-height: 85vh;
            overflow-y: auto;
        }
        
        .info {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
            max-width: 400px;
            max-height: 85vh;
            overflow-y: auto;
        }
        
        h3 {
            margin: 0 0 15px 0;
            font-size: 18px;
            color: #4a9eff;
        }
        
        .theory-selector {
            margin: 10px 0;
        }
        
        .theory-selector select {
            width: 100%;
            padding: 8px;
            border-radius: 4px;
            background: #1a1a1a;
            color: white;
            border: 1px solid #333;
            font-size: 14px;
        }
        
        .button {
            background: #2980b9;
            color: white;
            border: none;
            padding: 8px 16px;
            margin: 5px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .button:hover {
            background: #3498db;
        }
        
        .button.active {
            background: #e74c3c;
        }
        
        .button.primary {
            background: #27ae60;
        }
        
        .button.mounted {
            background: #f39c12;
        }
        
        .slider-container {
            margin: 10px 0;
        }
        
        .slider {
            width: 100%;
            margin: 5px 0;
        }
        
        .particle-control {
            background: #1a1a1a;
            padding: 10px;
            margin: 5px 0;
            border-radius: 4px;
            border: 1px solid #333;
        }
        
        .particle-control.primary {
            border-color: #27ae60;
        }
        
        .particle-control.mounted {
            border-color: #f39c12;
        }
        
        .particle-name {
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .particle-actions {
            display: flex;
            gap: 5px;
            margin-top: 5px;
        }
        
        .particle-toggle {
            margin-right: 10px;
        }
        
        .particle-toggle input {
            margin-right: 5px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            margin-right: 10px;
            border-radius: 3px;
        }
        
        .spacetime-info {
            background: #1a1a1a;
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
            border: 1px solid #333;
        }
        
        .tensor-info {
            background: #1a1a1a;
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
            border: 1px solid #333;
            font-family: monospace;
            font-size: 12px;
        }
        
        .view-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            padding: 10px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            display: none;
            border: 1px solid #4a9eff;
            max-width: 300px;
        }
        
        .object-info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 6px;
            display: none;
            max-width: 350px;
        }
        
        .grid-toggle {
            margin: 10px 0;
        }
        
        .degrees-of-freedom {
            margin-top: 10px;
            padding: 10px;
            background: #2a2a2a;
            border-radius: 4px;
        }
        
        .dof-item {
            margin: 5px 0;
            font-size: 12px;
        }
        
        /* Scrollbar styling */
        .controls::-webkit-scrollbar,
        .info::-webkit-scrollbar {
            width: 8px;
        }
        
        .controls::-webkit-scrollbar-track,
        .info::-webkit-scrollbar-track {
            background: #1a1a1a;
        }
        
        .controls::-webkit-scrollbar-thumb,
        .info::-webkit-scrollbar-thumb {
            background: #4a9eff;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div class="controls">
        <h3>Theory Selection</h3>
        <div class="theory-selector">
            <select id="theorySelect">
                <option value="">Select Theory...</option>
            </select>
        </div>
        
        <h3 style="margin-top: 20px;">Compare Trajectories</h3>
        <div class="theory-selector">
            <select id="overlaySelect">
                <option value="">No Overlay...</option>
            </select>
        </div>
        
        <h3 style="margin-top: 20px;">View Controls</h3>
        <button class="button" onclick="setView('third')">Third Person</button>
        <button class="button" onclick="setView('top')">Top View</button>
        <button class="button" onclick="resetCamera()">Reset View</button>
        
        <div class="grid-toggle">
            <label>
                <input type="checkbox" id="gridToggle" checked onchange="toggleSpacetimeGrid()">
                Show Spacetime Grid
            </label>
        </div>
        
        <h3 style="margin-top: 20px;">Animation</h3>
        <button class="button" id="playPauseBtn" onclick="toggleAnimation()">Pause</button>
        <button class="button" onclick="resetAnimation()">Reset</button>
        
        <div class="slider-container">
            <label>Speed: <span id="speedValue">1.0</span>x</label>
            <input type="range" class="slider" id="speedSlider" min="0.1" max="5" step="0.1" value="1">
        </div>
        
        <div class="slider-container">
            <label>Time: <span id="timeValue">0</span>%</label>
            <input type="range" class="slider" id="timeSlider" min="0" max="100" step="0.1" value="0">
        </div>
        
        <h3 style="margin-top: 20px;">Particles</h3>
        <div id="particleControls"></div>
    </div>
    
    <div class="info">
        <h3 id="theoryNameDisplay">No Theory Selected</h3>
        <p>Black Hole Mass: <span id="blackHoleMass">99450000000000.0</span> kg</p>
        <p>Schwarzschild Radius: <span id="schwarzschildRadius"></span> M</p>
        
        <div class="spacetime-info">
            <h4>Spacetime at Camera</h4>
            <p>Distance from BH: <span id="cameraDistance">-</span> M</p>
            <p>Proper Time Factor: <span id="properTimeFactor">-</span></p>
            <p>Spatial Curvature: <span id="spatialCurvature">-</span></p>
            <p id="spacetimeDescription">Move camera to see spacetime effects</p>
        </div>
        
        <h3 style="margin-top: 15px;">Legend</h3>
        <div id="legend"></div>
        
        <div style="margin-top: 15px; padding: 10px; background: #1a1a1a; border-radius: 6px;">
            <h4 style="margin: 0 0 10px 0; color: #4a9eff;">Spacetime Grid Visualization</h4>
            <p style="font-size: 12px; margin: 5px 0;">
                <strong>Green Grid:</strong> Flamm's paraboloid - the proper embedding of Schwarzschild spacetime<br>
                <strong>Curvature Formula:</strong> z = 2√(2M(r-2M)) where M = GM/c²<br>
                <strong>Grid Density:</strong> Logarithmic spacing - denser near black hole for detail<br>
                <strong>Funnel Shape:</strong> Shows how space is curved into the black hole<br>
                <strong>Key Radii:</strong> Red = Event Horizon (2M), Orange = Photon Sphere (3M), Yellow = ISCO (6M)<br>
                <strong>Note:</strong> This is a 2D spatial slice embedded in 3D to visualize curvature
            </p>
        </div>
        
        <div id="particleTensorInfo" class="tensor-info" style="display: none;">
            <h4>Particle State</h4>
            <div id="tensorContent"></div>
            <div class="degrees-of-freedom">
                <h5>Degrees of Freedom</h5>
                <div id="dofContent"></div>
            </div>
        </div>
    </div>
    
            <div class="view-info" id="viewInfo">
            Top View - Looking down at orbital plane
        </div>
    
    <div class="tooltip" id="tooltip"></div>
    
    <div class="object-info" id="objectInfo"></div>

    <script>
        // Run data containing all theories
        const runData = {"Schwarzschild": {"name": "Schwarzschild", "category": "baseline", "particles": {"electron": {"positions": [[100.55304172951233, 0.0], [100.55304172951139, -0.0037796447300923086], [100.5530417295102, -0.007559289460184698], [100.5530417295087, -0.011338934190277188], [100.55304172950693, -0.0151185789203698], [100.55304172950542, -0.018898223650462537], [100.55304172950416, -0.022677868380555376], [100.55304172950262, -0.0264575131106483], [100.55304172950083, -0.030237157840741373], [100.55304172949927, -0.03401680257083457], [100.55304172949796, -0.03779644730092788], [100.55304172949691, -0.04157609203102127], [100.5530417294956, -0.045355736761114734], [100.55304172949346, -0.049135381491208344], [100.55304172949106, -0.052915026221302126], [100.55304172948888, -0.05669467095139608], [100.553041729487, -0.06047431568149019], [100.55304172948536, -0.06425396041158443], [100.55304172948291, -0.06803360514167883], [100.5530417294807, -0.0718132498717734], [100.55304172947875, -0.07559289460186812], [100.55304172947707, -0.07937253933196298], [100.55304172947562, -0.08315218406205796], [100.55304172947444, -0.08693182879215304], [100.5530417294735, -0.0907114735222482], [100.55304172947282, -0.09449111825234342], [100.55304172947241, -0.09827076298243868], [100.55304172947116, -0.102050407712534], [100.55304172946965, -0.10583005244262943], [100.55304172946786, -0.10960969717272498], [100.55304172946633, -0.11338934190282066], [100.55304172946398, -0.11716898663291647], [100.55304172946191, -0.12094863136301245], [100.55304172945952, -0.12472827609310859], [100.55304172945688, -0.12850792082320492], [100.55304172945395, -0.13228756555330148], [100.55304172945074, -0.13606721028339827], [100.5530417294478, -0.13984685501349528], [100.55304172944508, -0.1436264997435925], [100.55304172944264, -0.14740614447368994], [100.55304172944045, -0.15118578920378753], [100.5530417294385, -0.1549654339338853], [100.5530417294368, -0.15874507866398319], [100.55304172943535, -0.1625247233940812], [100.55304172943417, -0.16630436812417929], [100.55304172943323, -0.17008401285427746], [100.55304172943255, -0.17386365758437572], [100.55304172943212, -0.177643302314474], [100.55304172943194, -0.18142294704457232], [100.55304172943096, -0.18520259177467066], [100.55304172943022, -0.18898223650476909], [100.55304172942974, -0.19276188123486754], [100.5530417294295, -0.19654152596496602], [100.55304172942951, -0.20032117069506453], [100.5530417294298, -0.204100815425163], [100.55304172942978, -0.2078804601552615], [100.5530417294295, -0.21166010488535997], [100.55304172942945, -0.21543974961545848], [100.55304172942967, -0.21921939434555698], [100.55304172943012, -0.22299903907565546], [100.55304172943084, -0.2267786838057539], [100.55304172943126, -0.23055832853585226], [100.55304172943144, -0.23433797326595063], [100.55304172943184, -0.23811761799604897], [100.55304172943251, -0.24189726272614726], [100.5530417294334, -0.24567690745624549], [100.55304172943404, -0.24945655218634366], [100.5530417294344, -0.2532361969164418], [100.55304172943445, -0.2570158416465399], [100.55304172943426, -0.260795486376638], [100.5530417294343, -0.26457513110673614], [100.55304172943407, -0.26835477583683426], [100.55304172943356, -0.27213442056693243], [100.55304172943222, -0.27591406529703066], [100.55304172943116, -0.279693710027129], [100.55304172943035, -0.2834733547572274], [100.55304172942978, -0.28725299948732586], [100.55304172942945, -0.29103264421742436], [100.55304172942938, -0.29481228894752287], [100.55304172942955, -0.2985919336776214], [100.55304172942947, -0.3023715784077199], [100.5530417294291, -0.3061512231378184], [100.55304172942792, -0.30993086786791696], [100.55304172942698, -0.31371051259801563], [100.5530417294263, -0.31749015732811436], [100.55304172942589, -0.3212698020582131], [100.5530417294257, -0.3250494467883119], [100.55304172942472, -0.3288290915184107], [100.55304172942398, -0.3326087362485096], [100.55304172942297, -0.33638838097860857], [100.55304172942166, -0.34016802570870763], [100.55304172942061, -0.34394767043880675], [100.55304172941875, -0.347727315168906], [100.55304172941713, -0.3515069598990054], [100.55304172941578, -0.3552866046291049], [100.55304172941469, -0.35906624935920445], [100.55304172941383, -0.3628458940893041], [100.5530417294127, -0.36662553881940385], [100.55304172941129, -0.3704051835495037], [100.55304172941013, -0.3741848282796036]], "velocities": [], "times": [0.0, 2.9607013032839673e-22, 5.921402606567943e-22, 8.882103909851927e-22, 1.1842805213135924e-21, 1.4803506516419933e-21, 1.7764207819703956e-21, 2.0724909122987983e-21, 2.3685610426272024e-21, 2.664631172955608e-21, 2.960701303284014e-21, 3.2567714336124217e-21, 3.55284156394083e-21, 3.848911694269239e-21, 4.14498182459765e-21, 4.441051954926063e-21, 4.737122085254477e-21, 5.033192215582893e-21, 5.3292623459113095e-21, 5.625332476239728e-21, 5.921402606568149e-21, 6.2174727368965705e-21, 6.513542867224994e-21, 6.809612997553419e-21, 7.105683127881843e-21, 7.401753258210268e-21, 7.697823388538694e-21, 7.99389351886712e-21, 8.289963649195548e-21, 8.586033779523977e-21, 8.882103909852407e-21, 9.178174040180837e-21, 9.47424417050927e-21, 9.770314300837705e-21, 1.006638443116614e-20, 1.0362454561494577e-20, 1.0658524691823018e-20, 1.095459482215146e-20, 1.1250664952479904e-20, 1.154673508280835e-20, 1.1842805213136798e-20, 1.213887534346525e-20, 1.24349454737937e-20, 1.2731015604122153e-20, 1.3027085734450606e-20, 1.3323155864779062e-20, 1.3619225995107518e-20, 1.391529612543597e-20, 1.4211366255764426e-20, 1.4507436386092882e-20, 1.480350651642134e-20, 1.5099576646749796e-20, 1.5395646777078255e-20, 1.569171690740671e-20, 1.598778703773517e-20, 1.6283857168063625e-20, 1.6579927298392084e-20, 1.687599742872054e-20, 1.7172067559048998e-20, 1.7468137689377457e-20, 1.7764207819705912e-20, 1.8060277950034368e-20, 1.8356348080362824e-20, 1.865241821069128e-20, 1.8948488341019732e-20, 1.9244558471348188e-20, 1.954062860167664e-20, 1.9836698732005096e-20, 2.0132768862333552e-20, 2.0428838992662008e-20, 2.0724909122990463e-20, 2.1020979253318916e-20, 2.1317049383647372e-20, 2.1613119513975827e-20, 2.1909189644304283e-20, 2.220525977463274e-20, 2.2501329904961194e-20, 2.2797400035289647e-20, 2.309347016561811e-20, 2.3389540295946565e-20, 2.3685610426275023e-20, 2.3981680556603482e-20, 2.427775068693194e-20, 2.4573820817260402e-20, 2.486989094758886e-20, 2.516596107791732e-20, 2.546203120824578e-20, 2.575810133857424e-20, 2.60541714689027e-20, 2.6350241599231158e-20, 2.6646311729559622e-20, 2.6942381859888087e-20, 2.723845199021655e-20, 2.7534522120545013e-20, 2.783059225087348e-20, 2.812666238120195e-20, 2.8422732511530417e-20, 2.871880264185889e-20, 2.901487277218736e-20, 2.931094290251583e-20], "losses": []}, "neutrino": {"positions": [[100.55304172951233, 0.0], [99.64329325524027, 0.004786736902905839], [98.73516598875838, 0.009661605883858011], [97.82869842270925, 0.014626897785001904], [96.92393016697012, 0.019684977517251255], [96.02090198425468, 0.024838286801996765], [95.11965582677506, 0.030089347020023853], [94.22023487397864, 0.03544076217151265], [93.32268357136995, 0.0408952219510658], [92.42704767042679, 0.04645550494177363], [91.53337426961538, 0.05212448193238], [90.64171185650629, 0.0579051193616532], [89.75211035098836, 0.06380048289409387], [88.86462114957317, 0.06981374113112168], [87.9792971707772, 0.07594816946187379], [87.09619290156232, 0.08220715405771652], [86.21536444480853, 0.08859419601451497], [86.80219022535813, 0.09502518678473675], [87.68454185162757, 0.10132648224840426], [88.56913171522959, 0.10750206685005599], [89.4559047956369, 0.11355536461938306], [90.34480765648601, 0.11948968743906353], [91.23578839878927, 0.1253082390881039], [92.12879661519727, 0.1310141191401108], [93.02378334533329, 0.13661032672057852], [93.92070103221451, 0.14209976412731729], [94.81950347976952, 0.14748524031816362], [95.72014581145598, 0.15276947427010992], [96.62258442997835, 0.15795509821396844], [97.52677697810195, 0.16304466074864837], [98.43268230055534, 0.16804062983907447], [99.34026040701133, 0.17294539570171547], [100.2494724361332, 0.17776127358161997], [101.16028062067188, 0.18249050642478112], [102.07264825359665, 0.1871352674495662], [102.98653965524159, 0.19169766262086005], [103.90192014144803, 0.19617973303047778], [104.8187559926828, 0.20058345718730736], [105.73701442411014, 0.20491075322054442], [106.65666355659644, 0.20916348099928375], [107.57767238862418, 0.21334344417163145], [108.50001076909335, 0.21745239212640244], [109.42364937098633, 0.22149202188036873], [110.34855966587422, 0.2254639798939248], [111.2747138992405, 0.22936986381793928], [112.20208506659989, 0.2332112241744657], [113.13064689038912, 0.23698956597389054], [114.06037379760704, 0.2407063502710045], [114.99124089818201, 0.24436299566239145], [115.9232239640442, 0.24796087972744169], [116.85629940888158, 0.2515013404152096], [117.79044426855796, 0.25498567737925176], [118.72563618217247, 0.2584151532624996], [119.66185337374029, 0.2617909949341426], [120.59907463447418, 0.2651143946804203], [121.53727930564797, 0.2683865113511471], [122.47644726202276, 0.27160847146372297], [123.41655889581713, 0.27478137026631283], [124.35759510120405, 0.2779062727618106], [125.2995372593163, 0.2809842146941397], [126.24236722374381, 0.2840162034983789], [127.18606730650654, 0.287003219216143], [128.1306202644864, 0.28994621537758924], [129.07600928630313, 0.29284611985136577], [130.0222179796192, 0.295703835663764], [130.96923035885843, 0.29852024178828646], [131.91703083332533, 0.30129619390679035], [132.86560419571026, 0.30403252514332263], [133.8149356109684, 0.30673004677171345], [134.76501060555879, 0.3093895488979537], [135.7158150570315, 0.31201180111833926], [136.6673351839513, 0.31459755315432375], [137.61955753614535, 0.317147535464985], [138.57246898526486, 0.3196624598379704], [139.52605671564922, 0.3221430199597541], [140.48030821548238, 0.32458989196600124], [141.43521126823146, 0.32700373497280627], [142.39075394435795, 0.32938519158953633], [143.34692459329221, 0.3317348884139845], [144.3037118356617, 0.3340534365105069], [145.2611045557652, 0.3363414318717906], [146.21909189428357, 0.3385994558648736], [147.17766324121973, 0.3408280756620117], [148.13680822905957, 0.3430278446569636], [149.0965167261465, 0.3451993028672432], [150.056778830262, 0.3473429773228633], [151.01758486240598, 0.3494593824420767], [151.97892536076884, 0.35154902039459873], [152.94079107489, 0.3536123814527754], [153.90317295999606, 0.3556499443311435], [154.86606217151217, 0.3576621765148112], [155.82945005974142, 0.3596495345770699], [156.7933281647061, 0.3616124644866316], [157.7576882111459, 0.3635514019048715], [158.7225221036668, 0.36546677247343895], [159.68782192203705, 0.3673589920925867], [160.6535799166241, 0.3692284671905537], [161.61978850396824, 0.37107559498432385], [162.58644026248865, 0.37290076373207093], [163.55352792831684, 0.37470435297758625]], "velocities": [], "times": [0.0, 3.099904993654045e-22, 6.206968737067595e-22, 9.321344342013378e-22, 1.2443189522645536e-21, 1.5572666768406408e-21, 1.8709943524502317e-21, 2.1855192380313983e-21, 2.500859126612539e-21, 2.8170323658574465e-21, 3.134057879524875e-21, 3.451955189887082e-21, 3.770744441153984e-21, 4.0904464239519035e-21, 4.411082600908297e-21, 4.732675133396344e-21, 5.055246909495933e-21, 5.378153412523451e-21, 5.700069931905398e-21, 6.021022545005815e-21, 6.3410336523775735e-21, 6.660124946641184e-21, 6.978317439628632e-21, 7.295631488348782e-21, 7.612086819829133e-21, 7.927702554886103e-21, 8.24249723087364e-21, 8.55648882345755e-21, 8.869694767460727e-21, 9.182131976822329e-21, 9.493816863711868e-21, 9.804765356837252e-21, 1.0114992918983923e-20, 1.0424514563820491e-20, 1.073334487200451e-20, 1.1041498006620481e-20, 1.1348987727980592e-20, 1.1655827407817215e-20, 1.1962030042894848e-20, 1.2267608268067777e-20, 1.2572574368808536e-20, 1.2876940293230986e-20, 1.318071766363071e-20, 1.3483917787564356e-20, 1.3786551668488442e-20, 1.4088630015977266e-20, 1.439016325553851e-20, 1.469116153804435e-20, 1.4991634748794905e-20, 1.5291592516230225e-20, 1.559104422030604e-20, 1.588999900054799e-20, 1.618846576379819e-20, 1.6486453191667412e-20, 1.6783969747705535e-20, 1.7081023684302284e-20, 1.7377623049329773e-20, 1.767377569253779e-20, 1.7969489271712264e-20, 1.8264771258606827e-20, 1.8559628944657065e-20, 1.885406944648643e-20, 1.9148099711212463e-20, 1.944172652156165e-20, 1.973495650080067e-20, 2.0027796117491658e-20, 2.0320251690078577e-20, 2.0612329391311587e-20, 2.0904035252515968e-20, 2.1195375167711786e-20, 2.148635489759034e-20, 2.1776980073353073e-20, 2.206725620041837e-20, 2.2357188662001504e-20, 2.2646782722572683e-20, 2.2936043531197962e-20, 2.3224976124767616e-20, 2.3513585431116264e-20, 2.380187627203899e-20, 2.4089853366207428e-20, 2.4377521331989584e-20, 2.466488469017713e-20, 2.4951947866623643e-20, 2.5238715194797085e-20, 2.5525190918249847e-20, 2.5811379193009346e-20, 2.6097284089892154e-20, 2.63829095967445e-20, 2.6668259620611803e-20, 2.6953337989839915e-20, 2.723814845611049e-20, 2.752269469641288e-20, 2.7806980314954913e-20, 2.809100884501465e-20, 2.8374783750735305e-20, 2.8658308428865306e-20, 2.8941586210445525e-20, 2.9224620362445384e-20, 2.9507414089349795e-20, 2.978997053469855e-20], "losses": []}, "photon": {"positions": [[100.55304172951233, 0.0], [101.4067499562034, 0.00587937789669226], [102.26287957366289, 0.011660451757557462], [103.1213786444794, 0.01734540138885117], [103.98219653053717, 0.02293635131850424], [104.84528385964897, 0.02843537217105896], [105.71059249286364, 0.03384448202161809], [106.5780754924545, 0.03916564772767819], [107.44768709059356, 0.044400786237896304], [108.31938265871364, 0.049551765877001], [109.19311867755879, 0.054620407606205415], [110.06885270792182, 0.05960848625861308], [110.94654336206597, 0.06451773174922718], [111.8261502758263, 0.06934983025928289], [112.70763408138579, 0.07410642539471948], [113.59095638071882, 0.07878911931869698], [114.47607971969525, 0.08339947385814031], [115.36296756283598, 0.08793901158436421], [116.25158426871154, 0.09240921686789426], [117.14189506597337, 0.09681153690765491], [118.03386603000784, 0.10114738273474404], [118.92746406020215, 0.10541813019105649], [119.8226568578108, 0.10962512088305672], [120.71941290441141, 0.11376966311103301], [121.61770144093816, 0.11785303277419404], [122.51749244728074, 0.12187647425199262], [123.41875662243685, 0.12584120126208168], [124.32146536520617, 0.1297483976953247], [125.22559075541372, 0.13359921842829683], [126.13110553565001, 0.13739479011372385], [127.03798309351615, 0.14113621194931547], [127.94619744436157, 0.1448245564254555], [128.85572321450246, 0.14846087005221634], [129.76653562490853, 0.15204617406616783], [130.67861047534691, 0.15558146511745174], [131.59192412897076, 0.15906771593759303], [132.50645349734143, 0.1625058759885173], [133.42217602587266, 0.16589687209324144], [134.33906967968568, 0.16924160904870084], [135.25711292986384, 0.17254097022117165], [136.1762847400964, 0.17579581812474218], [137.09656455370026, 0.17900699498328057], [138.01793228101005, 0.18217532327634028], [138.94036828712515, 0.18530160626943756], [139.86385338000494, 0.18838662852912752], [140.78836879890136, 0.19143115642329836], [141.7138962031202, 0.1944359386070944], [142.6404176611009, 0.19740170649487135], [143.56791563980622, 0.20032917471857764], [144.49637299441306, 0.2032190415729484], [145.42577295829517, 0.20607198944788888], [146.35609913328983, 0.20888868524841595], [147.28733548024, 0.21166978080251778], [148.21946630980372, 0.2144159132572823], [149.15247627352372, 0.21712770546363708], [150.08635035514857, 0.21980576635003427], [151.0210738621988, 0.22245069128540537], [151.95663241777035, 0.22506306243170274], [152.8930119525688, 0.22764344908633544], [153.83019869716676, 0.23019240801479965], [154.76817917447903, 0.23271048377379472], [155.70694019244775, 0.23519820902510846], [156.64646883693248, 0.23765610484054744], [157.5867524647985, 0.24008468099817953], [158.52777869719745, 0.24248443627014915], [159.46953541303498, 0.2448558587023176], [160.41201074261969, 0.24719942588597377], [161.3551930614876, 0.24951560522185331], [162.2990709843978, 0.25180485417669735], [163.24363335949323, 0.25406762053257503], [164.18886926262246, 0.25630434262918733], [165.13476799181726, 0.2585154495993632], [166.0813190619216, 0.26070136159795293], [167.02851219936727, 0.2628624900243171], [167.97633733709233, 0.2649992377386036], [168.92478460959757, 0.26711199927199947], [169.8738443481372, 0.2692011610311384], [170.82350707603993, 0.27126710149683964], [171.77376350415625, 0.27331019141734775], [172.7246045264287, 0.2753307939962385], [173.6760212155807, 0.27732926507515054], [174.62800481892168, 0.27930595331149743], [175.58054675426362, 0.28126120035131025], [176.53363860594703, 0.2831953409973558], [177.48727212097256, 0.28510870337267197], [178.4414392052351, 0.2870016090796554], [179.39613191985748, 0.28887437335483535], [180.3513424776213, 0.29072730521946033], [181.3070632394911, 0.2925607076260224], [182.26328671123045, 0.2943748776008394], [183.22000554010583, 0.2961701063828113], [184.17721251167723, 0.2979466795584635], [185.13490054667167, 0.29970487719338657], [186.0930626979385, 0.3014449739601787], [187.0516921474828, 0.3031672392629927], [188.01078220357596, 0.30487193735878754], [188.97032629793992, 0.3065593274753805], [189.93031798300447, 0.30822966392639367], [190.89075092923397, 0.30988319622318444], [191.85161892252265, 0.31152016918384845]], "velocities": [], "times": [0.0, 3.0931140802881996e-22, 6.179783891609334e-22, 9.260125370062534e-22, 1.2334251790106426e-21, 1.5402273829824097e-21, 1.8464299634953933e-21, 2.1520434881662445e-21, 2.457078283804126e-21, 2.7615444424315777e-21, 3.0654518271757865e-21, 3.3688100780299263e-21, 3.671628617484616e-21, 3.973916656029889e-21, 4.2756831975283566e-21, 4.576937044460542e-21, 4.877686803043551e-21, 5.177940888224488e-21, 5.477707528550186e-21, 5.776994770914975e-21, 6.075810485188328e-21, 6.374162368724378e-21, 6.6720579507553306e-21, 6.969504596670926e-21, 7.266509512186143e-21, 7.56307974739938e-21, 7.859222200743402e-21, 8.154943622831363e-21, 8.450250620200212e-21, 8.745149658953834e-21, 9.039647068308258e-21, 9.333749044041237e-21, 9.627461651848556e-21, 9.920790830609328e-21, 1.021374239556259e-20, 1.050632204139743e-20, 1.0798535345258894e-20, 1.1090387769671832e-20, 1.1381884665384897e-20, 1.1673031274136766e-20, 1.1963832731346715e-20, 1.2254294068731563e-20, 1.2544420216851019e-20, 1.283421600758338e-20, 1.3123686176533514e-20, 1.3412835365375013e-20, 1.370166812412834e-20, 1.3990188913376775e-20, 1.4278402106421943e-20, 1.4566311991380545e-20, 1.4853922773224102e-20, 1.514123857576317e-20, 1.5428263443577758e-20, 1.5715001343895398e-20, 1.6001456168418405e-20, 1.6287631735101763e-20, 1.6573531789883095e-20, 1.6859160008366066e-20, 1.7144519997458572e-20, 1.742961529696701e-20, 1.7714449381147928e-20, 1.7999025660218265e-20, 1.8283347481825357e-20, 1.8567418132477918e-20, 1.885124083893909e-20, 1.9134818769582686e-20, 1.941815503571365e-20, 1.9701252692853802e-20, 1.9984114741993862e-20, 2.0266744130812724e-20, 2.0549143754864903e-20, 2.0831316458737107e-20, 2.1113265037174808e-20, 2.139499223617965e-20, 2.1676500754078562e-20, 2.195779324256538e-20, 2.2238872307715743e-20, 2.2519740510976068e-20, 2.2800400370127275e-20, 2.3080854360224072e-20, 2.3361104914510403e-20, 2.3641154425311795e-20, 2.3921005244905245e-20, 2.420065968636726e-20, 2.4480120024400694e-20, 2.4759388496140958e-20, 2.503846730194219e-20, 2.5317358606143967e-20, 2.5596064537819027e-20, 2.5874587191502657e-20, 2.6152928627904142e-20, 2.6431090874600806e-20, 2.6709075926715178e-20, 2.6986885747575665e-20, 2.7264522269361265e-20, 2.75419873937307e-20, 2.7819282992436435e-20, 2.8096410907923944e-20, 2.837337295391672e-20, 2.86501709159873e-20], "losses": []}, "proton": {"positions": [[100.55304172951233, 0.0], [100.55323846365202, -0.002948835276794304], [100.55382866521775, -0.005897647475945542], [100.55481233164362, -0.008846413520723654], [100.55618945865227, -0.011795110336224608], [100.55796004025578, -0.014743714850283219], [100.56012406875732, -0.01769220399438571], [100.56268153474979, -0.02064055470458181], [100.56563242711543, -0.02358874392239664], [100.56897673302709, -0.02653674859574199], [100.5727144379468, -0.029484545679827043], [100.57684552562864, -0.03243211213806848], [100.58136997811872, -0.035379424942999685], [100.5862877757547, -0.038326461077179186], [100.59159889716699, -0.04127319753409818], [100.59730331927906, -0.04421961131908708], [100.60340101730657, -0.04716567945022098], [100.60989196476056, -0.05011137895922392], [100.61677613344672, -0.05305668689237191], [100.62405349346676, -0.05600158031139458], [100.63172401321756, -0.05894603629437551], [100.63978765939429, -0.061890031936651026], [100.64824439699024, -0.06483354435170732], [100.6570941892963, -0.06777655067207612], [100.66633699790297, -0.07071902805022844], [100.67597278270257, -0.07366095365946661], [100.68600150188921, -0.07660230469481433], [100.69642311196, -0.07954305837390475], [100.70723756771453, -0.08248319193786662], [100.71844482225734, -0.08542268265220812], [100.73004482700031, -0.08836150780769869], [100.74203753166388, -0.09129964472124825], [100.75442288427652, -0.09423707073678426], [100.76720083117652, -0.09717376322612627], [100.78037131701296, -0.10010969958985805], [100.79393428474896, -0.10304485725819693], [100.8078896756609, -0.10597921369186059], [100.82223742934181, -0.10891274638293104], [100.83697748370061, -0.11184543285571577], [100.85210977496573, -0.11477725066760597], [100.86763423768582, -0.11770817740993184], [100.88355080473285, -0.12063819070881465], [100.89985940730156, -0.12356726822601587], [100.91655997491227, -0.12649538765978297], [100.93365243541174, -0.12942252674569207], [100.95113671497646, -0.1323486632574871], [100.96901273811243, -0.13527377500791557], [100.9872804276612, -0.1381978398495609], [101.00593970479747, -0.14112083567567107], [101.02499048903249, -0.1440427404209837], [101.04443269821623, -0.1469635320625474], [101.06426624853974, -0.14988318862053948], [101.08449105453633, -0.15280168815907963], [101.10510702908428, -0.1557190087870397], [101.12611408340915, -0.15863512865884974], [101.1475121270855, -0.16155002597529955], [101.16930106803916, -0.16446367898433664], [101.19148081254973, -0.16737606598185964], [101.21405126525507, -0.17028716531250754], [101.23701232914884, -0.17319695537044463], [101.26036390558679, -0.17610541460014123], [101.284105894288, -0.17901252149714975], [101.30823819333607, -0.1819182546088765], [101.33276069918492, -0.18482259253534872], [101.35767330665844, -0.187725513929977], [101.38297590895267, -0.1906269975003133], [101.40866839763967, -0.19352702200880406], [101.43475066267182, -0.19642556627353835], [101.46122259238138, -0.19932260916899147], [101.48808407348467, -0.20221812962676344], [101.51533499108551, -0.2051121066363126], [101.54297522867725, -0.20800451924568422], [101.57100466814603, -0.2108953465622339], [101.59942318977161, -0.21378456775334606], [101.62823067223283, -0.2166721620471471], [101.65742699261017, -0.2195581087332134], [101.68701202638789, -0.2224423871632739], [101.71698564745724, -0.2253249767519076], [101.74734772811918, -0.22820585697723533], [101.77809813908866, -0.23108500738160653], [101.80923674949611, -0.23396240757228012], [101.84076342689109, -0.23683803722210015], [101.87267803724622, -0.23971187607016567], [101.90498044495956, -0.24258390392249518], [101.93767051285873, -0.24545410065268525], [101.97074810220317, -0.2483224462025634], [102.00421307268688, -0.25118892058283554], [102.03806528244397, -0.2540535038737271], [102.07230458805175, -0.25691617622561896], [102.10693084453096, -0.25977691785967677], [102.14194390535238, -0.26263570906847505], [102.1773436224399, -0.265492530216615], [102.2131298461732, -0.2683473617413361], [102.24930242539155, -0.2712001841531222], [102.28586120739787, -0.27405097803630113], [102.3228060379608, -0.27689972404963836], [102.3601367613188, -0.2797464029269246], [102.39785322018565, -0.282590995477557], [102.43595525575088, -0.2854334825871146], [102.47444270768685, -0.28827384521792687]], "velocities": [], "times": [0.0, 2.887384607192841e-22, 5.774766389793647e-22, 8.66214252330555e-22, 1.1549510183422027e-21, 1.4436866546122048e-21, 1.7324208787765197e-21, 2.021153408518677e-21, 2.309883961579281e-21, 2.598612255765513e-21, 2.887338008960625e-21, 3.1760609391334282e-21, 3.464780764347774e-21, 3.753497202772025e-21, 4.042209972688519e-21, 4.330918792503023e-21, 4.619623380754174e-21, 4.908323456122916e-21, 5.1970187374419145e-21, 5.485708943704964e-21, 5.774393794076381e-21, 6.063073007900382e-21, 6.3517463047104455e-21, 6.64041340423866e-21, 6.92907402642505e-21, 7.21772789142689e-21, 7.506374719628001e-21, 7.795014231648013e-21, 8.08364614835163e-21, 8.372270190857858e-21, 8.660886080549215e-21, 8.949493539080918e-21, 9.238092288390055e-21, 9.526682050704715e-21, 9.815262548553113e-21, 1.0103833504772679e-20, 1.039239464251912e-20, 1.068094568527546e-20, 1.0969486356861049e-20, 1.1258016381440545e-20, 1.1546535483532865e-20, 1.1835043388020109e-20, 1.2123539820156447e-20, 1.2412024505576984e-20, 1.2700497170306584e-20, 1.2988957540768671e-20, 1.3277405343793985e-20, 1.356584030662931e-20, 1.3854262156946174e-20, 1.4142670622849487e-20, 1.4431065432886192e-20, 1.471944631605381e-20, 1.5007813001809022e-20, 1.529616522007616e-20, 1.5584502701255672e-20, 1.587282517623256e-20, 1.6161132376384765e-20, 1.6449424033591518e-20, 1.673769988024164e-20, 1.7025959649241813e-20, 1.7314203074024798e-20, 1.7602429888557613e-20, 1.7890639827349668e-20, 1.8178832625460858e-20, 1.8467008018509604e-20, 1.8755165742680844e-20, 1.9043305534734007e-20, 1.9331427132010893e-20, 1.9619530272443547e-20, 1.9907614694562064e-20, 2.0195680137502348e-20, 2.048372634101383e-20, 2.0771753045467118e-20, 2.1059759991861628e-20, 2.134774692183313e-20, 2.1635713577661266e-20, 2.1923659702276998e-20, 2.221158503927003e-20, 2.2499489332896144e-20, 2.2787372328084518e-20, 2.3075233770444953e-20, 2.3363073406275083e-20, 2.3650890982567505e-20, 2.3938686247016855e-20, 2.4226458948026842e-20, 2.4514208834717223e-20, 2.480193565693071e-20, 2.5089639165239826e-20, 2.537731911095372e-20, 2.566497524612489e-20, 2.5952607323555877e-20, 2.6240215096805892e-20, 2.6527798320197394e-20, 2.681535674882257e-20, 2.7102890138549812e-20, 2.739039824603009e-20, 2.7677880828703287e-20, 2.7965337644804463e-20, 2.8252768453370073e-20, 2.854017301424409e-20], "losses": []}}}};
        const blackHoleMass = 99450000000000.0;
        
        // Constants
        const G = 6.67430e-11;
        const c = 299792458;
        const M_physical = G * blackHoleMass / (c * c); // Geometric units in meters
        const M = 1.0; // Use normalized units for visualization
        
        // Three.js setup
        let scene, camera, renderer, controls;
        let blackHole, particles = {};
        let trajectoryLines = {};
        let currentPositions = {};
        let animationTime = 0;
        let isPlaying = true;
        let animationSpeed = 1.0;
        let currentView = 'third';
        let primaryParticle = 'electron';
        let mountedParticle = null;
        let currentTheory = null;
        let overlayTheory = null;
        let overlayTrajectories = {};
        let overlayParticles = {};
        let spacetimeGrid = null;
        let raycaster, mouse;
        let hoveredObject = null;
        let selectedObject = null;
        
        // Particle colors
        const particleColors = {
            electron: 0x3498db,
            neutrino: 0xe74c3c,
            photon: 0xf39c12,
            proton: 0x2ecc71
        };
        
        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000814);
            
            // Camera setup
            camera = new THREE.PerspectiveCamera(
                75, 
                window.innerWidth / window.innerHeight,
                0.1,
                5000  // Increased far plane to prevent clipping
            );
            
            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // Controls - always orbit around the black hole
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 5;
            controls.maxDistance = 1000;  // Increased max distance
            controls.target.set(0, 0, 0); // Always focus on black hole
            controls.enablePan = false; // Disable panning to keep focus on black hole
            
            // Raycaster for mouse interactions
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(50, 50, 50);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Add point light for better black hole visibility
            const pointLight = new THREE.PointLight(0xffffff, 1, 100);
            pointLight.position.set(10, 10, 10);
            scene.add(pointLight);
            
            // Create black hole
            createBlackHole();
            
            // Create spacetime grid
            createSpacetimeGrid();
            
            // Add observer reference frame indicator
            const observerGeometry = new THREE.ConeGeometry(2, 5, 4);
            const observerMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff00,
                transparent: true,
                opacity: 0.5
            });
            const observerIndicator = new THREE.Mesh(observerGeometry, observerMaterial);
            observerIndicator.name = 'observerIndicator';
            scene.add(observerIndicator);
            
            // Add axes helper for orientation at proper scale
            const axesHelper = new THREE.AxesHelper(50);
            scene.add(axesHelper);
            
            // Setup UI
            populateTheorySelector();
            
            // Event listeners
            window.addEventListener('resize', onWindowResize);
            document.getElementById('speedSlider').addEventListener('input', updateSpeed);
            document.getElementById('timeSlider').addEventListener('input', updateTimeFromSlider);
            document.getElementById('theorySelect').addEventListener('change', onTheoryChange);
            document.getElementById('overlaySelect').addEventListener('change', onOverlayChange);
            
            // Mouse events
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('click', onMouseClick);
            
            // Update Schwarzschild radius display
            document.getElementById('schwarzschildRadius').textContent = (2 * M).toFixed(3) + ' (scaled)';
            
            // Set initial camera position to top-down view
            setView('top');
            
            // Load Kerr-Newman as default if available, otherwise first theory
            const kerrNewmanOption = document.getElementById('theorySelect').querySelector('option[value="Kerr-Newman"]');
            const firstTheory = document.getElementById('theorySelect').querySelector('option:not([value=""])');
            const defaultTheory = kerrNewmanOption || firstTheory;
            
            if (defaultTheory) {
                document.getElementById('theorySelect').value = defaultTheory.value;
                loadTheory(defaultTheory.value);
            }
            
            // Start animation
            animate();
        }
        
        function createBlackHole() {
            // Create realistic black hole with event horizon
            // Scale up for visibility
            const bhRadius = 2 * M; // Event horizon at 2M
            const geometry = new THREE.SphereGeometry(bhRadius, 64, 64);
            const material = new THREE.MeshPhysicalMaterial({
                color: 0x000000,
                metalness: 1,
                roughness: 0,
                opacity: 0.95,
                transparent: true
            });
            
            blackHole = new THREE.Mesh(geometry, material);
            blackHole.name = 'Black Hole';
            blackHole.userData = {
                type: 'blackhole',
                mass: blackHoleMass,
                schwarzschildRadius: 2 * M
            };
            blackHole.position.set(0, 0, 0);
            scene.add(blackHole);
            
            // Add glow effect around black hole
            const glowGeometry = new THREE.SphereGeometry(bhRadius * 1.2, 32, 32);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0xff4400,
                transparent: true,
                opacity: 0.1,
                side: THREE.BackSide
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            blackHole.add(glow);
            
            // Add thin accretion disk hint
            const diskGeometry = new THREE.RingGeometry(2.5 * M, 4 * M, 64);
            const diskMaterial = new THREE.MeshBasicMaterial({
                color: 0xff6600,
                side: THREE.DoubleSide,
                opacity: 0.3,
                transparent: true
            });
            const disk = new THREE.Mesh(diskGeometry, diskMaterial);
            disk.rotation.x = Math.PI / 2;
            disk.name = 'Accretion Disk';
            blackHole.add(disk);
            
            // Add photon sphere indicator
            const photonSphereGeometry = new THREE.RingGeometry(3 * M - 0.05, 3 * M + 0.05, 64);
            const photonSphereMaterial = new THREE.MeshBasicMaterial({
                color: 0xffff00,
                side: THREE.DoubleSide,
                opacity: 0.3,
                transparent: true
            });
            const photonSphere = new THREE.Mesh(photonSphereGeometry, photonSphereMaterial);
            photonSphere.rotation.x = Math.PI / 2;
            photonSphere.name = 'Photon Sphere';
            blackHole.add(photonSphere);
        }
        
        function createSpacetimeGrid() {
            // Create spacetime grid showing Schwarzschild metric curvature
            spacetimeGrid = new THREE.Group();
            spacetimeGrid.name = 'Spacetime Grid';
            
            // Grid parameters - denser near black hole for better curvature visualization
            const innerRadius = 2.5;  // Just outside event horizon
            const outerRadius = 150;
            const radialLines = 24;   // Number of radial lines
            const circularLines = 40; // Number of circular lines
            
            // Create radial lines (like spokes of a wheel)
            for (let i = 0; i < radialLines; i++) {
                const angle = (i / radialLines) * Math.PI * 2;
                const points = [];
                
                // Sample more densely near the black hole
                for (let r = innerRadius; r <= outerRadius; r *= 1.08) {
                    // Calculate embedding height using Flamm's paraboloid
                    // z = 2*sqrt(2M(r-2M)) for the Schwarzschild metric
                    const height = r > 2 ? -2 * Math.sqrt(2 * M * (r - 2 * M)) : 0;
                    
                    points.push(new THREE.Vector3(
                        r * Math.cos(angle),
                        height * 2,  // Scale up for visibility
                        r * Math.sin(angle)
                    ));
                }
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.6
                });
                const line = new THREE.Line(geometry, material);
                spacetimeGrid.add(line);
            }
            
            // Create circular lines (concentric circles at different radii)
            for (let i = 0; i < circularLines; i++) {
                // Logarithmic spacing for circles - denser near black hole
                const t = i / (circularLines - 1);
                const r = innerRadius * Math.pow(outerRadius / innerRadius, t);
                
                const points = [];
                const segments = 64;
                
                // Calculate embedding height for this radius
                const height = r > 2 ? -2 * Math.sqrt(2 * M * (r - 2 * M)) : 0;
                
                for (let j = 0; j <= segments; j++) {
                    const angle = (j / segments) * Math.PI * 2;
                    points.push(new THREE.Vector3(
                        r * Math.cos(angle),
                        height * 2,  // Scale up for visibility
                        r * Math.sin(angle)
                    ));
                }
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.6
                });
                const line = new THREE.Line(geometry, material);
                spacetimeGrid.add(line);
            }
            
            // Add special radius indicators with strong colors
            const keyRadii = [
                { r: 2, name: 'Event Horizon', color: 0xff0000, linewidth: 3 },
                { r: 3, name: 'Photon Sphere', color: 0xffaa00, linewidth: 2 },
                { r: 6, name: 'ISCO', color: 0xffff00, linewidth: 2 }
            ];
            
            keyRadii.forEach(({r, name, color, linewidth}) => {
                const points = [];
                const segments = 128;
                const height = r > 2 ? -2 * Math.sqrt(2 * M * (r - 2 * M)) : 0;
                
                for (let i = 0; i <= segments; i++) {
                    const angle = (i / segments) * Math.PI * 2;
                    points.push(new THREE.Vector3(
                        r * Math.cos(angle),
                        height * 2,
                        r * Math.sin(angle)
                    ));
                }
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({
                    color: color,
                    opacity: 1.0,
                    transparent: false,
                    linewidth: linewidth
                });
                const circle = new THREE.Line(geometry, material);
                circle.name = name;
                spacetimeGrid.add(circle);
            });
            
            // Add coordinate labels
            const labelPositions = [10, 20, 50, 100];
            labelPositions.forEach(r => {
                // Create label showing radius
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 128;
                canvas.height = 64;
                context.fillStyle = 'white';
                context.font = '32px Arial';
                context.fillText(`${r}M`, 10, 40);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ 
                    map: texture, 
                    opacity: 0.8,
                    color: 0x00ff00
                });
                const sprite = new THREE.Sprite(spriteMaterial);
                
                // Position label on the grid at angle 0
                const height = r > 2 ? -2 * Math.sqrt(2 * M * (r - 2 * M)) : 0;
                sprite.position.set(r, height * 2 + 5, 0);
                sprite.scale.set(5, 2.5, 1);
                spacetimeGrid.add(sprite);
                
                // Also add label at 90 degrees
                const sprite2 = sprite.clone();
                sprite2.position.set(0, height * 2 + 5, r);
                spacetimeGrid.add(sprite2);
            });
            
            scene.add(spacetimeGrid);
            
            // The grid is now static - shows the intrinsic curvature of spacetime
            // No observer-dependent effects
        }
        
        function updateSpacetimeGrid() {
            // Since the grid is now static and shows intrinsic curvature,
            // we only need to update the spacetime info display
            const cameraPos = camera.position;
            const observerR = cameraPos.length();
            updateSpacetimeInfo(observerR);
        }
        
        function updateSpacetimeInfo(r) {
            const rs = 2 * M;
            const properTimeFactor = Math.sqrt(Math.max(0, 1 - rs / r));
            const spatialCurvature = rs / (2 * r * r);
            
            document.getElementById('cameraDistance').textContent = r.toFixed(2);
            document.getElementById('properTimeFactor').textContent = properTimeFactor.toFixed(4);
            document.getElementById('spatialCurvature').textContent = spatialCurvature.toExponential(2);
            
            // Update description based on distance with scientific details
            let description = '';
            const timeDilationPercent = ((1 - properTimeFactor) * 100).toFixed(1);
            const escapeVelocity = Math.sqrt(2 * rs / r);  // As fraction of c
            
            if (r < 3 * M) {
                description = `DANGER: Near photon sphere (r = 3M)! Time dilation: ${timeDilationPercent}%. ` +
                    `Light can orbit here. Grid shows extreme curvature - Flamm's paraboloid embedding depth maximum.`;
            } else if (r < 6 * M) {
                description = `Strong field regime: Inside ISCO (r = 6M). Time dilation: ${timeDilationPercent}%. ` +
                    `No stable orbits exist. Grid curvature shows deep gravitational well. Escape velocity: ${(escapeVelocity * 100).toFixed(1)}% of c.`;
            } else if (r < 20 * M) {
                description = `Moderate field: Time dilation: ${timeDilationPercent}%. ` +
                    `Grid shows significant curvature - the funnel shape of Flamm's paraboloid is clearly visible.`;
            } else if (r < 50 * M) {
                description = `Weak-moderate field: Time dilation: ${timeDilationPercent}%. ` +
                    `Grid shows gentle spacetime curvature. Radial distances stretched by factor √(1 - rs/r) = ${(1/Math.sqrt(1-rs/r)).toFixed(3)}.`;
            } else {
                description = `Weak field: Nearly flat spacetime. Time dilation: ${timeDilationPercent}%. ` +
                    `Grid approaches Minkowski space. Curvature effects ~ rs/r = ${(rs/r).toFixed(4)}.`;
            }
            
            document.getElementById('spacetimeDescription').innerHTML = description;
        }
        
        function populateTheorySelector() {
            const select = document.getElementById('theorySelect');
            const overlaySelect = document.getElementById('overlaySelect');
            
            // Group theories by category
            const categories = {};
            for (const [theoryName, data] of Object.entries(runData)) {
                const category = data.category || 'other';
                if (!categories[category]) {
                    categories[category] = [];
                }
                categories[category].push(theoryName);
            }
            
            // Add options grouped by category to both selects
            for (const [category, theories] of Object.entries(categories)) {
                const optgroup = document.createElement('optgroup');
                optgroup.label = category.charAt(0).toUpperCase() + category.slice(1);
                
                const overlayOptgroup = document.createElement('optgroup');
                overlayOptgroup.label = category.charAt(0).toUpperCase() + category.slice(1);
                
                theories.sort().forEach(theory => {
                    const option = document.createElement('option');
                    option.value = theory;
                    option.textContent = theory;
                    optgroup.appendChild(option);
                    
                    const overlayOption = document.createElement('option');
                    overlayOption.value = theory;
                    overlayOption.textContent = theory;
                    overlayOptgroup.appendChild(overlayOption);
                });
                
                select.appendChild(optgroup);
                overlaySelect.appendChild(overlayOptgroup);
            }
        }
        
        function onTheoryChange(event) {
            const theoryName = event.target.value;
            if (!theoryName) return;
            
            loadTheory(theoryName);
        }
        
        function onOverlayChange(event) {
            const overlayName = event.target.value;
            
            // Clear existing overlay
            clearOverlay();
            
            if (!overlayName) {
                overlayTheory = null;
                return;
            }
            
            loadOverlay(overlayName);
        }
        
        function loadTheory(theoryName) {
            currentTheory = theoryName;
            const theoryData = runData[theoryName];
            
            if (!theoryData) {
                console.error('Theory data not found:', theoryName);
                return;
            }
            
            // Update display
            document.getElementById('theoryNameDisplay').textContent = theoryName;
            
            // Clear existing particles and trajectories
            clearVisualization();
            
            // Reset animation time
            animationTime = 0;
            document.getElementById('timeSlider').value = 0;
            updateTimeDisplay();
            
            // Load particle data
            const particleData = theoryData.particles || {};
            
            // Create particle controls and visualizations
            createParticleControls(particleData);
            
            // Load trajectories
            console.log('Loading trajectories for', Object.keys(particleData).length, 'particles');
            for (const [particleName, data] of Object.entries(particleData)) {
                if (data && data.positions) {
                    console.log(`Creating visualization for ${particleName} with ${data.positions.length} points`);
                    createParticleVisualization(particleName, data);
                }
            }
            
            // Auto-adjust camera to fit all trajectories
            if (Object.keys(trajectoryLines).length > 0) {
                console.log('Fitting camera to scene with', Object.keys(trajectoryLines).length, 'trajectories');
                fitCameraToScene();
            } else {
                console.log('No trajectories created!');
            }
            
            // Update legend
            updateLegend();
        }
        
        function clearVisualization() {
            // Remove existing particles and trajectories
            for (const name in particles) {
                if (particles[name]) {
                    scene.remove(particles[name]);
                    // Dispose of geometry and materials
                    if (particles[name].geometry) particles[name].geometry.dispose();
                    if (particles[name].material) particles[name].material.dispose();
                }
            }
            for (const name in trajectoryLines) {
                if (trajectoryLines[name]) {
                    scene.remove(trajectoryLines[name]);
                    if (trajectoryLines[name].geometry) trajectoryLines[name].geometry.dispose();
                    if (trajectoryLines[name].material) trajectoryLines[name].material.dispose();
                }
                
                // Also remove the tube geometry
                const tube = scene.getObjectByName(name + '_trajectory_tube');
                if (tube) {
                    scene.remove(tube);
                    if (tube.geometry) tube.geometry.dispose();
                    if (tube.material) tube.material.dispose();
                }
            }
            
            particles = {};
            trajectoryLines = {};
            currentPositions = {};
        }
        
        function clearOverlay() {
            // Remove overlay particles
            for (const name in overlayParticles) {
                if (overlayParticles[name]) {
                    scene.remove(overlayParticles[name]);
                    if (overlayParticles[name].geometry) overlayParticles[name].geometry.dispose();
                    if (overlayParticles[name].material) overlayParticles[name].material.dispose();
                }
            }
            // Remove overlay trajectories
            for (const name in overlayTrajectories) {
                if (overlayTrajectories[name]) {
                    scene.remove(overlayTrajectories[name]);
                    if (overlayTrajectories[name].geometry) overlayTrajectories[name].geometry.dispose();
                    if (overlayTrajectories[name].material) overlayTrajectories[name].material.dispose();
                }
            }
            
            overlayParticles = {};
            overlayTrajectories = {};
            overlayPositions = {};
        }
        
        function loadOverlay(theoryName) {
            overlayTheory = theoryName;
            const theoryData = runData[theoryName];
            
            if (!theoryData) {
                console.error('Overlay theory data not found:', theoryName);
                return;
            }
            
            // Load overlay particle data
            const particleData = theoryData.particles || {};
            
            // Create overlay visualizations
            for (const [particleName, data] of Object.entries(particleData)) {
                if (data && data.positions) {
                    createOverlayVisualization(particleName, data);
                }
            }
        }
        
        function createOverlayVisualization(particleName, data) {
            // Create semi-transparent particle for overlay
            const geometry = new THREE.SphereGeometry(0.8, 16, 16);
            const material = new THREE.MeshPhongMaterial({
                color: particleColors[particleName] || 0xffffff,
                emissive: particleColors[particleName] || 0xffffff,
                emissiveIntensity: 0.3,
                transparent: true,
                opacity: 0.4
            });
            
            const particle = new THREE.Mesh(geometry, material);
            particle.name = `overlay_${particleName}`;
            particle.userData = {
                type: 'overlay_particle',
                name: particleName,
                trajectory: data
            };
            
            overlayParticles[particleName] = particle;
            scene.add(particle);
            
            // Create dashed trajectory line for overlay
            if (data.positions && data.positions.length > 0) {
                const points = [];
                for (let i = 0; i < data.positions.length; i++) {
                    const pos = data.positions[i];
                    const r = pos[0];
                    const phi = pos[1];
                    
                    const x = r * Math.cos(phi);
                    const z = r * Math.sin(phi);
                    
                    // Apply Flamm's paraboloid embedding
                    const height = r > 2 ? -2 * Math.sqrt(2 * M * (r - 2 * M)) : 0;
                    const y = height * 2;
                    
                    points.push(new THREE.Vector3(x, y, z));
                }
                
                const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
                
                // Use dashed line material for overlay
                const lineMaterial = new THREE.LineDashedMaterial({
                    color: particleColors[particleName] || 0xffffff,
                    opacity: 0.6,
                    transparent: true,
                    dashSize: 3,
                    gapSize: 2,
                    linewidth: 2
                });
                
                const line = new THREE.Line(lineGeometry, lineMaterial);
                line.computeLineDistances();
                line.name = `overlay_trajectory_${particleName}`;
                
                overlayTrajectories[particleName] = line;
                scene.add(line);
                
                // Initialize position
                if (data.positions.length > 0) {
                    const pos = data.positions[0];
                    overlayPositions[particleName] = 0;
                }
            }
        }
        
        function createParticleControls(particleData) {
            const container = document.getElementById('particleControls');
            container.innerHTML = '';
            
            for (const [particleName, data] of Object.entries(particleData)) {
                const control = document.createElement('div');
                control.className = 'particle-control';
                if (particleName === primaryParticle) {
                    control.classList.add('primary');
                }
                
                control.innerHTML = `
                    <div class="particle-name">${particleName.charAt(0).toUpperCase() + particleName.slice(1)}</div>
                    <div class="particle-toggle">
                        <input type="checkbox" id="toggle_${particleName}" checked onchange="toggleParticle('${particleName}')">
                        <label for="toggle_${particleName}">Show</label>
                    </div>
                    <div class="particle-actions">
                        <button class="button small" onclick="makePrimary('${particleName}')">Make Primary</button>
                        <button class="button small" onclick="mountCamera('${particleName}')">Mount Camera</button>
                    </div>
                `;
                
                container.appendChild(control);
            }
        }
        
        function createParticleVisualization(particleName, data) {
            // Create particle scaled for visibility at orbit distances
            const geometry = new THREE.SphereGeometry(1, 16, 16);
            const material = new THREE.MeshPhongMaterial({
                color: particleColors[particleName] || 0xffffff,
                emissive: particleColors[particleName] || 0xffffff,
                emissiveIntensity: 0.5
            });
            
            const particle = new THREE.Mesh(geometry, material);
            particle.name = particleName;
            particle.userData = {
                type: 'particle',
                name: particleName,
                trajectory: data
            };
            
            // Add a glowing effect for better visibility
            const glowGeometry = new THREE.SphereGeometry(2, 16, 16);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: particleColors[particleName] || 0xffffff,
                transparent: true,
                opacity: 0.3
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            particle.add(glow);
            
            particles[particleName] = particle;
            scene.add(particle);
            
            // Create trajectory line following curved spacetime
            if (data.positions && data.positions.length > 0) {
                const points = [];
                console.log(`First position for ${particleName}: r=${data.positions[0][0]}, phi=${data.positions[0][1]}`);
                for (let i = 0; i < data.positions.length; i++) {
                    const pos = data.positions[i];
                    const r = pos[0]; // Already in geometric units from data extraction
                    const phi = pos[1];
                    
                    // Calculate position on curved spacetime surface
                    const x = r * Math.cos(phi);
                    const z = r * Math.sin(phi);
                    
                    // Apply Flamm's paraboloid embedding - same as grid
                    const height = r > 2 ? -2 * Math.sqrt(2 * M * (r - 2 * M)) : 0;
                    const y = height * 2;  // Scale up for visibility, same as grid
                    
                    points.push(new THREE.Vector3(x, y, z));
                }
                console.log(`Created ${points.length} points for ${particleName} trajectory on curved surface`);
                
                const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
                // Use LineSegments for better visibility
                const lineMaterial = new THREE.LineBasicMaterial({
                    color: particleColors[particleName] || 0xffffff,
                    opacity: 1.0,
                    transparent: false
                });
                
                // Also create a tube geometry for better visibility
                const curve = new THREE.CatmullRomCurve3(points);
                const tubeGeometry = new THREE.TubeGeometry(curve, points.length, 0.3, 8, false);
                const tubeMaterial = new THREE.MeshBasicMaterial({
                    color: particleColors[particleName] || 0xffffff,
                    opacity: 0.6,
                    transparent: true
                });
                
                // Add both line and tube for visibility
                const line = new THREE.Line(lineGeometry, lineMaterial);
                line.name = particleName + '_trajectory';
                trajectoryLines[particleName] = line;
                scene.add(line);
                
                const tube = new THREE.Mesh(tubeGeometry, tubeMaterial);
                tube.name = particleName + '_trajectory_tube';
                scene.add(tube);
            }
            
            // Set initial position
            if (data.positions && data.positions.length > 0) {
                const pos = data.positions[0];
                updateParticlePosition(particleName, pos);
                
                // Add particle name label
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                context.fillStyle = 'white';
                context.font = '48px Arial';
                context.fillText(particleName, 10, 50);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture, opacity: 0.8 });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(10, 2.5, 1);
                sprite.position.set(0, 5, 0);
                particle.add(sprite);
            }
        }
        
        function updateParticlePosition(particleName, position) {
            const particle = particles[particleName];
            if (!particle) return;
            
            const r = position[0]; // Already in geometric units from data extraction
            const phi = position[1];
            
            // Position particle on curved spacetime surface
            particle.position.x = r * Math.cos(phi);
            particle.position.z = r * Math.sin(phi);
            
            // Apply Flamm's paraboloid embedding - same as trajectory
            const height = r > 2 ? -2 * Math.sqrt(2 * M * (r - 2 * M)) : 0;
            particle.position.y = height * 2;  // Scale up for visibility
            
            currentPositions[particleName] = position;
        }
        
        function updateOverlayParticlePosition(particleName, position) {
            const particle = overlayParticles[particleName];
            if (!particle) return;
            
            const r = position[0];
            const phi = position[1];
            
            // Position particle on curved spacetime surface
            particle.position.x = r * Math.cos(phi);
            particle.position.z = r * Math.sin(phi);
            
            // Apply Flamm's paraboloid embedding
            const height = r > 2 ? -2 * Math.sqrt(2 * M * (r - 2 * M)) : 0;
            particle.position.y = height * 2;
            
            overlayPositions[particleName] = position;
        }
        
        function toggleParticle(particleName) {
            const checkbox = document.getElementById(`toggle_${particleName}`);
            const particle = particles[particleName];
            const trajectory = trajectoryLines[particleName];
            
            if (particle) particle.visible = checkbox.checked;
            if (trajectory) trajectory.visible = checkbox.checked;
            
            // Also toggle the tube if it exists
            const tube = scene.getObjectByName(particleName + '_trajectory_tube');
            if (tube) tube.visible = checkbox.checked;
        }
        
        function makePrimary(particleName) {
            primaryParticle = particleName;
            
            // Update UI
            document.querySelectorAll('.particle-control').forEach(control => {
                control.classList.remove('primary');
            });
            
            const controls = document.getElementById('particleControls').children;
            for (const control of controls) {
                if (control.querySelector('.particle-name').textContent.toLowerCase() === particleName) {
                    control.classList.add('primary');
                    break;
                }
            }
            
            // Update Schwarzschild radius based on particle mass
            updateSchwarzschildRadius(particleName);
        }
        
        function updateSchwarzschildRadius(particleName) {
            // This would calculate the actual Schwarzschild radius for the particle
            // For now, we'll show the black hole's radius
            document.getElementById('schwarzschildRadius').textContent = (2 * M).toFixed(3);
        }
        
        function mountCamera(particleName) {
            const observerIndicator = scene.getObjectByName('observerIndicator');
            
            if (mountedParticle === particleName) {
                // Unmount
                mountedParticle = null;
                setView('third');
                document.getElementById('particleTensorInfo').style.display = 'none';
                // Show observer indicator when unmounting
                if (observerIndicator) {
                    observerIndicator.visible = true;
                }
            } else {
                // Mount
                mountedParticle = particleName;
                document.getElementById('particleTensorInfo').style.display = 'block';
                updateTensorInfo();
                // Hide observer indicator when mounting camera to particle
                if (observerIndicator) {
                    observerIndicator.visible = false;
                }
            }
            
            // Update UI
            document.querySelectorAll('.particle-control').forEach(control => {
                control.classList.remove('mounted');
            });
            
            if (mountedParticle) {
                const controls = document.getElementById('particleControls').children;
                for (const control of controls) {
                    if (control.querySelector('.particle-name').textContent.toLowerCase() === particleName) {
                        control.classList.add('mounted');
                        break;
                    }
                }
            }
        }
        
        function updateTensorInfo() {
            if (!mountedParticle || !currentTheory) return;
            
            const theoryData = runData[currentTheory];
            const particleData = theoryData.particles[mountedParticle];
            
            if (!particleData) return;
            
            // Calculate current state based on animation time
            const timeIndex = Math.floor(animationTime * (particleData.positions.length - 1));
            const position = particleData.positions[Math.min(timeIndex, particleData.positions.length - 1)];
            const velocity = particleData.velocities ? particleData.velocities[timeIndex] : [0, 0];
            
            // Display tensor components
            const tensorContent = document.getElementById('tensorContent');
            tensorContent.innerHTML = `
                <p><strong>Position:</strong> r = ${position[0].toFixed(3)} M, φ = ${position[1].toFixed(3)} rad</p>
                <p><strong>Velocity:</strong> ṙ = ${velocity[0].toFixed(3)}, φ̇ = ${velocity[1].toFixed(3)}</p>
                <p><strong>4-Velocity:</strong> uᵘ = (${1}, ${velocity[0].toFixed(3)}, 0, ${velocity[1].toFixed(3)})</p>
                <p><strong>Metric:</strong> gₜₜ = ${(1 - 2*M/position[0]).toFixed(4)}</p>
            `;
            
            // Display degrees of freedom
            const dofContent = document.getElementById('dofContent');
            dofContent.innerHTML = `
                <div class="dof-item">• Radial motion: ${Math.abs(velocity[0]) > 0.01 ? 'Active' : 'Constrained'}</div>
                <div class="dof-item">• Angular motion: ${Math.abs(velocity[1]) > 0.01 ? 'Active' : 'Constrained'}</div>
                <div class="dof-item">• Energy: Conserved</div>
                <div class="dof-item">• Angular momentum: Conserved</div>
            `;
        }
        
        function toggleSpacetimeGrid() {
            const checkbox = document.getElementById('gridToggle');
            if (spacetimeGrid) {
                spacetimeGrid.visible = checkbox.checked;
            }
        }
        
        function onMouseMove(event) {
            // Calculate mouse position in normalized device coordinates
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Update raycaster
            raycaster.setFromCamera(mouse, camera);
            
            // Check for intersections
            const objects = [...Object.values(particles), blackHole].filter(obj => obj && obj.visible);
            const intersects = raycaster.intersectObjects(objects);
            
            if (intersects.length > 0) {
                const object = intersects[0].object;
                if (object !== hoveredObject) {
                    hoveredObject = object;
                    showTooltip(event, object);
                }
                updateTooltipPosition(event);
            } else {
                hoveredObject = null;
                hideTooltip();
            }
        }
        
        function onMouseClick(event) {
            if (hoveredObject) {
                selectedObject = hoveredObject;
                showObjectInfo(selectedObject);
            }
        }
        
        function showTooltip(event, object) {
            const tooltip = document.getElementById('tooltip');
            
            if (object.userData.type === 'particle') {
                tooltip.innerHTML = `
                    <strong>${object.name.charAt(0).toUpperCase() + object.name.slice(1)}</strong><br>
                    Click for detailed information
                `;
            } else if (object.userData.type === 'blackhole') {
                tooltip.innerHTML = `
                    <strong>Black Hole</strong><br>
                    Mass: ${blackHoleMass.toExponential(2)} kg<br>
                    Schwarzschild Radius: ${(2 * M).toFixed(3)} M<br>
                    Click for more details
                `;
            }
            
            tooltip.style.display = 'block';
            updateTooltipPosition(event);
        }
        
        function updateTooltipPosition(event) {
            const tooltip = document.getElementById('tooltip');
            tooltip.style.left = (event.clientX + 15) + 'px';
            tooltip.style.top = (event.clientY - 15) + 'px';
        }
        
        function hideTooltip() {
            document.getElementById('tooltip').style.display = 'none';
        }
        
        function showObjectInfo(object) {
            const info = document.getElementById('objectInfo');
            
            if (object.userData.type === 'particle') {
                const theoryData = runData[currentTheory];
                const particleData = theoryData.particles[object.name];
                
                info.innerHTML = `
                    <h3>${object.name.charAt(0).toUpperCase() + object.name.slice(1)} Properties</h3>
                    <p><strong>Theory:</strong> ${currentTheory}</p>
                    <p><strong>Trajectory Points:</strong> ${particleData.positions.length}</p>
                    <p><strong>Current Position:</strong> r = ${currentPositions[object.name][0].toFixed(3)} M</p>
                    <p><strong>Particle Type:</strong> ${getParticleType(object.name)}</p>
                    <p><strong>Key Features:</strong> ${getParticleFeatures(object.name)}</p>
                    <button class="button" onclick="closeObjectInfo()">Close</button>
                `;
            } else if (object.userData.type === 'blackhole') {
                info.innerHTML = `
                    <h3>Black Hole Information</h3>
                    <p><strong>Type:</strong> Primordial Mini Black Hole</p>
                    <p><strong>Mass:</strong> ${blackHoleMass.toExponential(2)} kg</p>
                    <p><strong>Schwarzschild Radius:</strong> ${(2 * M).toFixed(3)} M</p>
                    <p><strong>Event Horizon:</strong> r = ${(2 * M).toFixed(3)} M</p>
                    <p><strong>Photon Sphere:</strong> r = ${(3 * M).toFixed(3)} M</p>
                    <p><strong>ISCO:</strong> r = ${(6 * M).toFixed(3)} M</p>
                    <button class="button" onclick="closeObjectInfo()">Close</button>
                `;
            }
            
            info.style.display = 'block';
        }
        
        function closeObjectInfo() {
            document.getElementById('objectInfo').style.display = 'none';
        }
        
        function getParticleType(name) {
            const types = {
                electron: 'Fermion (Lepton)',
                neutrino: 'Fermion (Lepton)',
                photon: 'Boson (Gauge)',
                proton: 'Fermion (Baryon)'
            };
            return types[name] || 'Unknown';
        }
        
        function getParticleFeatures(name) {
            const features = {
                electron: 'Charged, massive, stable',
                neutrino: 'Neutral, nearly massless, weakly interacting',
                photon: 'Massless, travels at c, electromagnetic',
                proton: 'Charged, massive, stable (in most theories)'
            };
            return features[name] || 'Standard particle';
        }
        
        function setView(viewType) {
            currentView = viewType;
            
            switch (viewType) {
                case 'third':
                    // Position camera to see typical orbits at ~100 M
                    camera.position.set(150, 100, 150);
                    camera.lookAt(0, 0, 0);
                    controls.target.set(0, 0, 0);
                    controls.enabled = true;
                    controls.update();
                    document.getElementById('viewInfo').textContent = 'Third Person View - Use mouse to orbit';
                    break;
                    
                case 'top':
                    camera.position.set(0, 200, 0);
                    camera.lookAt(0, 0, 0);
                    controls.target.set(0, 0, 0);
                    controls.enabled = true;
                    controls.update();
                    document.getElementById('viewInfo').textContent = 'Top View - Looking down at orbital plane';
                    break;
            }
        }
        
        function resetCamera() {
            setView(currentView);
        }
        
        function toggleAnimation() {
            isPlaying = !isPlaying;
            document.getElementById('playPauseBtn').textContent = isPlaying ? 'Pause' : 'Play';
        }
        
        function resetAnimation() {
            animationTime = 0;
            document.getElementById('timeSlider').value = 0;
            updateTimeDisplay();
        }
        
        function updateSpeed(event) {
            animationSpeed = parseFloat(event.target.value);
            document.getElementById('speedValue').textContent = animationSpeed.toFixed(1);
        }
        
        function updateTimeFromSlider(event) {
            animationTime = parseFloat(event.target.value) / 100;
            updateTimeDisplay();
        }
        
        function updateTimeDisplay() {
            document.getElementById('timeValue').textContent = (animationTime * 100).toFixed(1);
            document.getElementById('timeSlider').value = animationTime * 100;
        }
        
        function updateLegend() {
            const legendDiv = document.getElementById('legend');
            legendDiv.innerHTML = '';
            
            for (const [name, color] of Object.entries(particleColors)) {
                if (particles[name]) {
                    const item = document.createElement('div');
                    item.className = 'legend-item';
                    
                    const colorBox = document.createElement('div');
                    colorBox.className = 'legend-color';
                    colorBox.style.backgroundColor = `#${color.toString(16).padStart(6, '0')}`;
                    
                    const label = document.createElement('span');
                    label.textContent = name.charAt(0).toUpperCase() + name.slice(1);
                    
                    item.appendChild(colorBox);
                    item.appendChild(label);
                    legendDiv.appendChild(item);
                }
            }
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            if (isPlaying && currentTheory) {
                animationTime += 0.001 * animationSpeed;
                if (animationTime > 1) {
                    animationTime = 0;
                }
                updateTimeDisplay();
                
                // Update particle positions
                const theoryData = runData[currentTheory];
                for (const [particleName, data] of Object.entries(theoryData.particles || {})) {
                    if (data && data.positions && particles[particleName]) {
                        const index = Math.floor(animationTime * (data.positions.length - 1));
                        const position = data.positions[Math.min(index, data.positions.length - 1)];
                        updateParticlePosition(particleName, position);
                    }
                }
                
                // Update overlay particle positions if overlay is active
                if (overlayTheory) {
                    const overlayData = runData[overlayTheory];
                    for (const [particleName, data] of Object.entries(overlayData.particles || {})) {
                        if (data && data.positions && overlayParticles[particleName]) {
                            const index = Math.floor(animationTime * (data.positions.length - 1));
                            const position = data.positions[Math.min(index, data.positions.length - 1)];
                            updateOverlayParticlePosition(particleName, position);
                        }
                    }
                }
                
                // Update tensor info if camera is mounted
                if (mountedParticle) {
                    updateTensorInfo();
                    
                    // Follow mounted particle but keep black hole in view
                    const particle = particles[mountedParticle];
                    if (particle) {
                        // Get particle position in r, phi coordinates
                        const pos = currentPositions[mountedParticle];
                        if (pos) {
                            const r = pos[0];
                            const phi = pos[1];
                            
                            // Place camera behind and above the particle on the curved surface
                            const cameraR = r + 10;
                            const cameraPhi = phi - 0.2; // Slightly behind
                            
                            // Calculate camera position on curved surface
                            const cameraX = cameraR * Math.cos(cameraPhi);
                            const cameraZ = cameraR * Math.sin(cameraPhi);
                            const cameraHeight = cameraR > 2 ? -2 * Math.sqrt(2 * M * (cameraR - 2 * M)) : 0;
                            
                            camera.position.set(
                                cameraX,
                                cameraHeight * 2 + 20, // Above the curved surface
                                cameraZ
                            );
                            
                            // Always look at the black hole center
                            camera.lookAt(0, -10, 0); // Look at bottom of the well
                            controls.target.set(0, -10, 0);
                        }
                    }
                }
            }
            
            // Always update spacetime grid to show dynamic curvature
            updateSpacetimeGrid();
            
            // Update observer indicator to show camera position
            const observerIndicator = scene.getObjectByName('observerIndicator');
            if (observerIndicator) {
                observerIndicator.position.copy(camera.position);
                observerIndicator.lookAt(0, 0, 0);
                observerIndicator.rotateX(Math.PI / 2); // Point cone toward black hole
            }
            
            // Update controls (but keep target on black hole)
            controls.target.set(0, 0, 0);
            controls.update();
            
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function updateOverlayParticlePosition(particleName, position) {
            const particle = overlayParticles[particleName];
            if (!particle) return;
            
            const r = position[0];
            const phi = position[1];
            
            // Position overlay particle on curved spacetime surface
            particle.position.x = r * Math.cos(phi);
            particle.position.z = r * Math.sin(phi);
            
            // Apply Flamm's paraboloid embedding
            const height = r > 2 ? -2 * Math.sqrt(2 * M * (r - 2 * M)) : 0;
            particle.position.y = height * 2;
        }
        
        function fitCameraToScene() {
            // Calculate bounding box of all trajectories
            const box = new THREE.Box3();
            
            // Include black hole
            if (blackHole) {
                box.expandByObject(blackHole);
            }
            
            // Include all trajectory lines
            for (const line of Object.values(trajectoryLines)) {
                if (line && line.visible) {
                    box.expandByObject(line);
                }
            }
            
            if (!box.isEmpty()) {
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                
                // Position camera to see entire scene
                const distance = maxDim * 2;
                camera.position.set(distance * 0.8, distance * 0.6, distance * 0.8);
                camera.lookAt(center);
                
                // Update controls
                controls.target.copy(center);
                controls.update();
            }
        }
        
        // Initialize
        init();
    </script>
</body>
</html>