#!/usr/bin/env python3
"""Exact theory implementation used for prediction"""

import numpy as np
import torch
from physics_agent.base_theory import GravitationalTheory

class UnifiedGaugeModel(GravitationalTheory):
    """
    Unified Gauge Model (UGM) from Partanen & Tulkki (2025).
    
    <reason>chain: Gravity emerges from four U(1) gauge symmetries, one for each tetrad index</reason>
    <reason>chain: Fully renormalizable and integrates seamlessly with Standard Model</reason>
    
    Key features:
    - Four independent U(1) gauge fields H^a_μ (a=0,1,2,3)
    - Tetrad formalism: e^a_μ = δ^a_μ + g H^a_μ
    - Metric from tetrads: g_μν = η_ab e^a_μ e^b_ν
    - Each U(1) sector has its own coupling α_a
    
    References:
    - Partanen & Tulkki (2025): "Gravity generated by four one-dimensional unitary gauge symmetries and the Standard Model"
    """
    
    category = "ugm"
    
    # <reason>chain: Parameter sweep for the four U(1) couplings and universal coupling g</reason>
    sweep = dict(
        alpha0={'min': 0.5, 'max': 2.0, 'points': 5, 'scale': 'linear'},
        alpha1={'min': 0.5, 'max': 2.0, 'points': 5, 'scale': 'linear'},
        alpha2={'min': 0.5, 'max': 2.0, 'points': 5, 'scale': 'linear'},
        alpha3={'min': 0.5, 'max': 2.0, 'points': 5, 'scale': 'linear'},
        g_coupling={'min': 1e-3, 'max': 1.0, 'points': 10, 'scale': 'log'}
    )
    
    # <reason>chain: Default to equal weights for all U(1) sectors</reason>
    preferred_params = {
        'alpha0': 1.0,
        'alpha1': 1.0, 
        'alpha2': 1.0,
        'alpha3': 1.0,
        'g_coupling': 0.1
    }
    
    cacheable = True
    
    def __init__(self, alpha0: float = 1.0, alpha1: float = 1.0, 
                 alpha2: float = 1.0, alpha3: float = 1.0, 
                 g_coupling: float = 0.1):
        """
        Initialize UGM with four U(1) coupling constants and universal coupling.
        
        Args:
            alpha0-3: Weights for each U(1) sector
            g_coupling: Universal gauge coupling constant
        """
        # <reason>chain: Store the four U(1) couplings</reason>
        self.alphas = torch.tensor([alpha0, alpha1, alpha2, alpha3], dtype=torch.float64)
        self.g = g_coupling
        
        # <reason>chain: Build the gravitational Lagrangian from four U(1) sectors</reason>
        # L_grav = -1/4 Σ_a α_a F^a_μν F^a^μν
        
        gravity_lagrangian = 0
        for a in range(4):
            F_a = get_symbol(f'F^{a}_μν')  # Field strength for U(1)_a
            gravity_lagrangian -= sp.Rational(1, 4) * get_symbol(f'α_{a}') * F_a * get_symbol(f'F^{a}^μν')
        
        # <reason>chain: Add matter and gauge sectors for full unification</reason>
        # Standard QED-like matter coupling through covariant derivatives
        psi = get_symbol('ψ')
        psi_bar = get_symbol('ψ̄')
        gamma_mu = get_symbol('γ^μ')
        D_mu = get_symbol('D_μ')  # Covariant derivative including all gauge fields
        
        matter_lagrangian = sp.I * psi_bar * gamma_mu * D_mu * psi - get_symbol('m_f') * psi_bar * psi
        
        # <reason>chain: Standard Model gauge fields couple through the tetrad</reason>
        gauge_lagrangian = -sp.Rational(1, 4) * get_symbol('F_μν') * get_symbol('F^μν')  # EM field
        
        # <reason>chain: Interaction through tetrad-modified coupling</reason>
        interaction_lagrangian = -get_symbol('q') * psi_bar * gamma_mu * psi * get_symbol('A_μ')
        
        super().__init__(
            f"UGM (α=[{alpha0:.1f},{alpha1:.1f},{alpha2:.1f},{alpha3:.1f}], g={g_coupling:.2e})",
            lagrangian=gravity_lagrangian,
            matter_lagrangian=matter_lagrangian,
            gauge_lagrangian=gauge_lagrangian,
            interaction_lagrangian=interaction_lagrangian
        )
        
        # <reason>chain: Mark as needing UGM solver for proper tetrad handling</reason>
        self.use_ugm_solver = True
        
    def initialize_gauge_fields(self, r: Tensor, theta: Tensor = None, phi: Tensor = None) -> Tensor:
        """
        Initialize the four U(1) gauge fields H^a_μ.
        
        <reason>chain: Use weak-field approximation around spherical mass</reason>
        <reason>chain: H^0_0 generates time dilation, H^i_i generates spatial curvature</reason>
        
        Returns:
            H: Tensor of shape (4, 4, *r.shape) containing gauge potentials
        """
        device = r.device
        dtype = r.dtype
        
        # <reason>chain: Initialize with zeros then add weak-field corrections</reason>
        H = torch.zeros((4, 4) + r.shape, device=device, dtype=dtype)
        
        # <reason>chain: Weak-field limit around spherical mass M</reason>
        # In Newtonian limit: g_00 ≈ -(1 + 2Φ/c²) where Φ = -GM/r
        # This gives H^0_0 ≈ -Φ/c² = GM/(rc²) for small g
        
        # Assume M=1, G=1, c=1 in geometric units
        rs = 2.0  # Schwarzschild radius in geometric units
        
        # <reason>chain: Time component generates gravitational time dilation</reason>
        # For weak field: e^0_0 = 1 + g*H^0_0 ≈ 1 + rs/(2r)
        # So H^0_0 = rs/(2r*g) but this is the gauge potential, not the field strength
        # <reason>chain: Use proper weak-field expansion for tetrad components</reason>
        H[0, 0] = rs / (2 * r)  # This gives e^0_0 ≈ 1 + g*rs/(2r) when g is small
        
        # <reason>chain: Radial component generates spatial curvature</reason>  
        H[1, 1] = -rs / (2 * r)  # This gives e^1_1 ≈ 1 - g*rs/(2r) when g is small
        
        # <reason>chain: Angular components (simplified spherical symmetry)</reason>
        # In full UGM these would have nontrivial profiles
        H[2, 2] = 0.0  # H^2_2 (theta component)
        H[3, 3] = 0.0  # H^3_3 (phi component)
        
        # <reason>chain: Off-diagonal terms zero for static spherical symmetry</reason>
        # In rotating case (Kerr-like), H^0_3 and H^3_0 would be nonzero
        
        return H
        
    def compute_field_strengths(self, H: Tensor, coords: Tensor) -> Tensor:
        """
        Compute field strengths F^a_μν = ∂_μ H^a_ν - ∂_ν H^a_μ.
        
        <reason>chain: Standard Abelian field strength for each U(1) sector</reason>
        """
        # <reason>chain: Use autograd to compute derivatives</reason>
        coords.requires_grad_(True)
        
        F = torch.zeros((4, 4, 4) + coords.shape[1:], device=H.device, dtype=H.dtype)
        
        for a in range(4):
            for nu in range(4):
                if H[a, nu].requires_grad:
                    # Compute ∂_μ H^a_ν for all μ
                    grad_H = torch.autograd.grad(
                        H[a, nu].sum(), coords, 
                        create_graph=True, retain_graph=True
                    )[0]
                    
                    for mu in range(4):
                        # F^a_μν = ∂_μ H^a_ν - ∂_ν H^a_μ
                        F[a, mu, nu] = grad_H[mu]
                        if mu != nu:
                            grad_H_swap = torch.autograd.grad(
                                H[a, mu].sum(), coords,
                                create_graph=True, retain_graph=True
                            )[0]
                            F[a, mu, nu] -= grad_H_swap[nu]
        
        return F
        
    def get_metric(self, r: Tensor, M_param: Tensor, C_param: Tensor, G_param: Tensor, 
                   t: Tensor = None, phi: Tensor = None) -> tuple[Tensor, Tensor, Tensor, Tensor]:
        """
        Compute metric components from the four U(1) gauge fields.
        
        <reason>chain: Build tetrad e^a_μ then metric g_μν = η_ab e^a_μ e^b_ν</reason>
        """
        # <reason>chain: Initialize gauge fields for given position</reason>
        theta = torch.full_like(r, np.pi/2)  # Equatorial plane
        if phi is None:
            phi = torch.zeros_like(r)
        
        H = self.initialize_gauge_fields(r, theta, phi)
        
        # <reason>chain: Build tetrad e^a_μ = δ^a_μ + g H^a_μ</reason>
        # Shape: (4, 4, *r.shape)
        e = torch.eye(4, device=r.device, dtype=r.dtype).reshape(4, 4, *([1] * len(r.shape)))
        e = e.expand(4, 4, *r.shape) + self.g * H
        
        # <reason>chain: Minkowski metric η_ab = diag(-1, 1, 1, 1)</reason>
        eta = torch.diag(torch.tensor([-1.0, 1.0, 1.0, 1.0], device=r.device, dtype=r.dtype))
        
        # <reason>chain: Compute metric g_μν = η_ab e^a_μ e^b_ν</reason>
        # Use einsum for clarity: sum over tetrad indices a,b
        g = torch.einsum('ab,ai...,bj...->ij...', eta, e, e)
        
        # <reason>chain: Extract 2+1D metric components for geodesic integrator</reason>
        g_tt = g[0, 0]
        g_rr = g[1, 1]
        g_pp = g[3, 3]  # φφ component
        g_tp = g[0, 3]  # tφ component (frame dragging if present)
        
        return g_tt, g_rr, g_pp, g_tp
        
    def get_metric_tensor(self, coords_4d: Tensor) -> Tensor:
        """
        Get full 4x4 metric tensor at given coordinates.
        
        <reason>chain: Full implementation for UGMGeodesicRK4Solver</reason>
        """
        t, r, theta, phi = coords_4d[0], coords_4d[1], coords_4d[2], coords_4d[3]
        
        # <reason>chain: Get gauge fields and build full metric</reason>
        H = self.initialize_gauge_fields(r.unsqueeze(0), theta.unsqueeze(0), phi.unsqueeze(0))
        H = H.squeeze(-1)  # Remove batch dimension
        
        # Build tetrad
        e = torch.eye(4, device=r.device, dtype=r.dtype) + self.g * H
        
        # Minkowski metric
        eta = torch.diag(torch.tensor([-1.0, 1.0, 1.0, 1.0], device=r.device, dtype=r.dtype))
        
        # Full metric tensor
        g = torch.einsum('ab,am,bn->mn', eta, e, e)
        
        return g
        
    def lagrangian_density(self, H: Tensor, F: Tensor) -> Tensor:
        """
        Compute the gravitational Lagrangian density.
        
        <reason>chain: L = -1/4 Σ_a α_a F^a_μν F^a^μν</reason>
        """
        L = torch.zeros_like(H[0, 0])
        
        for a in range(4):
            # Contract field strength: F^a_μν F^a^μν
            F_squared = torch.einsum('mn...,mn...', F[a], F[a])
            L -= 0.25 * self.alphas[a] * F_squared
            
        return L
        
    def get_H_a_nu(self, coords_4d: Tensor) -> Tensor:
        """
        Get gauge field configuration for UGMGeodesicRK4Solver.
        
        <reason>chain: Interface method for geodesic integrator</reason>
        """
        r = coords_4d[1].unsqueeze(0)
        theta = coords_4d[2].unsqueeze(0) if coords_4d[2] is not None else torch.full_like(r, np.pi/2)
        phi = coords_4d[3].unsqueeze(0) if coords_4d[3] is not None else torch.zeros_like(r)
        
        H = self.initialize_gauge_fields(r, theta, phi)
        return H.squeeze(-1)  # Remove spatial batch dimension 


# Instantiation with exact parameters
theory = UnifiedGaugeModel()
theory.alpha = "α"
theory.beta = "β"
theory.gamma = "γ"
