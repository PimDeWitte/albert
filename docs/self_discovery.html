<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Self-Discovery System - Albert Framework</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        
        h1, h2, h3 {
            color: #1976d2;
        }
        
        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .subtitle {
            font-size: 1.2em;
            color: #666;
            margin-bottom: 30px;
        }
        
        .discovery-hero {
            background: linear-gradient(135deg, #6a1b9a 0%, #9c27b0 100%);
            color: white;
            padding: 40px;
            border-radius: 12px;
            margin-bottom: 40px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }
        
        .process-flow {
            background: white;
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            margin-bottom: 30px;
        }
        
        #discovery-flow {
            width: 100%;
            height: 500px;
        }
        
        .phase-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 25px;
            margin-bottom: 40px;
        }
        
        .phase-card {
            background: white;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            position: relative;
            overflow: hidden;
        }
        
        .phase-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #9c27b0, #ce93d8);
        }
        
        .phase-number {
            background: #9c27b0;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-bottom: 15px;
        }
        
        .equation {
            background-color: #f3e5f5;
            padding: 15px;
            border-left: 4px solid #9c27b0;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
        }
        
        .algorithm-box {
            background: #f8f9fa;
            padding: 30px;
            border-radius: 8px;
            margin-bottom: 30px;
        }
        
        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .feature-item {
            background: white;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            border: 2px solid #e0e0e0;
            transition: all 0.3s ease;
        }
        
        .feature-item:hover {
            border-color: #9c27b0;
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .feature-icon {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .discovery-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }
        
        .stat-box {
            background: linear-gradient(135deg, #9c27b0 0%, #ce93d8 100%);
            color: white;
            padding: 25px;
            border-radius: 8px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 2.5em;
            font-weight: bold;
            display: block;
            margin-bottom: 5px;
        }
        
        .stat-label {
            opacity: 0.9;
            font-size: 0.9em;
        }
        
        .theory-evolution {
            background: white;
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            margin-bottom: 30px;
        }
        
        #evolution-chart {
            width: 100%;
            height: 400px;
        }
        
        .code-example {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
            margin-top: 20px;
        }
        
        .keyword { color: #569cd6; }
        .string { color: #ce9178; }
        .comment { color: #6a9955; }
        .number { color: #b5cea8; }
        
        .example-theories {
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            margin-bottom: 30px;
        }
        
        .theory-example {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 15px;
            border-left: 4px solid #9c27b0;
        }
        
        .theory-example h4 {
            margin-top: 0;
            color: #6a1b9a;
        }
        
        .parameter-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .param-box {
            text-align: center;
            padding: 10px;
            background: white;
            border-radius: 6px;
        }
        
        .param-value {
            font-size: 1.2em;
            font-weight: bold;
            color: #9c27b0;
        }
        
        .param-name {
            font-size: 0.85em;
            color: #666;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1); opacity: 0.8; }
        }
        
        .pulsing {
            animation: pulse 2s infinite;
        }
    </style>
</head>
<body>
    <h1>Self-Discovery System</h1>
    <p class="subtitle">Automated Theory Generation and Validation</p>
    
    <div class="discovery-hero">
        <h2 style="color: white; margin-top: 0;">Discovering New Physics</h2>
        <p>The Albert framework employs advanced automated discovery algorithms to explore the space of possible gravitational theories, systematically generating and testing novel modifications to General Relativity that could explain quantum gravity, dark matter, or other phenomena.</p>
        <div class="discovery-stats">
            <div class="stat-box">
                <span class="stat-value">10^12</span>
                <span class="stat-label">Theory Space</span>
            </div>
            <div class="stat-box">
                <span class="stat-value">500+</span>
                <span class="stat-label">Generated Theories</span>
            </div>
            <div class="stat-box">
                <span class="stat-value">18</span>
                <span class="stat-label">Novel Predictions</span>
            </div>
            <div class="stat-box">
                <span class="stat-value">3</span>
                <span class="stat-label">Breakthrough Candidates</span>
            </div>
        </div>
    </div>

    <div class="process-flow">
        <h2>Discovery Process Flow</h2>
        <canvas id="discovery-flow"></canvas>
    </div>

    <h2>Discovery Phases</h2>
    
    <div class="phase-cards">
        <div class="phase-card">
            <div class="phase-number">1</div>
            <h3>Theory Generation</h3>
            <p>Generate candidate theories through systematic modification of known physics:</p>
            <div class="equation">
                g_μν^(new) = g_μν^(GR) + δg_μν(α, β, γ...)
            </div>
            <ul>
                <li>Metric perturbations</li>
                <li>Additional field couplings</li>
                <li>Modified dispersion relations</li>
                <li>Quantum corrections</li>
            </ul>
        </div>

        <div class="phase-card">
            <div class="phase-number">2</div>
            <h3>Constraint Application</h3>
            <p>Apply fundamental physics constraints:</p>
            <ul>
                <li><strong>Covariance:</strong> ∇_μT^μν = 0</li>
                <li><strong>Causality:</strong> No closed timelike curves</li>
                <li><strong>Energy conditions:</strong> T_μν u^μ u^ν ≥ 0</li>
                <li><strong>Asymptotic flatness:</strong> g_μν → η_μν as r→∞</li>
            </ul>
        </div>

        <div class="phase-card">
            <div class="phase-number">3</div>
            <h3>Numerical Validation</h3>
            <p>Test theories against known observations:</p>
            <ul>
                <li>Solar system tests</li>
                <li>Binary pulsar timing</li>
                <li>Gravitational wave signals</li>
                <li>Cosmological observations</li>
            </ul>
            <div class="equation">
                χ² = Σ[(O_i - T_i)²/σ_i²]
            </div>
        </div>

        <div class="phase-card">
            <div class="phase-number">4</div>
            <h3>Novel Prediction</h3>
            <p>Identify unique predictions for experimental testing:</p>
            <ul>
                <li>Modified gravitational wave polarizations</li>
                <li>Quantum gravity signatures</li>
                <li>Dark matter interactions</li>
                <li>Black hole thermodynamics</li>
            </ul>
        </div>

        <div class="phase-card">
            <div class="phase-number">5</div>
            <h3>Theory Evolution</h3>
            <p>Refine successful theories using genetic algorithms:</p>
            <div class="equation">
                T_{n+1} = mutate(crossover(T_n^(best)))
            </div>
            <ul>
                <li>Parameter optimization</li>
                <li>Structure refinement</li>
                <li>Hybrid theory generation</li>
            </ul>
        </div>

        <div class="phase-card">
            <div class="phase-number">6</div>
            <h3>Publication Pipeline</h3>
            <p>Prepare discoveries for scientific community:</p>
            <ul>
                <li>Automated paper generation</li>
                <li>Peer review preparation</li>
                <li>Experimental proposals</li>
                <li>Open-source code release</li>
            </ul>
        </div>
    </div>

    <div class="algorithm-box">
        <h2>Core Discovery Algorithms</h2>
        
        <div class="feature-grid">
            <div class="feature-item">
                <div class="feature-icon">🧬</div>
                <h4>Genetic Evolution</h4>
                <p>Evolve theories through natural selection based on fitness scores</p>
            </div>
            <div class="feature-item">
                <div class="feature-icon">🌳</div>
                <h4>Tree Search</h4>
                <p>Systematic exploration of theory modification space</p>
            </div>
            <div class="feature-item">
                <div class="feature-icon">🧠</div>
                <h4>Neural Architecture</h4>
                <p>Deep learning for pattern recognition in successful theories</p>
            </div>
            <div class="feature-item">
                <div class="feature-icon">🎲</div>
                <h4>Monte Carlo</h4>
                <p>Random sampling with importance weighting</p>
            </div>
            <div class="feature-item">
                <div class="feature-icon">🔄</div>
                <h4>Symmetry Analysis</h4>
                <p>Discover hidden symmetries and conservation laws</p>
            </div>
            <div class="feature-item">
                <div class="feature-icon">📊</div>
                <h4>Bayesian Inference</h4>
                <p>Update theory probabilities based on new evidence</p>
            </div>
        </div>

        <div class="code-example">
<span class="keyword">class</span> TheoryDiscovery:
    <span class="keyword">def</span> generate_candidate(self, base_theory, mutation_rate=<span class="number">0.1</span>):
        <span class="string">"""Generate new theory candidate through controlled mutation"""</span>
        <span class="comment"># Copy base theory structure</span>
        candidate = deepcopy(base_theory)
        
        <span class="comment"># Apply random modifications</span>
        <span class="keyword">if</span> random.random() < mutation_rate:
            <span class="comment"># Modify metric tensor</span>
            candidate.add_correction_term(
                type=<span class="string">'metric'</span>,
                form=self.generate_tensor_modification(),
                coupling=random.gauss(<span class="number">0</span>, <span class="number">0.1</span>)
            )
        
        <span class="comment"># Ensure physical constraints</span>
        <span class="keyword">if</span> self.validate_constraints(candidate):
            <span class="keyword">return</span> candidate
        <span class="keyword">else</span>:
            <span class="keyword">return</span> self.repair_theory(candidate)
    
    <span class="keyword">def</span> fitness_score(self, theory):
        <span class="string">"""Evaluate theory fitness based on multiple criteria"""</span>
        score = <span class="number">0.0</span>
        
        <span class="comment"># Agreement with experiments</span>
        score += self.experimental_chi_squared(theory) * <span class="number">0.4</span>
        
        <span class="comment"># Mathematical elegance</span>
        score += self.complexity_penalty(theory) * <span class="number">0.2</span>
        
        <span class="comment"># Novel predictions</span>
        score += self.novelty_score(theory) * <span class="number">0.3</span>
        
        <span class="comment"># Quantum consistency</span>
        score += self.quantum_compatibility(theory) * <span class="number">0.1</span>
        
        <span class="keyword">return</span> score
        </div>
    </div>

    <div class="theory-evolution">
        <h2>Theory Evolution Timeline</h2>
        <canvas id="evolution-chart"></canvas>
    </div>

    <div class="example-theories">
        <h2>Example Discovered Theories</h2>
        
        <div class="theory-example">
            <h4>Quantum-Corrected Schwarzschild (QCS)</h4>
            <p>Incorporates quantum vacuum fluctuations near the horizon:</p>
            <div class="equation">
                g_tt = -(1 - 2M/r + αℏ/(Mr³))
            </div>
            <div class="parameter-grid">
                <div class="param-box">
                    <div class="param-value">98.7%</div>
                    <div class="param-name">Validation Score</div>
                </div>
                <div class="param-box">
                    <div class="param-value">α = 0.73</div>
                    <div class="param-name">Quantum Parameter</div>
                </div>
                <div class="param-box">
                    <div class="param-value">Novel</div>
                    <div class="param-name">Hawking Modification</div>
                </div>
            </div>
        </div>

        <div class="theory-example">
            <h4>Torsion-Modified Gravity (TMG)</h4>
            <p>Includes spacetime torsion for dark matter explanation:</p>
            <div class="equation">
                R_μν - ½Rg_μν + T²_μν = 8πGT_μν
            </div>
            <div class="parameter-grid">
                <div class="param-box">
                    <div class="param-value">94.2%</div>
                    <div class="param-name">Validation Score</div>
                </div>
                <div class="param-box">
                    <div class="param-value">λ = 10^-3</div>
                    <div class="param-name">Torsion Coupling</div>
                </div>
                <div class="param-box">
                    <div class="param-value">Explains</div>
                    <div class="param-name">Galaxy Rotation</div>
                </div>
            </div>
        </div>

        <div class="theory-example">
            <h4>Emergent Gravity with Information (EGI)</h4>
            <p>Gravity emerges from quantum information dynamics:</p>
            <div class="equation">
                ΔS = 2πk_B(Mc/ℏ)Δx → F = (Mc²/2π)∇S
            </div>
            <div class="parameter-grid">
                <div class="param-box">
                    <div class="param-value">91.5%</div>
                    <div class="param-name">Validation Score</div>
                </div>
                <div class="param-box">
                    <div class="param-value">S_BH = A/4</div>
                    <div class="param-name">Entropy Scaling</div>
                </div>
                <div class="param-box">
                    <div class="param-value">Unifies</div>
                    <div class="param-name">QM & GR</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Discovery flow visualization
        const flowCanvas = document.getElementById('discovery-flow');
        const flowCtx = flowCanvas.getContext('2d');
        flowCanvas.width = flowCanvas.offsetWidth;
        flowCanvas.height = 500;

        // Define discovery pipeline stages
        const stages = [
            {x: 0.1, y: 0.5, label: 'Theory\nSpace', radius: 40},
            {x: 0.25, y: 0.3, label: 'Generation', radius: 35},
            {x: 0.25, y: 0.7, label: 'Mutation', radius: 35},
            {x: 0.4, y: 0.5, label: 'Constraint\nFilter', radius: 40},
            {x: 0.55, y: 0.5, label: 'Validation', radius: 40},
            {x: 0.7, y: 0.3, label: 'Novel\nPredictions', radius: 35},
            {x: 0.7, y: 0.7, label: 'Refinement', radius: 35},
            {x: 0.85, y: 0.5, label: 'Selected\nTheories', radius: 40}
        ];

        // Flowing particles
        const flowParticles = [];
        class FlowParticle {
            constructor() {
                this.reset();
            }
            
            reset() {
                this.stage = 0;
                this.progress = 0;
                this.speed = 0.01 + Math.random() * 0.01;
                this.path = Math.random() > 0.5 ? 'upper' : 'lower';
                this.active = true;
                this.color = `hsl(${280 + Math.random() * 40}, 70%, 60%)`;
            }
            
            update() {
                this.progress += this.speed;
                
                if (this.progress >= 1) {
                    this.progress = 0;
                    this.stage++;
                    
                    // Random filtering at constraint stage
                    if (this.stage === 3 && Math.random() < 0.5) {
                        this.active = false;
                    }
                    
                    // More filtering at validation
                    if (this.stage === 4 && Math.random() < 0.3) {
                        this.active = false;
                    }
                    
                    if (this.stage >= stages.length - 1 || !this.active) {
                        this.reset();
                    }
                }
            }
            
            draw(ctx, width, height) {
                if (!this.active) return;
                
                let from, to;
                
                // Determine path based on stage
                if (this.stage === 0) {
                    from = stages[0];
                    to = this.path === 'upper' ? stages[1] : stages[2];
                } else if (this.stage === 1) {
                    from = this.path === 'upper' ? stages[1] : stages[2];
                    to = stages[3];
                } else if (this.stage === 2) {
                    from = stages[3];
                    to = stages[4];
                } else if (this.stage === 3) {
                    from = stages[4];
                    to = this.path === 'upper' ? stages[5] : stages[6];
                } else if (this.stage === 4) {
                    from = this.path === 'upper' ? stages[5] : stages[6];
                    to = stages[7];
                }
                
                if (from && to) {
                    const x = from.x * width + (to.x * width - from.x * width) * this.progress;
                    const y = from.y * height + (to.y * height - from.y * height) * this.progress;
                    
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        // Initialize particles
        for (let i = 0; i < 20; i++) {
            setTimeout(() => {
                flowParticles.push(new FlowParticle());
            }, i * 200);
        }

        function drawDiscoveryFlow() {
            flowCtx.clearRect(0, 0, flowCanvas.width, flowCanvas.height);
            
            // Draw connections
            flowCtx.strokeStyle = '#e0e0e0';
            flowCtx.lineWidth = 2;
            flowCtx.beginPath();
            
            // From theory space to generation/mutation
            flowCtx.moveTo(stages[0].x * flowCanvas.width + stages[0].radius, stages[0].y * flowCanvas.height);
            flowCtx.lineTo(stages[1].x * flowCanvas.width - stages[1].radius, stages[1].y * flowCanvas.height);
            flowCtx.moveTo(stages[0].x * flowCanvas.width + stages[0].radius, stages[0].y * flowCanvas.height);
            flowCtx.lineTo(stages[2].x * flowCanvas.width - stages[2].radius, stages[2].y * flowCanvas.height);
            
            // From generation/mutation to constraint filter
            flowCtx.moveTo(stages[1].x * flowCanvas.width + stages[1].radius, stages[1].y * flowCanvas.height);
            flowCtx.lineTo(stages[3].x * flowCanvas.width - stages[3].radius, stages[3].y * flowCanvas.height);
            flowCtx.moveTo(stages[2].x * flowCanvas.width + stages[2].radius, stages[2].y * flowCanvas.height);
            flowCtx.lineTo(stages[3].x * flowCanvas.width - stages[3].radius, stages[3].y * flowCanvas.height);
            
            // Through the pipeline
            flowCtx.moveTo(stages[3].x * flowCanvas.width + stages[3].radius, stages[3].y * flowCanvas.height);
            flowCtx.lineTo(stages[4].x * flowCanvas.width - stages[4].radius, stages[4].y * flowCanvas.height);
            
            // Split to predictions/refinement
            flowCtx.moveTo(stages[4].x * flowCanvas.width + stages[4].radius, stages[4].y * flowCanvas.height);
            flowCtx.lineTo(stages[5].x * flowCanvas.width - stages[5].radius, stages[5].y * flowCanvas.height);
            flowCtx.moveTo(stages[4].x * flowCanvas.width + stages[4].radius, stages[4].y * flowCanvas.height);
            flowCtx.lineTo(stages[6].x * flowCanvas.width - stages[6].radius, stages[6].y * flowCanvas.height);
            
            // To final selection
            flowCtx.moveTo(stages[5].x * flowCanvas.width + stages[5].radius, stages[5].y * flowCanvas.height);
            flowCtx.lineTo(stages[7].x * flowCanvas.width - stages[7].radius, stages[7].y * flowCanvas.height);
            flowCtx.moveTo(stages[6].x * flowCanvas.width + stages[6].radius, stages[6].y * flowCanvas.height);
            flowCtx.lineTo(stages[7].x * flowCanvas.width - stages[7].radius, stages[7].y * flowCanvas.height);
            
            flowCtx.stroke();
            
            // Draw stages
            stages.forEach((stage, index) => {
                const x = stage.x * flowCanvas.width;
                const y = stage.y * flowCanvas.height;
                
                // Stage circle
                const gradient = flowCtx.createRadialGradient(x, y, 0, x, y, stage.radius);
                gradient.addColorStop(0, '#9c27b0');
                gradient.addColorStop(1, '#6a1b9a');
                flowCtx.fillStyle = gradient;
                flowCtx.beginPath();
                flowCtx.arc(x, y, stage.radius, 0, Math.PI * 2);
                flowCtx.fill();
                
                // Stage label
                flowCtx.fillStyle = 'white';
                flowCtx.font = 'bold 12px Arial';
                flowCtx.textAlign = 'center';
                flowCtx.textBaseline = 'middle';
                const lines = stage.label.split('\n');
                lines.forEach((line, i) => {
                    flowCtx.fillText(line, x, y + (i - lines.length/2 + 0.5) * 14);
                });
            });
            
            // Update and draw particles
            flowParticles.forEach(particle => {
                particle.update();
                particle.draw(flowCtx, flowCanvas.width, flowCanvas.height);
            });
            
            requestAnimationFrame(drawDiscoveryFlow);
        }

        drawDiscoveryFlow();

        // Evolution chart
        const evoCanvas = document.getElementById('evolution-chart');
        const evoCtx = evoCanvas.getContext('2d');
        evoCanvas.width = evoCanvas.offsetWidth;
        evoCanvas.height = 400;

        function drawEvolutionChart() {
            evoCtx.clearRect(0, 0, evoCanvas.width, evoCanvas.height);
            
            // Draw axes
            evoCtx.strokeStyle = '#666';
            evoCtx.lineWidth = 2;
            evoCtx.beginPath();
            evoCtx.moveTo(50, 350);
            evoCtx.lineTo(evoCanvas.width - 20, 350);
            evoCtx.moveTo(50, 350);
            evoCtx.lineTo(50, 20);
            evoCtx.stroke();
            
            // Labels
            evoCtx.fillStyle = '#333';
            evoCtx.font = '12px Arial';
            evoCtx.textAlign = 'center';
            evoCtx.fillText('Generation', evoCanvas.width / 2, 390);
            
            evoCtx.save();
            evoCtx.translate(20, evoCanvas.height / 2);
            evoCtx.rotate(-Math.PI / 2);
            evoCtx.fillText('Fitness Score', 0, 0);
            evoCtx.restore();
            
            // Generate evolution data
            const generations = 50;
            const theories = [
                {name: 'Best Theory', color: '#9c27b0', data: []},
                {name: 'Average', color: '#ce93d8', data: []},
                {name: 'Diversity', color: '#ba68c8', data: []}
            ];
            
            // Simulate evolution
            for (let i = 0; i < generations; i++) {
                theories[0].data.push(0.3 + 0.6 * (1 - Math.exp(-i/10)));
                theories[1].data.push(0.2 + 0.4 * (1 - Math.exp(-i/15)));
                theories[2].data.push(0.8 * Math.exp(-i/20) + 0.2);
            }
            
            // Draw evolution curves
            theories.forEach(theory => {
                evoCtx.strokeStyle = theory.color;
                evoCtx.lineWidth = 3;
                evoCtx.beginPath();
                
                theory.data.forEach((value, index) => {
                    const x = 50 + (evoCanvas.width - 70) * index / (generations - 1);
                    const y = 350 - value * 300;
                    
                    if (index === 0) {
                        evoCtx.moveTo(x, y);
                    } else {
                        evoCtx.lineTo(x, y);
                    }
                });
                evoCtx.stroke();
            });
            
            // Legend
            let legendX = evoCanvas.width - 150;
            let legendY = 40;
            theories.forEach(theory => {
                evoCtx.fillStyle = theory.color;
                evoCtx.fillRect(legendX, legendY, 20, 3);
                evoCtx.fillStyle = '#333';
                evoCtx.font = '12px Arial';
                evoCtx.textAlign = 'left';
                evoCtx.fillText(theory.name, legendX + 25, legendY + 5);
                legendY += 25;
            });
            
            // Milestone markers
            const milestones = [
                {gen: 10, label: 'Quantum correction discovered'},
                {gen: 25, label: 'Dark matter candidate'},
                {gen: 40, label: 'Unification achieved'}
            ];
            
            milestones.forEach(milestone => {
                const x = 50 + (evoCanvas.width - 70) * milestone.gen / (generations - 1);
                
                evoCtx.strokeStyle = '#f44336';
                evoCtx.lineWidth = 1;
                evoCtx.setLineDash([5, 5]);
                evoCtx.beginPath();
                evoCtx.moveTo(x, 350);
                evoCtx.lineTo(x, 50);
                evoCtx.stroke();
                evoCtx.setLineDash([]);
                
                evoCtx.fillStyle = '#f44336';
                evoCtx.font = '11px Arial';
                evoCtx.save();
                evoCtx.translate(x, 45);
                evoCtx.rotate(-Math.PI / 4);
                evoCtx.fillText(milestone.label, 0, 0);
                evoCtx.restore();
            });
        }

        drawEvolutionChart();
    </script>
</body>
</html>