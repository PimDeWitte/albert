

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Albert - Differential PyTorch Physics Engine for Testing Theories</title>
    
    <!-- Primary Meta Tags -->
    <meta name="title" content="Albert - Differential PyTorch Physics Engine for Testing Theories">
    <meta name="description" content="A PyTorch-based physics engine for testing and validating fundamental theories through differentiable simulations.">
    <meta name="keywords" content="physics engine, differential equations, gravitational theories, general relativity, experimental validation, PyTorch physics, differential physics, research tools">
    <meta name="author" content="Albert Project">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://albert.so/">
    <meta property="og:title" content="Albert - Differential PyTorch Physics Engine">
    <meta property="og:description" content="A PyTorch-based physics engine for testing and validating fundamental theories through differentiable simulations.">
    <meta property="og:image" content="https://albert.so/docs/sketch.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:site_name" content="Albert">
    
    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://albert.so/">
    <meta property="twitter:title" content="Albert - Differential PyTorch Physics Engine">
    <meta property="twitter:description" content="A PyTorch-based physics engine for testing and validating fundamental theories through differentiable simulations.">
    <meta property="twitter:image" content="https://albert.so/docs/sketch.png">
    
    <!-- Additional Meta Tags -->
    <meta name="robots" content="index, follow">
    <meta name="language" content="English">
    <meta name="revisit-after" content="7 days">
    <link rel="canonical" href="https://albert.so/">
    
    <!-- Favicon -->
    <link rel="icon" type="image/png" href="sketch.png">
    <link rel="apple-touch-icon" href="sketch.png">
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,700;1,400;1,500;1,700&family=Playfair+Display:ital,wght@0,400;0,700;1,400;1,700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <script type="module">
        import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
        mermaid.initialize({ startOnLoad: true, theme: 'default' });
    </script>
    
    <!-- Tailwind Config -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        'serif': ['EB Garamond', 'Georgia', 'serif'],
                        'display': ['Playfair Display', 'serif'],
                        'mono': ['JetBrains Mono', 'monospace'],
                    },
                    colors: {
                        'white': '#FAF8F3',          // Override white to match paper
                        'ink': '#2D2D2D',           // Dark text
                        'paper': '#FAF8F3',          // Background
                        'accent': '#1A3A8A',         // Deep blue (primary)
                        'muted': '#8B7355',          // Brown (secondary)
                        'success': '#556B2F',        // Olive green (validation)
                        'danger': '#B91C1C',         // Deep red (errors)
                        'warning': '#D97706',        // Amber (in progress)
                        'quantum': '#059669',        // Emerald (quantum tests)
                        'extreme': '#7C3AED',        // Purple (extreme regime)
                        'canvas-bg': '#FAF8F3',      // Canvas backgrounds - same as paper
                        'canvas-stroke': '#E5E7EB',  // Canvas lines
                        'code-bg': '#FAF8F3',        // Code block background - same as paper
                        'code-border': '#E8E2D8',    // Code block border
                    }
                }
            }
        }
    </script>
    
    <style>
        /* Remove Aeonik font-face declarations */
        
        h1, h2, h3, h4, h5, h6 {
            font-family: 'Playfair Display', 'Georgia', serif;
        }
        
        body {
            font-family: 'EB Garamond', 'Georgia', serif;
        }
        
        /* Update formula-display to use new colors */
        .formula-display {
            @apply text-center text-accent bg-paper py-6 px-8 rounded-xl my-6 mx-auto;
            font-family: 'Times New Roman', 'Georgia', serif;
            font-size: 1.4rem;
            width: fit-content;
            min-width: 300px;
            box-shadow: 0 2px 8px rgba(26, 13, 171, 0.08);
            border: 1px solid rgba(26, 58, 138, 0.15);
            position: relative;
        }
        
        /* Update code-block colors */
        .code-block {
            @apply bg-code-bg text-ink border border-code-border;
            padding: 1.5rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.875rem;
            line-height: 1.6;
            white-space: pre-wrap;
        }
        
        .code-block .comment { @apply text-muted; }
        .code-block .string { @apply text-success; }
        .code-block .keyword { @apply text-accent; }
        .code-block .function { @apply text-ink; }
        
        html {
            scroll-behavior: smooth;
        }
        
        @keyframes pulse {
            0%, 100% { 
                opacity: 1; 
            }
            50% { 
                opacity: 0.6; 
            }
        }
        
        .pulse-animation {
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes gravitationalFloat {
            0%, 100% { 
                transform: translateY(0px) scale(1) rotateZ(0deg); 
            }
            20% { 
                transform: translateY(-2px) scale(1.008) rotateZ(0.2deg); 
            }
            40% { 
                transform: translateY(-3px) scale(1.01) rotateZ(-0.1deg); 
            }
            60% { 
                transform: translateY(1px) scale(0.995) rotateZ(0.15deg); 
            }
            80% { 
                transform: translateY(-1px) scale(1.003) rotateZ(-0.1deg); 
            }
        }
        
        @keyframes gravitationalPulse {
            0%, 100% { 
                transform: scale(1); 
                filter: brightness(1);
            }
            50% { 
                transform: scale(1.01); 
                filter: brightness(1.02);
            }
        }
        
        .gravitational-text {
            animation: gravitationalFloat 8s ease-in-out infinite;
        }
        
        .gravitational-pulse {
            animation: gravitationalPulse 4s ease-in-out infinite;
        }
        
        .glow {
            box-shadow: 0 4px 20px rgba(59, 130, 246, 0.3);
        }
        
        .non-interactive {
            pointer-events: none;
        }
        .interactive {
            pointer-events: auto;
        }
        
        body {
            background-color: #FAF8F3; /* colors.paper - Light cream matching sketch background */
        }
        
        /* New animations for the journey */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .animate-fadeIn {
            animation: fadeIn 1s ease-out;
        }
        
        /* Counting animation helper */
        .counting-animation {
            transition: all 2s ease-out;
        }
        
        /* Golden ratio spiral animation */
        @keyframes spiralRotate {
            from {
                transform: rotate(0deg);
            }
            to {
                transform: rotate(360deg);
            }
        }
        
        /* Scroll indicator bounce */
        @keyframes bounce {
            0%, 100% {
                transform: translateY(0);
            }
            50% {
                transform: translateY(-10px);
            }
        }
        
        /* Albert logo frame styling */
        .sketch-frame {
            position: relative;
            background: linear-gradient(135deg, 
                rgba(250, 248, 243, 0.9) 0%, 
                rgba(255, 255, 255, 0.95) 40%, 
                rgba(255, 255, 255, 0.95) 60%, 
                rgba(250, 248, 243, 0.9) 100%);
            box-shadow: 
                inset 0 1px 3px rgba(0, 0, 0, 0.06),
                0 4px 12px rgba(45, 45, 45, 0.08);
        }
        
        .sketch-frame::before {
            content: '';
            position: absolute;
            inset: -1px;
            background: linear-gradient(135deg, 
                transparent 30%, 
                rgba(26, 58, 138, 0.05) 50%, 
                transparent 70%);
            border-radius: 0.75rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .sketch-frame:hover::before {
            opacity: 1;
        }
        
        /* Vintage paper texture overlay */
        .sketch-paper {
            position: relative;
            background: 
                radial-gradient(ellipse at top left, rgba(232, 226, 216, 0.2) 0%, transparent 50%),
                radial-gradient(ellipse at bottom right, rgba(232, 226, 216, 0.2) 0%, transparent 50%),
                white;
            box-shadow: inset 0 1px 4px rgba(0, 0, 0, 0.04);
        }
        
        .sketch-paper::after {
            content: '';
            position: absolute;
            inset: 0;
            background-image: 
                repeating-linear-gradient(45deg, 
                    transparent, 
                    transparent 10px, 
                    rgba(232, 226, 216, 0.03) 10px, 
                    rgba(232, 226, 216, 0.03) 20px);
            border-radius: 0.5rem;
            pointer-events: none;
        }
        
        /* Mobile-specific styles */
        @media (max-width: 768px) {
            /* Hide animated hero section on mobile */
            #home {
                display: none !important;
            }
            
            /* Make Real-Time Theory Testing the first visible section */
            #journey {
                padding-top: 7rem !important; /* Account for nav (64px) + research notice (~48px) */
            }
            
            /* Ensure main content starts below fixed headers */
            main {
                padding-top: 7rem !important; /* Match the journey padding */
            }
            
            /* Fix header navigation on mobile */
            nav {
                padding: 0 0.5rem;
            }
            
            .sketch-frame {
                padding: 0.5rem !important;
            }
            
            .sketch-paper {
                padding: 0.25rem !important;
            }
            
            .sketch-frame img {
                height: 3rem !important;
            }
            
            /* Fix research notice spacing on mobile */
            .research-notice {
                padding: 0.5rem 1rem;
                font-size: 12px;
            }
            
            /* Improve mobile typography */
            h3.text-4xl {
                font-size: 1.875rem !important; /* text-3xl */
            }
            
            h3.text-5xl {
                font-size: 2.25rem !important; /* text-4xl */
            }
            
            .text-lg {
                font-size: 1rem !important;
            }
            
            /* Fix theory testing demo box on mobile */
            .grid.grid-cols-1.lg\\:grid-cols-2 {
                grid-template-columns: 1fr !important;
            }
            
            /* Einstein detail elements on mobile */
            #einstein-asymmetric-detail,
            #einstein-connection-detail,
            #einstein-field-detail {
                font-size: 0.75rem !important;
            }
            
            /* Adjust padding for mobile */
            .px-4, .px-6, .px-8 {
                padding-left: 1rem !important;
                padding-right: 1rem !important;
            }
            
            .py-20 {
                padding-top: 3rem !important;
                padding-bottom: 3rem !important;
            }
            
            /* Fix canvas containers on mobile */
            canvas {
                max-width: 100% !important;
                height: auto !important;
            }
            
            /* Hide non-essential animations on mobile */
            .gravitational-text {
                animation: none !important;
            }
            
            .gravitational-pulse {
                animation: none !important;
            }
            
            /* Fix modal on mobile */
            #setupModal .max-w-3xl {
                max-width: calc(100vw - 2rem) !important;
                margin: 1rem !important;
            }
            
            /* Improve button spacing on mobile */
            .flex.gap-6 {
                gap: 1rem !important;
                flex-direction: column !important;
            }
            
            .w-64 {
                width: 100% !important;
            }
            
            /* Fix code blocks on mobile */
            .code-block, pre {
                font-size: 0.75rem !important;
                padding: 1rem !important;
                white-space: pre-wrap !important;
            }
            

            
            /* Make validation visualizations responsive */
            #validationGauntletCanvas,
            #theoryEngineCanvas {
                height: 300px !important;
            }
        }
        
        /* Additional mobile improvements */
        @media (max-width: 640px) {
            /* Even smaller adjustments for very small screens */
            h3.text-4xl {
                font-size: 1.5rem !important;
            }
            
            h3.text-5xl {
                font-size: 1.875rem !important;
            }
            
            .text-2xl {
                font-size: 1.25rem !important;
            }
            
            /* Stack buttons vertically on very small screens */
            .flex.items-center.justify-center.gap-6 {
                flex-direction: column !important;
            }
            
            /* Full width install command on mobile */
            .max-w-3xl {
                max-width: 100% !important;
            }
        }
    </style>
</head>
<body class="text-ink antialiased bg-paper">

    <!-- Setup Modal -->
    <div id="setupModal" class="fixed inset-0 z-50 hidden">
        <!-- Backdrop -->
        <div class="absolute inset-0 bg-ink/70 backdrop-blur-sm" onclick="closeSetupModal()"></div>
        
        <!-- Modal Content -->
        <div class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-full max-w-3xl max-h-[80vh] overflow-y-auto">
            <div class="bg-paper rounded-2xl p-8 shadow-2xl border border-code-border">
                <!-- Close button -->
                <button onclick="closeSetupModal()" class="absolute top-4 right-4 text-muted hover:text-ink transition">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
                
                <h2 class="text-3xl font-bold text-accent mb-6">Quick Start Installation</h2>
                
                <div class="space-y-6">
                    <!-- One-line install -->
                    <div>
                        <h3 class="text-xl font-bold text-ink mb-2">One-line Installation</h3>
                        <div class="relative group">
                            <div class="bg-code-bg rounded-lg border border-code-border hover:border-accent/50 transition-all overflow-hidden">
                                <div class="flex items-stretch">
                                    <div class="flex-1 p-4">
                                        <code id="modal-install-command" class="text-ink font-mono text-sm break-all select-all">curl -fsSL https://albert.so/install | bash</code>
                                    </div>
                                    <button 
                                        onclick="copyModalCommand()" 
                                        class="px-4 text-muted hover:text-accent hover:bg-accent/5 transition-all group-hover:text-accent border-l border-code-border flex items-center justify-center"
                                        title="Copy to clipboard"
                                    >
                                        <svg id="modal-copy-icon" class="w-5 h-5 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
                                        </svg>
                                        <svg id="modal-check-icon" class="w-5 h-5 hidden text-success flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                                        </svg>
                                    </button>
                                </div>
                            </div>
                            <div id="modal-copy-tooltip" class="absolute -top-10 right-0 bg-ink text-paper text-xs px-3 py-1 rounded opacity-0 pointer-events-none transition-opacity shadow-lg">
                                Copied to clipboard!
                            </div>
                        </div>
                    </div>
                    
                    <!-- Features -->
                    <div class="grid grid-cols-1 sm:grid-cols-3 gap-4">
                        <div class="flex items-center space-x-2">
                            <svg class="w-5 h-5 text-success flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path>
                            </svg>
                            <span class="text-sm text-ink">Pure Python</span>
                        </div>
                        <div class="flex items-center space-x-2">
                            <svg class="w-5 h-5 text-success flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path>
                            </svg>
                            <span class="text-sm text-ink">PyTorch powered</span>
                        </div>
                        <div class="flex items-center space-x-2">
                            <svg class="w-5 h-5 text-success flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path>
                            </svg>
                            <span class="text-sm text-ink">GPU accelerated</span>
                        </div>
                    </div>
                    
                    <!-- Quick Start Commands -->
                    <div>
                        <h3 class="text-xl font-bold text-ink mb-2">Basic Usage</h3>
                        <div class="bg-code-bg border border-code-border rounded-xl p-4 space-y-3 font-mono text-sm">
                            <div>
                                <span class="text-muted"># Run comprehensive evaluation on all theories</span>
                                <div class="text-accent">albert run</div>
                            </div>
                            <div>
                                <span class="text-muted"># Include experimental candidate theories</span>
                                <div class="text-accent">albert run --candidates</div>
                            </div>
                            <div>
                                <span class="text-muted"># Test a specific theory</span>
                                <div class="text-accent">albert run --theory-filter "MyTheory"</div>
                            </div>
                            <div>
                                <span class="text-muted"># Run with extended integration steps</span>
                                <div class="text-accent">albert run --max-steps 10000</div>
                            </div>
                            <div>
                                <span class="text-muted"># Run pre-flight solver validation tests</span>
                                <div class="text-accent">albert run --test</div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Available Commands -->
                    <div>
                        <h3 class="text-xl font-bold text-ink mb-2">Other Commands</h3>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
                            <div class="bg-code-bg/50 border border-code-border/50 rounded-lg p-3">
                                <div class="font-mono text-sm">
                                    <span class="text-accent">albert discover</span>
                                    <p class="text-xs text-muted mt-1">AI-assisted theory generation</p>
                                </div>
                            </div>
                            
                            <div class="bg-code-bg/50 border border-code-border/50 rounded-lg p-3">
                                <div class="font-mono text-sm">
                                    <span class="text-accent">albert setup</span>
                                    <p class="text-xs text-muted mt-1">Configure environment and API keys</p>
                                </div>
                            </div>
                            
                            <div class="bg-code-bg/50 border border-code-border/50 rounded-lg p-3">
                                <div class="font-mono text-sm">
                                    <span class="text-accent">albert validate</span>
                                    <p class="text-xs text-muted mt-1">Test a specific theory file</p>
                                </div>
                            </div>
                            
                            <div class="bg-code-bg/50 border border-code-border/50 rounded-lg p-3">
                                <div class="font-mono text-sm">
                                    <span class="text-accent">albert run-advanced</span>
                                    <p class="text-xs text-muted mt-1">Parameter sweeps and optimization</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Documentation Link -->
                    <div class="mt-6 pt-6 border-t border-code-border text-center">
                        <p class="text-sm text-muted mb-2">For detailed documentation and advanced options:</p>
                        <a href="documentation.html" class="text-accent hover:text-accent/80 font-semibold text-sm inline-flex items-center gap-2">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"></path>
                            </svg>
                            View Full Documentation
                        </a>
                    </div>
                    
                
                </div>
            </div>
        </div>
    </div>

    <!-- Navigation -->
    <nav class="fixed top-0 left-0 right-0 bg-paper/95 backdrop-blur-sm shadow-md z-40">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex items-center justify-between h-16">
                <div class="flex items-center">
                    <div class="sketch-frame p-2 rounded-xl border border-code-border/30 hover:shadow-[0_6px_20px_rgba(26,58,138,0.12)] transition-all duration-300 group">
                        <!-- Inner frame with vintage paper effect -->
                        <div class="sketch-paper rounded-lg p-1.5">
                            <img src="sketch.png" alt="Albert Einstein Sketch" class="h-16 w-auto filter contrast-110 brightness-98 sepia-[0.1] group-hover:contrast-120 group-hover:sepia-[0.15] transition-all duration-300 relative z-10">
                        </div>
                        <!-- Subtle corner accents - like old photo corners -->
                        <div class="absolute top-1 left-1 w-3 h-3 border-t-2 border-l-2 border-accent/15 rounded-tl-lg group-hover:border-accent/25 transition-colors"></div>
                        <div class="absolute top-1 right-1 w-3 h-3 border-t-2 border-r-2 border-accent/15 rounded-tr-lg group-hover:border-accent/25 transition-colors"></div>
                        <div class="absolute bottom-1 left-1 w-3 h-3 border-b-2 border-l-2 border-accent/15 rounded-bl-lg group-hover:border-accent/25 transition-colors"></div>
                        <div class="absolute bottom-1 right-1 w-3 h-3 border-b-2 border-r-2 border-accent/15 rounded-br-lg group-hover:border-accent/25 transition-colors"></div>
                        <!-- Vintage stamp effect on hover -->
                        <div class="absolute -bottom-1 -right-1 opacity-0 group-hover:opacity-100 transition-opacity duration-300">
                            <div class="text-[8px] text-accent/40 font-mono transform rotate-[-5deg]">1955</div>
                        </div>
                    </div>
                </div>
                <div class="hidden md:flex items-center space-x-4">
                    <button onclick="openSetupModal()" class="bg-accent hover:bg-accent/90 text-white px-6 py-2 rounded-lg font-semibold transition shadow-sm">
                        Setup
                    </button>
                    
                    <!-- GitHub with stars -->
                    <a href="https://github.com/pimdewitte/albert" target="_blank" class="group relative flex items-center space-x-2 bg-paper hover:bg-code-bg border border-code-border px-4 py-2 rounded-lg transition shadow-sm">
                        <svg class="w-5 h-5 text-ink" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M12 0c-6.626 0-12 5.373-12 12c0 5.08 3.29 9.39 7.86 10.91.58.11.79-.25.79-.56 0-.28-.01-1.02-.02-2-3.2.7-3.88-1.54-3.88-1.54-.53-1.34-1.3-1.7-1.3-1.7-1.06-.72.08-.71.08-.71 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
                        </svg>
                        <span class="text-sm font-mono text-ink">â˜… 5 (new)</span>
                        <!-- Tooltip -->
                        <span class="absolute -bottom-8 left-1/2 transform -translate-x-1/2 bg-ink text-paper text-xs px-2 py-1 rounded opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none whitespace-nowrap">
                            Star on GitHub
                        </span>
                    </a>
                    
                    <!-- Discord -->
                    <a href="https://discord.gg/tnPhwxr6qZ" target="_blank" class="group relative flex items-center bg-paper hover:bg-code-bg border border-code-border p-2 rounded-lg transition shadow-sm">
                        <svg class="w-5 h-5 text-accent" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M20.317 4.37a19.791 19.791 0 0 0-4.885-1.515a.074.074 0 0 0-.079.037c-.21.375-.444.864-.608 1.25a18.27 18.27 0 0 0-5.487 0a12.64 12.64 0 0 0-.617-1.25a.077.077 0 0 0-.079-.037A19.736 19.736 0 0 0 3.677 4.37a.07.07 0 0 0-.032.027C.533 9.046-.32 13.58.099 18.057a.082.082 0 0 0 .031.057a19.9 19.9 0 0 0 5.993 3.03a.078.078 0 0 0 .084-.028a14.09 14.09 0 0 0 1.226-1.994a.076.076 0 0 0-.041-.106a13.107 13.107 0 0 1-1.872-.892a.077.077 0 0 1-.008-.128a10.2 10.2 0 0 0 .372-.292a.074.074 0 0 1 .077-.01c3.928 1.793 8.18 1.793 12.062 0a.074.074 0 0 1 .078.01c.12.098.246.198.373.292a.077.077 0 0 1-.006.127a12.299 12.299 0 0 1-1.873.892a.077.077 0 0 0-.041.107c.36.698.772 1.362 1.225 1.993a.076.076 0 0 0 .084.028a19.839 19.839 0 0 0 6.002-3.03a.077.077 0 0 0 .032-.054c.5-5.177-.838-9.674-3.549-13.66a.061.061 0 0 0-.031-.03zM8.02 15.33c-1.183 0-2.157-1.085-2.157-2.419c0-1.333.956-2.419 2.157-2.419c1.21 0 2.176 1.096 2.157 2.42c0 1.333-.956 2.418-2.157 2.418zm7.975 0c-1.183 0-2.157-1.085-2.157-2.419c0-1.333.955-2.419 2.157-2.419c1.21 0 2.176 1.096 2.157 2.42c0 1.333-.946 2.418-2.157 2.418z"/>
                        </svg>
                        <!-- Tooltip -->
                        <span class="absolute -bottom-8 left-1/2 transform -translate-x-1/2 bg-ink text-paper text-xs px-2 py-1 rounded opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none whitespace-nowrap">
                            Join Community
                        </span>
                    </a>
                </div>
                <div class="md:hidden flex items-center space-x-2">
                    <button onclick="openSetupModal()" class="bg-accent hover:bg-accent/90 text-white px-4 py-1.5 rounded-lg font-semibold transition shadow-sm text-sm">
                        Setup
                    </button>
                    
                    <!-- GitHub with stars (mobile) -->
                    <a href="https://github.com/pimdewitte/albert" target="_blank" class="flex items-center space-x-1 bg-paper hover:bg-code-bg border border-code-border px-3 py-1.5 rounded-lg transition shadow-sm">
                        <svg class="w-4 h-4 text-ink" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M12 0c-6.626 0-12 5.373-12 12c0 5.08 3.29 9.39 7.86 10.91.58.11.79-.25.79-.56 0-.28-.01-1.02-.02-2-3.2.7-3.88-1.54-3.88-1.54-.53-1.34-1.3-1.7-1.3-1.7-1.06-.72.08-.71.08-.71 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
                        </svg>
                        <span class="text-xs font-mono text-ink">NEW</span>
                    </a>
                    
                    <!-- Discord (mobile) -->
                    <a href="https://discord.gg/tnPhwxr6qZ" target="_blank" class="flex items-center bg-paper hover:bg-code-bg border border-code-border p-1.5 rounded-lg transition shadow-sm">
                        <svg class="w-4 h-4 text-accent" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M20.317 4.37a19.791 19.791 0 0 0-4.885-1.515a.074.074 0 0 0-.079.037c-.21.375-.444.864-.608 1.25a18.27 18.27 0 0 0-5.487 0a12.64 12.64 0 0 0-.617-1.25a.077.077 0 0 0-.079-.037A19.736 19.736 0 0 0 3.677 4.37a.07.07 0 0 0-.032.027C.533 9.046-.32 13.58.099 18.057a.082.082 0 0 0 .031.057a19.9 19.9 0 0 0 5.993 3.03a.078.078 0 0 0 .084-.028a14.09 14.09 0 0 0 1.226-1.994a.076.076 0 0 0-.041-.106a13.107 13.107 0 0 1-1.872-.892a.077.077 0 0 1-.008-.128a10.2 10.2 0 0 0 .372-.292a.074.074 0 0 1 .077-.01c3.928 1.793 8.18 1.793 12.062 0a.074.074 0 0 1 .078.01c.12.098.246.198.373.292a.077.077 0 0 1-.006.127a12.299 12.299 0 0 1-1.873.892a.077.077 0 0 0-.041.107c.36.698.772 1.362 1.225 1.993a.076.076 0 0 0 .084.028a19.839 19.839 0 0 0 6.002-3.03a.077.077 0 0 0 .032-.054c.5-5.177-.838-9.674-3.549-13.66a.061.061 0 0 0-.031-.03zM8.02 15.33c-1.183 0-2.157-1.085-2.157-2.419c0-1.333.956-2.419 2.157-2.419c1.21 0 2.176 1.096 2.157 2.42c0 1.333-.956 2.418-2.157 2.418zm7.975 0c-1.183 0-2.157-1.085-2.157-2.419c0-1.333.955-2.419 2.157-2.419c1.21 0 2.176 1.096 2.157 2.42c0 1.333-.946 2.418-2.157 2.418z"/>
                        </svg>
                    </a>
                </div>
            </div>
        </div>
    </nav>

    <!-- Research Preview Notice -->
    <div class="research-notice fixed top-16 left-0 right-0 bg-warning/10 border-b border-warning/20 py-3 px-4 sm:px-6 lg:px-8 z-30" style="background: linear-gradient(135deg, rgba(250, 248, 243, 0.95) 0%, rgba(250, 248, 243, 0.92) 30%, rgba(250, 248, 243, 0.94) 70%, rgba(250, 248, 243, 0.95) 100%), linear-gradient(rgba(251, 191, 36, 0.25), rgba(251, 191, 36, 0.25)) !important; border: none !important; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12), inset 0 1px 0 rgba(255, 255, 255, 0.25), inset 0 -1px 0 rgba(0, 0, 0, 0.05) !important;">
        <div class="max-w-7xl mx-auto flex items-center justify-center gap-3">
            <svg class="w-5 h-5 text-warning flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"/>
            </svg>
            <p class="text-sm text-ink font-medium text-center">
                <strong>Research Preview:</strong> This is an early research preview of Albert. While the code is openly available, it has only been shared with a select group of researchers and early testers.
            </p>
        </div>
    </div>



    <!-- Main Content -->
    <main class="pt-16 md:pt-16">
        
        <!-- Mobile-only content wrapper -->
        <div class="block md:hidden">
            <!-- This div ensures proper spacing on mobile when animated section is hidden -->
        </div>
        
        <!-- Homepage Section with Spacetime Background -->
        <section id="home" class="min-h-screen flex items-center justify-center px-4 sm:px-6 lg:px-8 relative overflow-hidden">
            <!-- Spacetime Curvature Visualization Background -->
            <canvas id="spacetimeCanvas" class="absolute inset-0 w-full h-full z-0" style="cursor: crosshair;"></canvas>
            
            <div class="max-w-7xl mx-auto text-center relative z-10 non-interactive">
                
                <h1 class="text-4xl sm:text-6xl lg:text-8xl font-bold mb-8 fade-in font-display">
                    <span class="text-accent">Introducing Albert</span>
                    <span class="text-muted block text-2xl sm:text-3xl lg:text-4xl mt-4">  A Differential PyTorch Physics Research Engine </span>
                </h1>
                
    
                     <!-- Quick Start One-Line Setup (Trustworthy Professional Design) -->
                <div class="bg-paper rounded-2xl p-8 mb-12 max-w-3xl mx-auto shadow-lg border border-muted/20 gravitational-text interactive" style="padding: 2rem 3.236rem; animation-delay: 1.5s; animation-duration: 10s;">
                    <div class="flex items-center justify-between mb-6">
                   
                        <div class="flex items-center space-x-3">
                            <svg class="w-5 h-5 text-accent" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M2.166 4.999A11.954 11.954 0 0010 1.944 11.954 11.954 0 0017.834 5c.11.65.166 1.32.166 2.001 0 5.225-3.34 9.67-8 11.317C5.34 16.67 2 12.225 2 7c0-.682.057-1.35.166-2.001zm11.541 3.708a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path>
                            </svg>
                            <span class="text-sm text-muted font-medium">Albert is 100% open source and you can audit everything you're installing!</span>
                        </div>
                    </div>
                    
                    <div class="relative group">
                        <div class="bg-code-bg rounded-lg border border-code-border hover:border-accent/50 transition-all overflow-hidden">
                            <div class="flex items-stretch">
                                <div class="flex-1 p-3 sm:p-4 space-y-1">
                                    <div id="homepage-install-command" class="font-mono text-base sm:text-lg whitespace-nowrap">
                                        <span class="select-all"><span class="text-accent">curl -fsSL</span> <span class="text-ink">https://albert.so/install</span> <span class="text-muted">| bash</span></span>
                                    </div>
                                </div>
                                <button 
                                    onclick="copyHomepageCommand()" 
                                    class="px-4 text-muted hover:text-accent hover:bg-accent/5 transition-all group-hover:text-accent border-l border-code-border flex items-center justify-center"
                                    title="Copy to clipboard"
                                >
                                    <svg id="homepage-copy-icon" class="w-5 h-5 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
                                    </svg>
                                    <svg id="homepage-check-icon" class="w-5 h-5 hidden text-success flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                                    </svg>
                                </button>
                            </div>
                        </div>
                        
                        <!-- Tooltip -->
                        <div id="homepage-copy-tooltip" class="absolute -top-10 right-0 bg-ink text-paper text-xs px-3 py-1 rounded opacity-0 pointer-events-none transition-opacity shadow-lg">
                            Copied to clipboard!
                        </div>
                    </div>
                    
                    <!-- Trust indicators -->
                    <div class="mt-6 grid grid-cols-1 sm:grid-cols-3 gap-4" style="gap: 1.618rem;">
                        <div class="flex items-center space-x-2">
                            <svg class="w-5 h-5 text-success flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path>
                            </svg>
                            <span class="text-sm text-ink">PyTorch Based</span>
                        </div>
                        <div class="flex items-center space-x-2">
                            <svg class="w-5 h-5 text-success flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path>
                            </svg>
                            <span class="text-sm text-ink">Optional GPU Acceleration</span>
                        </div>
                        <div class="flex items-center space-x-2">
                            <svg class="w-5 h-5 text-success flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
                                <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"></path>
                            </svg>
                            <span class="text-sm text-ink">No root required</span>
                        </div>
                    </div>
                    
                    <!-- Additional trust elements -->
                    <div class="mt-6 pt-6 border-t border-code-border flex items-center justify-between">
                        <div class="flex items-center space-x-4">
                            <a href="https://github.com/pimdewitte/albert" class="text-sm text-accent hover:text-accent/80 flex items-center space-x-1">
                                <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24">
                                    <path d="M12 .5C5.73.5.5 5.73.5 12c0 5.08 3.29 9.39 7.86 10.91.58.11.79-.25.79-.56 0-.28-.01-1.02-.02-2-3.2.7-3.88-1.54-3.88-1.54-.53-1.34-1.3-1.7-1.3-1.7-1.06-.72.08-.71.08-.71 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
                                </svg>
                                <span>View source code</span>
                            </a>
                    
            
                        </div>
                        <div class="flex items-center space-x-2">
                            <span class="text-xs text-muted">Latest version: v1.2.0</span>
                        </div>
                    </div>
                </div>
                
                <div class="flex items-center justify-center gap-6 mt-8">
                    <a href="documentation.html" 
                       class="bg-accent hover:bg-accent/90 text-white text-lg px-6 py-3 rounded-lg font-semibold transition transform hover:scale-105 shadow-sm interactive w-64 h-14 flex items-center justify-center gap-2">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 17v-2m3 2v-4m3 4v-6m2 10H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                        </svg>
                        View Docs
                    </a>
                    <a href="https://albert.so/latest_run/trajectory_viewers/unified_multi_particle_viewer_advanced.html" 
                       class="bg-quantum hover:bg-quantum/90 text-white text-lg px-6 py-3 rounded-lg font-semibold transition transform hover:scale-105 shadow-sm interactive w-64 h-14 flex items-center justify-center gap-2">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 01-9 9m9-9a9 9 0 00-9-9m9 9H3m9 9a9 9 0 01-9-9m9 9c1.657 0 3-4.03 3-9s-1.343-9-3-9m0 18c-1.657 0-3-4.03-3-9s1.343-9 3-9m-9 9a9 9 0 019-9"></path>
                        </svg>
                         3D Visualizer
                    </a>
                </div>
                

                
                
            </div>
        </section>

        <!-- The Emotional Journey Begins -->
        <section id="journey" class="relative">
                    <!-- Chapter 2: Real-Time Theory Testing -->
        <div class="min-h-screen px-4 sm:px-6 lg:px-8 relative overflow-hidden bg-paper pt-8 md:pt-0">
                <div class="max-w-7xl mx-auto">
                    
                    <!-- Section Header -->
                    <div class="text-center mb-8 md:mb-12">
                        <h3 class="text-5xl sm:text-6xl lg:text-5xl font-display font-bold text-accent mb-4 md:mb-6">
                           A simulator just for physics research
                        </h3>
                    </div>
                    
                    <!-- CLI Demo Video -->
                    <div class="mb-16 max-w-7xl mx-auto">
                        <div class="relative bg-gradient-to-br from-accent/5 to-quantum/5 rounded-3xl p-1 shadow-2xl">
                            <div class="bg-black rounded-3xl overflow-hidden">
                                <!-- Terminal-style header -->
                                <div class="bg-gray-800 px-4 py-2 flex items-center gap-2">
                                    <div class="flex gap-1.5">
                                        <div class="w-3 h-3 bg-red-500 rounded-full"></div>
                                        <div class="w-3 h-3 bg-yellow-500 rounded-full"></div>
                                        <div class="w-3 h-3 bg-green-500 rounded-full"></div>
                                    </div>
                                    <span class="text-gray-400 text-sm font-mono ml-2">albert demo</span>
                                </div>
                                <!-- Video container with 2.33:1 aspect ratio -->
                                <div class="relative" style="padding-bottom: 42.9%;">
                                    <video 
                                        id="demoVideo"
                                        class="absolute inset-0 w-full h-full"
                                        src="demo.mp4"
                                        muted
                                        loop
                                        playsinline
                                        preload="metadata"
                                        controls
                                    >
                                        Your browser does not support the video tag.
                                    </video>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Theory Engine Visualization - Full Width -->
                    <div class="mb-20">
                        <div class="bg-white rounded-3xl shadow-2xl p-4 md:p-8 border border-code-border/30">
                            <canvas id="theoryEngineCanvas" width="1200" height="800" class="w-full"></canvas>
                        </div>
                     
                    </div>

                </div>
            </section>
            
    


            <!-- Chapter 6: A Validation Framework for Fundamental Physics -->
            <div class="px-4 sm:px-6 lg:px-8 py-20 relative overflow-hidden bg-paper">
                <div class="container mx-auto">
                    <h2 class="text-4xl lg:text-6xl font-display font-bold text-center text-accent mb-12">
                         Bringing fundamental physics into code space
                    </h2>
                    
                    <!-- Two Column Layout: Text and Video -->
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-12 items-center max-w-7xl mx-auto mb-16">
                        <!-- Text Content -->
                        <div class="space-y-6">
                            <p class="text-xl font-serif text-ink leading-relaxed">
                                AlphaFold succeeded by creating specialized environments for training on protein structures. 
                                Albert provides analogous infrastructure for physicsâ€”leveraging PyTorch as the computational foundation. 
                                Express your theory as codeâ€”metric tensors and field equationsâ€”and Albert's solvers transform these 
                                mathematical laws into differentiable computations. This extends PyTorch into a platform for physics 
                                simulation, where Lagrangians can be implemented as differentiable operations yielding executable dynamics.
                            </p>
                            
                            <p class="text-xl font-serif text-ink leading-relaxed">
                                The differentiable nature enables theories to learn from their own simulations through gradient-based 
                                optimization. By providing this integrated infrastructure, Albert reduces the barrier to developing 
                                physics learning systems, allowing researchers to focus on innovation rather than building validation 
                                pipelines from scratch.
                            </p>
                        </div>
                        
                        <!-- 3D Video -->
                        <div class="relative">
                            <div class="bg-white rounded-3xl shadow-2xl p-4 border border-accent/20 overflow-hidden">
                                <video 
                                    class="w-full h-auto rounded-2xl"
                                    autoplay 
                                    loop 
                                    muted 
                                    playsinline
                                    controls
                                >
                                    <source src="3d.mp4" type="video/mp4">
                                    Your browser does not support the video tag.
                                </video>
                            </div>
                            <div class="absolute -z-10 top-8 right-8 w-full h-full bg-gradient-to-br from-quantum/20 to-accent/20 rounded-3xl blur-3xl"></div>
                        </div>
                    </div>

                    
                    <!-- Energy Calculation Example -->
                    <div class="bg-white rounded-3xl shadow-xl p-8 border border-accent/10 max-w-6xl mx-auto mt-12">
                        <h3 class="text-2xl font-bold text-accent mb-6">Example: How Energy Conservation Validation Works</h3>
                        <p class="text-lg font-serif text-ink mb-6">
                            Here's a concrete example of how validators analyze solver output to verify physical conservation laws:
                        </p>
                        <div class="bg-paper rounded-2xl p-6 border border-code-border overflow-x-auto">
                            <div class="mermaid">
graph LR
    subgraph Input["Input Data"]
        Traj["Trajectory<br/>(t, r, Ï†)"]
        Theory["Theory<br/>(Metric g_Î¼Î½)"]
    end
    
    subgraph EnergyCalc["Energy Calculation at Each Point"]
        Vel["Velocity Components<br/>u_t = dt/dÏ„<br/>u_Ï† = dÏ†/dÏ„"]
        Metric["Metric Components<br/>g_tt, g_tp, g_pp"]
        Energy["Energy<br/>E = -(g_ttÂ·u_t + g_tpÂ·u_Ï†)"]
        Vel --> Energy
        Metric --> Energy
    end
    
    subgraph Analysis["Statistical Analysis"]
        Mean["Mean Energy<br/>Î¼(E)"]
        StdDev["Std Deviation<br/>Ïƒ(E)"]
        Error["Relative Error<br/>Îµ = Ïƒ(E)/|Î¼(E)|"]
        Mean --> Error
        StdDev --> Error
    end
    
    subgraph Comparison["Theory Comparison"]
        T1["Theory A<br/>Îµ = 1e-7<br/>âœ“ PASS"]
        T2["Theory B<br/>Îµ = 1e-4<br/>âœ“ PASS"]
        T3["Theory C<br/>Îµ = 0.1<br/>âœ— FAIL"]
        Rank["Ranking:<br/>A > B > C"]
        T1 --> Rank
        T2 --> Rank
        T3 --> Rank
    end
    
    Traj --> Vel
    Theory --> Metric
    Energy --> Mean
    Energy --> StdDev
    Error --> T1
    Error --> T2
    Error --> T3
    
    classDef inputBox fill:#e8f5e9,stroke:#2e7d32,stroke-width:2px
    classDef calcBox fill:#e3f2fd,stroke:#1976d2,stroke-width:2px
    classDef analysisBox fill:#fff3e0,stroke:#f57c00,stroke-width:2px
    classDef passBox fill:#c8e6c9,stroke:#388e3c,stroke-width:2px
    classDef failBox fill:#ffcdd2,stroke:#d32f2f,stroke-width:2px
    
    class Traj,Theory inputBox
    class Vel,Metric,Energy calcBox
    class Mean,StdDev,Error analysisBox
    class T1,T2 passBox
    class T3 failBox
                                    </div>
                                </div>
                        <p class="text-base text-muted mt-4 italic text-center">
                            The validator continuously monitors conserved quantities throughout the trajectory, 
                            ensuring numerical integration preserves the physics
                        </p>
                        </div>
                    
                    <!-- Live Validation Visualization -->
                    <div class="max-w-7xl mx-auto mt-12">
                        <div class="bg-white rounded-3xl shadow-2xl p-8 mb-12">
                            <canvas id="validationGauntletCanvas" width="1200" height="400" class="w-full"></canvas>
                        </div>
                    </div>
                  
                </div>
            </div>



             <!-- Chapter 5: The Theory Engine -->
             <div class="min-h-screen px-4 sm:px-6 lg:px-8 py-20 relative overflow-hidden bg-paper">
                <div class="max-w-7xl mx-auto">
                   
                  
                    
                    <!-- Section 1: Standard Model Support (Expandable) -->
                    <div class="mb-20">
                        <div class="max-w-5xl mx-auto">
                            <!-- Collapsible Header -->
                            <div class="bg-gradient-to-r from-quantum/5 to-accent/5 rounded-2xl shadow-lg border border-quantum/20 overflow-hidden">
                                <button onclick="toggleStandardModelSection()" class="w-full px-8 py-6 flex items-center justify-between hover:bg-quantum/5 transition-colors group">
                                    <div class="flex items-center gap-4">
                                        <h4 class="text-3xl font-bold text-quantum">Standard Model Integration</h4>
                                        <div class="flex items-center space-x-2 bg-warning/10 border border-warning/30 rounded-lg px-3 py-1">
                                            <svg class="w-4 h-4 text-warning" fill="currentColor" viewBox="0 0 20 20">
                                                <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"/>
                                            </svg>
                                            <span class="text-xs font-medium text-ink">Experimental Quantum Features</span>
                                        </div>
                                    </div>
                                    <div class="flex items-center gap-3">
                                        <span class="text-sm text-muted group-hover:text-quantum transition-colors">
                                            Click to explore quantum-gravity interface
                                        </span>
                                        <svg id="sm-chevron" class="w-6 h-6 text-quantum transform transition-transform duration-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                                        </svg>
                                    </div>
                                </button>
                                
                                <!-- Collapsible Content -->
                                <div id="sm-content" class="overflow-hidden transition-all duration-500" style="max-height: 0;">
                                    <div class="px-8 py-6 bg-gradient-to-b from-transparent to-quantum/5">
                                        <div class="bg-white rounded-2xl shadow-lg p-8 border border-code-border mb-8">
                                            <h5 class="text-2xl font-bold text-accent mb-4">Technical Implementation</h5>
                                            <p class="text-lg font-serif text-ink mb-4">
                                                Albert embeds the complete Standard Model physics through QED Lagrangians, 
                                                enabling precision tests at the quantum-gravitational interface. Every theory 
                                                must couple correctly to fermions and gauge bosons.
                                            </p>

                                            
                                            <!-- Real Implementation Example: Kerr -->
                                            <div class="mt-6">
                                                <h5 class="text-xl font-bold text-success mb-4">Real Implementation: Kerr Black Holes</h5>
                                                <pre class="text-xs font-mono overflow-x-auto bg-code-bg rounded-lg p-4 border border-code-border">
<span class="text-accent">from</span> physics_agent.theories.kerr <span class="text-accent">import</span> KerrMetric

<span class="text-accent">class</span> <span class="text-warning">KerrMetric</span>(<span class="text-warning">GravitationalTheory</span>):
    <span class="text-muted">"""Rotating black hole solution with angular momentum"""</span>
    
    <span class="text-accent">def</span> <span class="text-success">get_metric</span>(self, r, theta, M, a):
        <span class="text-muted"># Kerr metric in Boyer-Lindquist coordinates</span>
        rs = 2 * G * M / c**2
        rho2 = r**2 + a**2 * cos(theta)**2
        delta = r**2 - rs * r + a**2
        sigma2 = (r**2 + a**2)**2 - a**2 * delta * sin(theta)**2
        
        <span class="text-muted"># Metric components (diagonal + frame-dragging)</span>
        g_tt = -(1 - rs * r / rho2)
        g_rr = rho2 / delta  
        g_Î¸Î¸ = rho2
        g_Ï†Ï† = sigma2 * sin(theta)**2 / rho2
        g_tÏ† = -rs * r * a * sin(theta)**2 / rho2  <span class="text-muted"># Frame-dragging!</span>
        
        <span class="text-accent">return</span> g_tt, g_rr, g_Î¸Î¸, g_Ï†Ï†, g_tÏ†

<span class="text-muted"># Test extreme Kerr (a = 0.998M) against observations</span>
kerr = <span class="text-warning">KerrMetric</span>()
results = kerr.validate_black_hole_shadow(M87_data)
<span class="text-accent">assert</span> results['shadow_radius'] == 42.0 Â± 3.0  <span class="text-success">âœ“ Î¼as</span>
<span class="text-accent">assert</span> results['asymmetry'] < 0.1             <span class="text-success">âœ“</span>
<span class="text-accent">assert</span> results['ISCO_radius'] == 1.235 * rs   <span class="text-success">âœ“</span>
                                                </pre>
                                            </div>
                                            
                                            <!-- Experimental Quantum Features -->
                                            <div class="mt-8 bg-warning/10 rounded-lg p-4 border border-warning/30">
                                                <h5 class="text-lg font-bold text-warning mb-3">âš ï¸ Experimental: Quantum Corrections</h5>
                                                <p class="text-sm text-ink mb-4">
                                                    The following features are experimental and may change. They represent ongoing research
                                                    into quantum gravity effects near black holes.
                                                </p>
                                                <pre class="text-xs font-mono overflow-x-auto bg-code-bg rounded-lg p-4 border border-code-border">
<span class="text-muted"># EXPERIMENTAL: Quantum corrections to Kerr metric</span>
<span class="text-accent">from</span> physics_agent.quantum.corrections <span class="text-accent">import</span> HawkingRadiation, QuantumHorizon

<span class="text-accent">class</span> <span class="text-warning">QuantumKerr</span>(<span class="text-warning">KerrMetric</span>):
    <span class="text-muted">"""Kerr metric with quantum gravity corrections (EXPERIMENTAL)"""</span>
    
    <span class="text-accent">def</span> <span class="text-success">__init__</span>(self, enable_hawking=True, quantum_hair=False):
        super().__init__()
        self.â„ = 1.054571817e-34  <span class="text-muted"># Planck's constant</span>
        self.l_p = torch.sqrt(self.â„ * G / c**3)  <span class="text-muted"># Planck length</span>
        
    <span class="text-accent">def</span> <span class="text-success">get_quantum_corrections</span>(self, r, M, a):
        <span class="text-muted"># Quantum corrections near horizon (r â†’ r+)</span>
        r_plus = M + torch.sqrt(M**2 - a**2)
        
        <span class="text-muted"># Leading order quantum correction</span>
        Î´g_tt = self.â„ / (M * r**3) * torch.exp(-(r - r_plus) / self.l_p)
        
        <span class="text-muted"># Hawking temperature</span>
        Îº = (r_plus - M) / (2 * M * r_plus)  <span class="text-muted"># Surface gravity</span>
        T_H = self.â„ * Îº / (2 * Ï€ * k_B)     <span class="text-muted"># ~ 10^-8 K for stellar BH</span>
        
        <span class="text-accent">return</span> Î´g_tt, T_H

<span class="text-muted"># WARNING: These corrections are ~ 10^-70 for astrophysical black holes!</span>
<span class="text-muted"># Only potentially observable for primordial black holes with M ~ 10^15 g</span>
                                                </pre>
                                            </div>
                                            
                                            <p class="text-sm text-muted mt-6 mb-4">
                                                Standard Model integration allows testing unified theories against QED precision 
                                                measurements with up to 13 significant figures of accuracy. Quantum gravity effects
                                                remain orders of magnitude below current observational thresholds.
                                            </p>
                                            
                                            <!-- Quantum Validator Spotlight - Atomic Clock Test -->
                                            <div class="mt-8">
                                                <div class="bg-gradient-to-r from-quantum/10 to-accent/10 rounded-3xl p-1">
                                                    <div class="bg-white rounded-3xl p-8 md:p-12">
                                                        <h4 class="text-3xl font-bold text-center mb-12 bg-gradient-to-r from-quantum to-accent bg-clip-text text-transparent">
                                                            Quantum Precision: The Atomic Clock Test
                                                        </h4>
                                                        
                                                        <div class="grid grid-cols-1 lg:grid-cols-2 gap-12 items-center">
                                                            <div class="order-2 lg:order-1">
                                                                <div class="space-y-6">
                                                                    <p class="text-xl font-serif text-ink leading-relaxed">
                                                                        Optical atomic clocks are humanity's most precise instruments. In 2018, 
                                                                        scientists measured time's flow between two clocks just 33 cm apart.
                                                                    </p>
                                                                    
                                                                    <!-- Interactive measurement display -->
                                                                    <div class="group bg-gradient-to-br from-code-bg to-paper rounded-2xl p-6 border border-code-border/50 hover:border-quantum/50 transition-all cursor-pointer" onclick="toggleClockDetails()">
                                                                        <div class="flex items-center justify-between mb-4">
                                                                            <h5 class="font-bold text-lg">Experimental Parameters</h5>
                                                                            <div class="text-quantum text-sm">Hover for details</div>
                                                                        </div>
                                                                        
                                                                        <div class="grid grid-cols-2 gap-4">
                                                                            <div class="bg-white/50 rounded-lg p-3 group-hover:bg-white/80 transition-colors">
                                                                                <div class="text-2xl font-mono font-bold text-accent">1.121</div>
                                                                                <div class="text-sm text-muted">PHz frequency</div>
                                                                            </div>
                                                                            <div class="bg-white/50 rounded-lg p-3 group-hover:bg-white/80 transition-colors">
                                                                                <div class="text-2xl font-mono font-bold text-quantum">0.33</div>
                                                                                <div class="text-sm text-muted">meters apart</div>
                                                                            </div>
                                                                        </div>
                                                                        
                                                                        <div id="clock-details" class="mt-4 overflow-hidden transition-all duration-300" style="max-height: 0;">
                                                                            <div class="pt-4 border-t border-code-border/30">
                                                                                <div class="bg-success/10 rounded-lg p-3 mb-3">
                                                                                    <div class="text-sm font-mono text-success">âœ“ Measured: (3.61 Â± 1.60) Ã— 10â»Â¹â·</div>
                                                                                </div>
                                                                                <p class="text-sm text-muted">
                                                                                    This measurement tests gravitational time dilation with 
                                                                                    extraordinary precisionâ€”demonstrating the framework's ability to validate theories against cutting-edge experiments.
                                                                                </p>
                                                                            </div>
                                                                        </div>
                                                                    </div>
                                                                    
                                                                    <div class="bg-warning/10 border border-warning/30 rounded-xl p-4">
                                                                        <p class="text-sm font-medium text-warning mb-1">Why This Matters</p>
                                                                        <p class="text-sm text-ink">
                                                                            Every theory must predict this shift to 17 decimal places, 
                                                                            testing where Einstein meets quantum mechanics.
                                                                        </p>
                                                                    </div>
                                                                </div>
                                                            </div>
                                                            
                                                            <div class="order-1 lg:order-2 flex justify-center">
                                                                <div class="bg-code-bg rounded-2xl p-4 shadow-lg border border-code-border/50">
                                                                    <canvas id="quantumValidatorCanvas" width="450" height="350" class="w-full max-w-md"></canvas>
                                                                </div>
                                                            </div>
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                            
                                            <a href="documentation.html" target="_blank" class="inline-flex items-center space-x-2 bg-accent hover:bg-accent/90 text-white px-4 py-2 rounded-lg font-semibold transition shadow-sm mt-8">
                                                <span>View Documentation</span>
                                                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"></path>
                                                </svg>
                                            </a>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Section 2: UnifiedGaugeModel Support -->
                    <div class="mb-20">
                        <div class="max-w-5xl mx-auto">
                            <!-- Collapsible Header -->
                            <div class="bg-gradient-to-r from-accent/5 to-quantum/5 rounded-2xl shadow-lg border border-accent/20 overflow-hidden">
                                <button onclick="toggleUGMSection()" class="w-full px-8 py-6 flex items-center justify-between hover:bg-accent/5 transition-colors group">
                                    <div class="flex items-center gap-4">
                                        <h4 class="text-3xl font-bold text-accent">Unified Gauge Model (UGM)</h4>
                                        <div class="flex items-center space-x-2 bg-warning/10 border border-warning/30 rounded-lg px-3 py-1">
                                            <svg class="w-4 h-4 text-warning" fill="currentColor" viewBox="0 0 20 20">
                                                <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"/>
                                            </svg>
                                            <span class="text-xs font-medium text-ink">Experimental</span>
                                        </div>
                                    </div>
                                    <div class="flex items-center gap-3">
                                        <span class="text-sm text-muted group-hover:text-accent transition-colors">
                                            Click to explore
                                        </span>
                                        <svg id="ugm-chevron" class="w-6 h-6 text-accent transform transition-transform duration-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                                        </svg>
                                    </div>
                                </button>
                                
                                <!-- Collapsible Content -->
                                <div id="ugm-content" class="overflow-hidden transition-all duration-500" style="max-height: 0;">
                                    <div class="px-8 py-6 bg-gradient-to-b from-transparent to-accent/5">
                                        <p class="text-center text-sm font-medium text-ink mb-8">
                                            To use UGM theories, run with <code class="bg-code-bg px-2 py-1 rounded text-warning">--category ugm</code>
                                        </p>
                        
                        <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 max-w-7xl mx-auto mb-12">
                            <!-- The Inspiration -->
                            <div class="bg-gradient-to-br from-accent/10 to-quantum/10 rounded-2xl shadow-lg p-8 border border-accent/30">
                                <h5 class="text-2xl font-bold text-accent mb-4">The Geodesic Solver Genesis</h5>
                                <p class="text-lg font-serif text-ink mb-4">
                                    In 2025, Partanen & Tulkki published 
                                    <a href="https://aaltodoc.aalto.fi/items/a2fbfa61-7480-437b-ab12-9773d8070a98" target="_blank" class="text-accent hover:text-accent/80 underline">
                                        "Gravity generated by four one-dimensional unitary gauge symmetries"
                                    </a>. Their insight: gravity isn't one force, but four U(1) gauge fields working together.
                                </p>
                                <p class="text-lg font-serif text-ink mb-4">
                                    This paper inspired our geodesic solver architecture. The UGMGeodesicRK4Solver 
                                    implements their tetrad formalism exactly.
                                </p>
                                <div class="bg-white/80 rounded-lg p-4 border border-accent/20">
                                    <p class="text-sm font-mono">
                                        e^a_Î¼ = Î´^a_Î¼ + g H^a_Î¼<br/>
                                        g_Î¼Î½ = Î·_ab e^a_Î¼ e^b_Î½
                                    </p>
                                    <p class="text-xs text-muted mt-2">Tetrads build spacetime from gauge fields</p>
                                </div>
                            </div>
                            
                            <!-- Technical Details -->
                            <div class="bg-white rounded-2xl shadow-lg p-8 border border-code-border">
                                <h5 class="text-2xl font-bold text-success mb-4">Four U(1) Implementation</h5>
                                
                                <div class="space-y-3 mb-4">
                                    <div class="flex items-center gap-3">
                                        <div class="w-12 h-12 bg-accent/20 rounded-lg flex items-center justify-center font-bold">Hâ°</div>
                                        <div>
                                            <div class="font-bold">Time U(1)</div>
                                            <div class="text-sm text-muted">Generates gravitational time dilation</div>
                                        </div>
                                    </div>
                                    <div class="flex items-center gap-3">
                                        <div class="w-12 h-12 bg-quantum/20 rounded-lg flex items-center justify-center font-bold">HÂ¹</div>
                                        <div>
                                            <div class="font-bold">Radial U(1)</div>
                                            <div class="text-sm text-muted">Creates spatial curvature</div>
                                        </div>
                                    </div>
                                    <div class="flex items-center gap-3">
                                        <div class="w-12 h-12 bg-warning/20 rounded-lg flex items-center justify-center font-bold">HÂ²</div>
                                        <div>
                                            <div class="font-bold">Theta U(1)</div>
                                            <div class="text-sm text-muted">Angular momentum coupling</div>
                                        </div>
                                    </div>
                                    <div class="flex items-center gap-3">
                                        <div class="w-12 h-12 bg-success/20 rounded-lg flex items-center justify-center font-bold">HÂ³</div>
                                        <div>
                                            <div class="font-bold">Phi U(1)</div>
                                            <div class="text-sm text-muted">Frame-dragging effects</div>
                                        </div>
                                    </div>
                                </div>
                                
                                <p class="text-sm text-muted">
                                    Each U(1) has its own coupling Î±_a. When all Î±'s equal 1, 
                                    we recover General Relativity exactly.
                                </p>
                            </div>
                        </div>
                        
                        <!-- UGM Implementation -->
                        <div class="bg-code-bg rounded-2xl shadow-lg p-8 border border-code-border max-w-5xl mx-auto">
                            <h5 class="text-xl font-bold text-success mb-4">UGM Implementation in Albert</h5>
                            <pre class="text-xs font-mono overflow-x-auto">
<span class="text-accent">import</span> torch
<span class="text-accent">import</span> sympy <span class="text-accent">as</span> sp
<span class="text-accent">from</span> physics_agent.base_theory <span class="text-accent">import</span> GravitationalTheory
<span class="text-accent">from</span> physics_agent.constants <span class="text-accent">import</span> get_symbol, G, c

<span class="text-accent">class</span> <span class="text-warning">UnifiedGaugeModel</span>(<span class="text-warning">GravitationalTheory</span>):
    <span class="text-muted">"""
    Unified Gauge Model (UGM) from Partanen & Tulkki (2025).
    
    <reason>chain: Gravity emerges from four U(1) gauge symmetries, one for each tetrad index</reason>
    <reason>chain: Fully renormalizable and integrates seamlessly with Standard Model</reason>
    """</span>
    
    category = <span class="text-string">"ugm"</span>
    
    <span class="text-accent">def</span> <span class="text-success">__init__</span>(self, alpha0=1.0, alpha1=1.0, alpha2=1.0, alpha3=1.0, g_coupling=0.1):
        <span class="text-muted"># <reason>chain: Store the four U(1) couplings</reason></span>
        self.alphas = torch.tensor([alpha0, alpha1, alpha2, alpha3], dtype=torch.float64)
        self.g = g_coupling
        
        <span class="text-muted"># <reason>chain: Build the gravitational Lagrangian from four U(1) sectors</reason></span>
        <span class="text-muted"># L_grav = -1/4 Î£_a Î±_a F^a_Î¼Î½ F^a^Î¼Î½</span>
        gravity_lagrangian = 0
        <span class="text-accent">for</span> a <span class="text-accent">in</span> range(4):
            F_a = get_symbol(f'F^{a}_Î¼Î½')  <span class="text-muted"># Field strength for U(1)_a</span>
            gravity_lagrangian -= sp.Rational(1, 4) * get_symbol(f'Î±_{a}') * F_a * get_symbol(f'F^{a}^Î¼Î½')
        
        <span class="text-muted"># <reason>chain: Mark as needing UGM solver for proper tetrad handling</reason></span>
        self.use_ugm_solver = True
    
    <span class="text-accent">def</span> <span class="text-success">initialize_gauge_fields</span>(self, r: Tensor, theta: Tensor = None, phi: Tensor = None) -> Tensor:
        <span class="text-muted">"""
        Initialize the four U(1) gauge fields H^a_Î¼.
        
        <reason>chain: Use weak-field approximation around spherical mass</reason>
        <reason>chain: H^0_0 generates time dilation, H^i_i generates spatial curvature</reason>
        """</span>
        H = torch.zeros((4, 4) + r.shape, device=r.device, dtype=r.dtype)
        
        <span class="text-muted"># <reason>chain: Weak-field limit around spherical mass M</reason></span>
        rs = 2.0  <span class="text-muted"># Schwarzschild radius in geometric units</span>
        
        <span class="text-muted"># <reason>chain: Time component generates gravitational time dilation</reason></span>
        H[0, 0] = rs / (2 * r)  <span class="text-muted"># This gives e^0_0 â‰ˆ 1 + g*rs/(2r) when g is small</span>
        
        <span class="text-muted"># <reason>chain: Radial component generates spatial curvature</reason></span>
        H[1, 1] = -rs / (2 * r)  <span class="text-muted"># This gives e^1_1 â‰ˆ 1 - g*rs/(2r) when g is small</span>
        
        <span class="text-accent">return</span> H
        
    <span class="text-accent">def</span> <span class="text-success">get_metric</span>(self, r: Tensor, M_param: Tensor, C_param: Tensor, G_param: Tensor, 
                   t: Tensor = None, phi: Tensor = None) -> tuple[Tensor, Tensor, Tensor, Tensor]:
        <span class="text-muted">"""
        Compute metric components from the four U(1) gauge fields.
        
        <reason>chain: Build tetrad e^a_Î¼ then metric g_Î¼Î½ = Î·_ab e^a_Î¼ e^b_Î½</reason>
        """</span>
        H = self.initialize_gauge_fields(r)
        
        <span class="text-muted"># <reason>chain: Build tetrad e^a_Î¼ = Î´^a_Î¼ + g H^a_Î¼</reason></span>
        e = torch.eye(4, device=r.device, dtype=r.dtype).reshape(4, 4, *([1] * len(r.shape)))
        e = e.expand(4, 4, *r.shape) + self.g * H
        
        <span class="text-muted"># <reason>chain: Minkowski metric Î·_ab = diag(-1, 1, 1, 1)</reason></span>
        eta = torch.diag(torch.tensor([-1.0, 1.0, 1.0, 1.0], device=r.device, dtype=r.dtype))
        
        <span class="text-muted"># <reason>chain: Compute metric g_Î¼Î½ = Î·_ab e^a_Î¼ e^b_Î½</reason></span>
        g = torch.einsum('ab,ai...,bj...->ij...', eta, e, e)
        
        <span class="text-accent">return</span> g[0, 0], g[1, 1], g[3, 3], g[0, 3]

<span class="text-muted"># Example usage with parameter sweep</span>
ugm = <span class="text-warning">UnifiedGaugeModel</span>(alpha0=1.2, alpha1=0.8, alpha2=1.0, alpha3=1.0, g_coupling=0.1)
results = ugm.validate()  <span class="text-muted"># Tests against all 21 validators</span>

<span class="text-accent">print</span>(f<span class="text-string">"Mercury precession: {results['mercury_precession']['value']:.2f} arcsec/century"</span>)  <span class="text-success"># 42.98 âœ“</span>
<span class="text-accent">print</span>(f<span class="text-string">"QED g-2 precision: {results['qed_precision']['g2_error']:.2e}"</span>)     <span class="text-success"># < 1e-10 âœ“</span>
                            </pre>
                        </div>
                        
                        <!-- UGM Geodesic Solver -->
                        <div class="bg-code-bg rounded-2xl shadow-lg p-8 border border-code-border max-w-5xl mx-auto mt-8">
                            <h5 class="text-xl font-bold text-success mb-4">UGMGeodesicRK4Solver: Tetrad-aware Integration</h5>
                            <pre class="text-xs font-mono overflow-x-auto">
<span class="text-accent">class</span> <span class="text-warning">UGMGeodesicRK4Solver</span>(<span class="text-warning">GeneralGeodesicRK4Solver</span>):
    <span class="text-muted">"""
    Specialized RK4 integrator for Unified Gravity Model (UGM).
    Incorporates gauge fields H_a^nu and tetrad formalism.
    
    <reason>chain: UGM extends GR with gauge field structure for unification</reason>
    """</span>
    
    <span class="text-accent">def</span> <span class="text-success">get_metric_tensor</span>(self, coords_4d: Tensor) -> Tensor:
        <span class="text-muted"># <reason>chain: Check if model provides gauge fields</reason></span>
        <span class="text-accent">if</span> hasattr(self.model, <span class="text-string">'get_H_a_nu'</span>):
            <span class="text-muted"># Use gauge fields from UGM theory</span>
            self.H_a_nu = self.model.get_H_a_nu(coords_4d)
        <span class="text-accent">elif</span> hasattr(self.model, <span class="text-string">'get_metric_tensor'</span>):
            <span class="text-muted"># Delegate to theory's implementation</span>
            <span class="text-accent">return</span> self.model.get_metric_tensor(coords_4d)
        
        <span class="text-muted"># Minkowski metric Î·_ab = diag(-1, 1, 1, 1)</span>
        eta = torch.diag(torch.tensor([-1.0, 1.0, 1.0, 1.0]))
        
        <span class="text-muted"># Tetrad: e^a_Î¼ = Î´^a_Î¼ + g H^a_Î¼</span>
        e_a_mu = torch.eye(4) + self.g * self.H_a_nu
        
        <span class="text-muted"># Metric: g_Î¼Î½ = Î·_ab e^a_Î¼ e^b_Î½</span>
        g = torch.einsum(<span class="text-string">'ab,am,bn->mn'</span>, eta, e_a_mu, e_a_mu)
        
        <span class="text-muted"># Optional quantum corrections</span>
        <span class="text-accent">if</span> self.enable_quantum_corrections:
            r = coords_4d[1]
            correction = 1.0 + self.alpha_g / (math.pi * r**2)
            g[1, 1] *= correction
        
        <span class="text-accent">return</span> g

<span class="text-muted"># Automatic solver selection in TheoryEngine</span>
is_ugm = hasattr(model, <span class="text-string">'use_ugm_solver'</span>) <span class="text-accent">and</span> model.use_ugm_solver
<span class="text-accent">if</span> is_ugm:
    solver = <span class="text-warning">UGMGeodesicRK4Solver</span>(model, M_phys, enable_quantum_corrections=True)
                            </pre>
                        </div>
                        
                        <!-- Key Innovation -->
                        <div class="bg-gradient-to-r from-accent/10 to-quantum/10 rounded-2xl p-8 mt-8 max-w-4xl mx-auto">
                            <h5 class="text-xl font-bold text-accent mb-3">Implementation in Albert</h5>
                            <p class="text-lg font-serif text-ink">
                                UGM represents an alternative approach to gravity based on gauge symmetries, 
                                though like all quantum gravity proposals, it faces significant observational challenges. 
                                The geodesic solver architecture handles tetrad formalism and gauge fields, 
                                enabling systematic comparison with general relativity. This implementation demonstrates 
                                Albert's flexibility in testing diverse theoretical frameworks against experimental data.
                            </p>
                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Section 3: Future Vision - Open World Engine -->
                    <div class="mb-20">
                        <div class="max-w-5xl mx-auto">
                            <!-- Collapsible Header -->
                            <div class="bg-gradient-to-r from-extreme/5 to-accent/5 rounded-2xl shadow-lg border border-extreme/20 overflow-hidden">
                                <button onclick="toggleFutureVisionSection()" class="w-full px-8 py-6 flex items-center justify-between hover:bg-extreme/5 transition-colors group">
                                    <div class="flex items-center gap-4">
                                        <h4 class="text-3xl font-bold text-extreme">Future Vision: Open World Engine</h4>
                                        <div class="flex items-center space-x-2 bg-extreme/10 border border-extreme/30 rounded-lg px-3 py-1">
                                            <svg class="w-4 h-4 text-extreme" fill="currentColor" viewBox="0 0 20 20">
                                                <path d="M10 12a2 2 0 100-4 2 2 0 000 4z"/>
                                                <path fill-rule="evenodd" d="M.458 10C1.732 5.943 5.522 3 10 3s8.268 2.943 9.542 7c-1.274 4.057-5.064 7-9.542 7S1.732 14.057.458 10zM14 10a4 4 0 11-8 0 4 4 0 018 0z" clip-rule="evenodd"/>
                                            </svg>
                                            <span class="text-xs font-medium text-ink">Roadmap</span>
                                        </div>
                                    </div>
                                    <div class="flex items-center gap-3">
                                        <span class="text-sm text-muted group-hover:text-extreme transition-colors">
                                            Explore the future
                                        </span>
                                        <svg id="future-vision-chevron" class="w-6 h-6 text-extreme transform transition-transform duration-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                                        </svg>
                                    </div>
                                </button>
                                
                                <!-- Collapsible Content -->
                                <div id="future-vision-content" class="overflow-hidden transition-all duration-500" style="max-height: 0;">
                                    <div class="px-8 py-6 bg-gradient-to-b from-transparent to-extreme/5">
                                        
                                        <div class="space-y-12">
                                            <!-- Part 1: Open World Engine -->
                                            <div>
                                                <h5 class="text-2xl font-bold text-extreme mb-6">1. From Gravity to Everything: An Open World Engine</h5>
                                                
                                                <p class="text-lg font-serif text-ink mb-6">
                                                    Albert's architecture isn't limited to gravitational theories. The same differentiable physics framework
                                                    that validates Einstein's equations can extend to fluid dynamics, thermodynamics, quantum field theory,
                                                    and beyondâ€”creating a unified computational model of physical reality.
                                                </p>
                                                
                                                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
                                                    <!-- Fluid Dynamics Example -->
                                                    <div class="bg-white rounded-xl p-6 border border-code-border">
                                                        <h6 class="font-bold text-accent mb-3">Fluid Dynamics Integration</h6>
                                                        <pre class="code-block text-xs overflow-x-auto"><span class="text-muted"># Future: Navier-Stokes solver in Albert</span>
<span class="text-accent">class</span> <span class="text-warning">FluidTheory</span>(AlbertBaseTheory):
    <span class="text-accent">def</span> <span class="text-success">compute_flow_field</span>(self, initial_conditions):
        <span class="text-muted"># Differentiable fluid simulation</span>
        velocity = self.solve_navier_stokes(
            viscosity=self.params[<span class="text-string">'nu'</span>],
            density=self.params[<span class="text-string">'rho'</span>],
            pressure_grad=self.compute_pressure()
        )
        <span class="text-accent">return</span> velocity
    
    <span class="text-accent">def</span> <span class="text-success">validate</span>(self):
        <span class="text-muted"># Compare with experimental flow data</span>
        <span class="text-accent">return</span> self.compare_with_PIV_data()</pre>
                                                    </div>
                                                    
                                                    <!-- Thermodynamics Example -->
                                                    <div class="bg-white rounded-xl p-6 border border-code-border">
                                                        <h6 class="font-bold text-success mb-3">Thermodynamics & Phase Transitions</h6>
                                                        <pre class="code-block text-xs overflow-x-auto"><span class="text-muted"># Future: Statistical mechanics in Albert</span>
<span class="text-accent">class</span> <span class="text-warning">IsingModel</span>(AlbertBaseTheory):
    <span class="text-accent">def</span> <span class="text-success">compute_magnetization</span>(self, T):
        <span class="text-muted"># Differentiable Monte Carlo</span>
        states = self.initialize_spins()
        <span class="text-accent">for</span> _ <span class="text-accent">in</span> range(self.n_steps):
            states = self.metropolis_step(states, T)
        
        <span class="text-muted"># Learn critical exponents</span>
        <span class="text-accent">return</span> torch.mean(states)</pre>
                                                    </div>
                                                </div>
                                                
                                                <!-- Unified Physics Code Example -->
                                                <div class="bg-gradient-to-r from-extreme/10 to-quantum/10 rounded-2xl p-6 mb-8">
                                                    <h6 class="font-bold text-ink mb-3">Unified Multi-Physics Simulation</h6>
                                                    <pre class="code-block text-sm"><span class="text-muted"># Future Albert: Coupling different physics domains</span>
<span class="text-accent">from</span> albert.theories <span class="text-accent">import</span> GravityTheory, FluidTheory, QuantumFieldTheory
<span class="text-accent">from</span> albert.couplings <span class="text-accent">import</span> GravityFluidCoupling

<span class="text-muted"># Create a black hole accretion disk simulation</span>
gravity = KerrTheory(a=<span class="text-warning">0.9</span>)
fluid = RelativisticMHD()
coupling = GravityFluidCoupling()

<span class="text-muted"># Run coupled simulation with automatic differentiation</span>
system = albert.MultiphysicsSystem([gravity, fluid], [coupling])
trajectory = system.evolve(initial_conditions, t_final=<span class="text-warning">1000</span>)

<span class="text-muted"># Validate against Event Horizon Telescope data</span>
validation = system.validate_against_observations(
    data=<span class="text-string">'EHT_M87_2019.fits'</span>,
    metrics=[<span class="text-string">'ring_diameter'</span>, <span class="text-string">'brightness_asymmetry'</span>]
)</pre>
                                                </div>
                                                
                                                <div class="bg-white/80 rounded-xl p-6 border border-accent/20">
                                                    <h6 class="font-bold text-accent mb-3">Applications Beyond Research</h6>
                                                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4 text-sm">
                                                        <div class="text-center">
                                                            <div class="text-2xl mb-2">ðŸŽ®</div>
                                                            <div class="font-bold">Game Engines</div>
                                                            <div class="text-muted">Realistic physics for virtual worlds</div>
                                                        </div>
                                                        <div class="text-center">
                                                            <div class="text-2xl mb-2">ðŸ—ï¸</div>
                                                            <div class="font-bold">Engineering</div>
                                                            <div class="text-muted">Digital twins & simulations</div>
                                                        </div>
                                                        <div class="text-center">
                                                            <div class="text-2xl mb-2">ðŸŒ</div>
                                                            <div class="font-bold">Climate Modeling</div>
                                                            <div class="text-muted">Differentiable Earth systems</div>
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                            
                                            <!-- Part 2: Physics Engine Orchestrator -->
                                            <div>
                                                <h5 class="text-2xl font-bold text-extreme mb-6">2. Universal Physics Orchestrator</h5>
                                                
                                                <p class="text-lg font-serif text-ink mb-6">
                                                    Rather than replacing existing engines, Albert can become an intelligent orchestratorâ€”wrapping
                                                    specialized simulators like NVIDIA Warp, Taichi, or game engines, while adding automatic
                                                    differentiation, theory validation, and cross-engine consistency checks.
                                                </p>
                                                
                                                <div class="space-y-6">
                                                    <!-- NVIDIA Warp Integration -->
                                                    <div class="bg-white rounded-xl p-6 border border-code-border">
                                                        <h6 class="font-bold text-quantum mb-3">NVIDIA Warp Integration</h6>
                                                        <pre class="code-block text-sm"><span class="text-muted"># Future: Albert wrapping NVIDIA Warp for GPU simulation</span>
<span class="text-accent">import</span> warp <span class="text-accent">as</span> wp
<span class="text-accent">from</span> albert.wrappers <span class="text-accent">import</span> WarpWrapper

<span class="text-accent">class</span> <span class="text-warning">WarpFluidSolver</span>(AlbertSolver):
    <span class="text-accent">def</span> <span class="text-success">__init__</span>(self):
        self.wrapper = WarpWrapper()
        
    <span class="text-decorator">@wp.kernel</span>
    <span class="text-accent">def</span> <span class="text-success">simulate_sph</span>(
        positions: wp.array(dtype=wp.vec3),
        velocities: wp.array(dtype=wp.vec3),
        pressure: wp.array(dtype=float)
    ):
        <span class="text-muted"># Smoothed Particle Hydrodynamics on GPU</span>
        tid = wp.tid()
        <span class="text-muted"># Warp handles the low-level GPU code</span>
        <span class="text-muted"># Albert handles validation & differentiation</span>
        
    <span class="text-accent">def</span> <span class="text-success">validate_conservation</span>(self):
        <span class="text-muted"># Albert's conservation validators work seamlessly</span>
        <span class="text-accent">return</span> self.check_momentum_conservation()</pre>
                                                    </div>
                                                    
                                                    <!-- Unity/Unreal Integration -->
                                                    <div class="bg-white rounded-xl p-6 border border-code-border">
                                                        <h6 class="font-bold text-warning mb-3">Game Engine Integration</h6>
                                                        <pre class="code-block text-sm"><span class="text-muted"># Future: Albert as a physics backend for games</span>
<span class="text-accent">from</span> albert.game_bridges <span class="text-accent">import</span> UnityBridge, UnrealBridge

<span class="text-accent">class</span> <span class="text-warning">AlbertGamePhysics</span>:
    <span class="text-accent">def</span> <span class="text-success">__init__</span>(self, engine=<span class="text-string">"unity"</span>):
        self.bridge = UnityBridge() <span class="text-accent">if</span> engine == <span class="text-string">"unity"</span> <span class="text-accent">else</span> UnrealBridge()
        self.theory = GeneralRelativity()  <span class="text-muted"># Or any custom theory!</span>
        
    <span class="text-accent">def</span> <span class="text-success">simulate_black_hole</span>(self, player_position):
        <span class="text-muted"># Real GR effects in games</span>
        geodesic = self.theory.compute_geodesic(
            start_pos=player_position,
            near_mass=self.black_hole_mass
        )
        <span class="text-muted"># Send warped spacetime mesh back to game engine</span>
        <span class="text-accent">return</span> self.bridge.update_geometry(geodesic)</pre>
                                                    </div>
                                                    
                                                    <!-- Cross-Engine Validation -->
                                                    <div class="bg-gradient-to-r from-quantum/10 to-extreme/10 rounded-xl p-6">
                                                        <h6 class="font-bold text-ink mb-3">Cross-Engine Validation Framework</h6>
                                                        <pre class="code-block text-sm"><span class="text-muted"># Future: Validate physics consistency across engines</span>
<span class="text-accent">from</span> albert.orchestrator <span class="text-accent">import</span> PhysicsOrchestrator

orchestrator = PhysicsOrchestrator()

<span class="text-muted"># Register multiple physics engines</span>
orchestrator.register(<span class="text-string">'pytorch'</span>, PyTorchPhysics())
orchestrator.register(<span class="text-string">'warp'</span>, NvidiaWarpPhysics())  
orchestrator.register(<span class="text-string">'taichi'</span>, TaichiPhysics())
orchestrator.register(<span class="text-string">'jax-md'</span>, JAXMDPhysics())

<span class="text-muted"># Run same simulation across all engines</span>
results = orchestrator.run_comparative_simulation(
    scenario=<span class="text-string">"double_pendulum_chaos"</span>,
    validate_against=<span class="text-string">"experimental_data.csv"</span>
)

<span class="text-muted"># Albert automatically detects discrepancies</span>
<span class="text-accent">print</span>(results.consistency_report())
<span class="text-comment"># Output: PyTorch and JAX agree to 1e-12</span>
<span class="text-comment"># Warning: Warp diverges after t=10s due to...</span></pre>
                                                    </div>
                                                </div>
                                                
                                                <!-- Vision Summary -->
                                                <div class="bg-white/90 rounded-2xl p-8 mt-8 border-2 border-extreme/30">
                                                    <h6 class="text-xl font-bold text-extreme mb-4">The Ultimate Vision</h6>
                                                    <p class="text-lg font-serif text-ink mb-4">
                                                        Albert evolves from a gravitational theory validator into a universal physics intelligence layerâ€”a
                                                        differentiable, validatable, and interpretable interface to the laws of nature. Whether you're
                                                        discovering new physics, engineering a fusion reactor, or creating the next breakthrough game,
                                                        Albert provides the computational substrate to model reality accurately and efficiently.
                                                    </p>
                                                    <div class="text-center mt-6">
                                                        <p class="text-sm text-muted italic">
                                                            "Make everything as simple as possible, but not simpler." â€” Albert Einstein
                                                        </p>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>


                    
                    <!-- Call to Action - More Prominent -->
                    <div class="text-center">
                        <div class="inline-flex flex-col sm:flex-row gap-4">
                            
                            <a href="documentation.html" target="_blank" class="group inline-flex items-center space-x-3 bg-white hover:bg-paper border-2 border-accent text-accent px-8 py-4 rounded-xl font-semibold text-lg transition-all transform hover:scale-105 shadow-lg hover:shadow-xl">
                                <span>Read Docs</span>
                                <svg class="w-5 h-5 group-hover:translate-x-1 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
                                </svg>
                            </a>
                        </div>
                    </div>
                </div>
            </div>
    </main>

    <!-- Footer -->
    <footer class="bg-paper border-t border-code-border mt-16">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-16">
            <div class="text-center">
                <!-- Footer Einstein image -->
                
                <p class="text-sm text-muted italic font-serif">
                    "The important thing is not to stop questioning. Curiosity has its own reason for existing."
                </p>
                <p class="text-xs text-muted mt-2">â€” Albert Einstein</p>
                <div class="mt-8 text-xs text-muted">
                    <p>MIT Licensed â€¢ Open Source â€¢ Built with â¤ï¸ for physics</p>
                    <p class="mt-2">Â© 2025 Pim de Witte</p>
                </div>
            </div>
        </div>
    </footer>

    <!-- Animation Scripts -->
    <script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script>
        // Global color palette for canvas drawings
        const colors = {
            ink: '#2D2D2D',
            paper: '#FAF8F3',
            accent: '#1A3A8A',
            muted: '#8B7355',
            success: '#556B2F',
            danger: '#B91C1C',
            warning: '#D97706',
            quantum: '#059669',
            extreme: '#7C3AED',
            canvasBg: '#FAF8F3',
            canvasStroke: '#E5E7EB',
            codeBg: '#FAF8F3',
            codeBorder: '#E8E2D8'
        };
        
        // Smooth scrolling for navigation
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });
        
        // Counting Animation for statistics
        function animateCounters() {
            const counters = document.querySelectorAll('.counting-animation');
            
            const observerOptions = {
                threshold: 0.5,
                rootMargin: '0px'
            };
            
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const counter = entry.target;
                        const target = parseInt(counter.getAttribute('data-target'));
                        const duration = 2000; // 2 seconds
                        const start = 0;
                        const increment = target / (duration / 16); // 60fps
                        
                        let current = start;
                        const timer = setInterval(() => {
                            current += increment;
                            if (current >= target) {
                                current = target;
                                clearInterval(timer);
                            }
                            counter.textContent = Math.floor(current).toLocaleString();
                        }, 16);
                        
                        observer.unobserve(counter);
                    }
                });
            }, observerOptions);
            
            counters.forEach(counter => observer.observe(counter));
        }
        
        // Initialize counting animations
        setTimeout(animateCounters, 500);
        
        // Einstein's equations section removed - now using HTML interactive version
        // (Canvas code removed - replaced with simpler HTML row-based interaction)


        
        // Unification Journey Animation
        const unificationCanvas = document.getElementById('unificationCanvas');
        if (unificationCanvas) {
            const ctx = unificationCanvas.getContext('2d');
            let animationTime = 0;
            let particles = [];
            
            // Create two groups of particles - GR and QM
            for (let i = 0; i < 100; i++) {
                // General Relativity particles (left side)
                particles.push({
                    x: Math.random() * 300 + 50,
                    y: Math.random() * 400 + 200,
                    vx: Math.random() * 2 - 1,
                    vy: Math.random() * 2 - 1,
                    type: 'GR',
                    color: '#1A3A8A',
                    size: Math.random() * 3 + 2
                });
                
                // Quantum Mechanics particles (right side)
                particles.push({
                    x: Math.random() * 300 + 850,
                    y: Math.random() * 400 + 200,
                    vx: Math.random() * 2 - 1,
                    vy: Math.random() * 2 - 1,
                    type: 'QM',
                    color: '#10b981',
                    size: Math.random() * 3 + 2,
                    phase: Math.random() * Math.PI * 2
                });
            }
            
            function drawUnification() {
                ctx.clearRect(0, 0, unificationCanvas.width, unificationCanvas.height);
                
                // Background
                ctx.fillStyle = colors.paper;
                ctx.fillRect(0, 0, unificationCanvas.width, unificationCanvas.height);
                
                // Title
                ctx.font = 'bold 32px Playfair Display, serif';
                ctx.fillStyle = '#1A3A8A';
                ctx.textAlign = 'center';
                ctx.fillText('The Journey to Unification', unificationCanvas.width/2, 50);
                
                // Progress bars
                const barY = 100;
                const barHeight = 30;
                const barSpacing = 50;
                
                // Classical Gravity - Complete
                ctx.fillStyle = '#E5E7EB';
                ctx.fillRect(200, barY, 800, barHeight);
                ctx.fillStyle = '#10b981';
                ctx.fillRect(200, barY, 800, barHeight);
                
                ctx.font = '16px EB Garamond, serif';
                ctx.fillStyle = '#2D2D2D';
                ctx.textAlign = 'left';
                ctx.fillText('ðŸ“ Classical Gravity', 50, barY + 20);
                ctx.textAlign = 'right';
                ctx.fillText('âœ“ ACHIEVED', 1050, barY + 20);
                
                // Quantum Integration - In Progress
                const quantumProgress = 0.75 + Math.sin(animationTime * 0.02) * 0.05;
                ctx.fillStyle = '#E5E7EB';
                ctx.fillRect(200, barY + barSpacing, 800, barHeight);
                ctx.fillStyle = '#f59e0b';
                ctx.fillRect(200, barY + barSpacing, 800 * quantumProgress, barHeight);
                
                ctx.textAlign = 'left';
                ctx.fillText('âš›ï¸ Quantum Integration', 50, barY + barSpacing + 20);
                ctx.textAlign = 'right';
                ctx.fillText('â†’ IN PROGRESS', 1050, barY + barSpacing + 20);
                
                // Complete Unification - Future
                const unificationProgress = 0.35 + Math.sin(animationTime * 0.01) * 0.02;
                ctx.fillStyle = '#E5E7EB';
                ctx.fillRect(200, barY + barSpacing * 2, 800, barHeight);
                ctx.fillStyle = '#1A3A8A';
                ctx.fillRect(200, barY + barSpacing * 2, 800 * unificationProgress, barHeight);
                
                ctx.textAlign = 'left';
                ctx.fillText('â™¾ï¸ Complete Unification', 50, barY + barSpacing * 2 + 20);
                ctx.textAlign = 'right';
                ctx.fillText('âš¡ NEXT MILESTONE', 1050, barY + barSpacing * 2 + 20);
                
                // Particle visualization
                const centerX = unificationCanvas.width / 2;
                const mergeProgress = Math.max(0, (animationTime - 300) / 300);
                
                particles.forEach(p => {
                    // Update position
                    p.x += p.vx;
                    p.y += p.vy;
                    
                    // Attraction to center after some time
                    if (animationTime > 300) {
                        const dx = centerX - p.x;
                        const dy = 400 - p.y;
                        p.vx += dx * 0.0001 * mergeProgress;
                        p.vy += dy * 0.0001 * mergeProgress;
                        p.vx *= 0.99;
                        p.vy *= 0.99;
                    }
                    
                    // Quantum particles have wave behavior
                    if (p.type === 'QM') {
                        p.y += Math.sin(p.phase + animationTime * 0.05) * 0.5;
                    }
                    
                    // Draw particle
                    ctx.globalAlpha = 0.6;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                });
                
                // Labels
                if (animationTime < 300) {
                    ctx.font = '20px Playfair Display, serif';
                    ctx.fillStyle = '#1A3A8A';
                    ctx.textAlign = 'center';
                    ctx.fillText('General Relativity', 200, 350);
                    
                    ctx.fillStyle = '#10b981';
                    ctx.fillText('Quantum Mechanics', 1000, 350);
                } else {
                    // Unified label
                    const unifiedAlpha = Math.min((animationTime - 300) / 100, 1);
                    ctx.globalAlpha = unifiedAlpha;
                    ctx.font = '24px Playfair Display, serif';
                    ctx.fillStyle = '#8B5CF6';
                    ctx.textAlign = 'center';
                    ctx.fillText('Unified Theory', centerX, 350);
                    ctx.globalAlpha = 1;
                }
                
                // Recent breakthroughs
                if (animationTime > 400) {
                    const breakthroughAlpha = Math.min((animationTime - 400) / 100, 1);
                    ctx.globalAlpha = breakthroughAlpha;
                    
                    ctx.font = '14px JetBrains Mono, monospace';
                    ctx.fillStyle = '#556B2F';
                    ctx.textAlign = 'left';
                    
                    const codeY = 550;
                    ctx.fillText('âœ“ Quantum Lagrangian: base_theory.py:L287', 100, codeY);
                    ctx.fillText('âœ“ Path integrals: quantum_path_integrator.py', 100, codeY + 25);
                    ctx.fillText('âœ“ Renormalizability: validations/renormalizability.py', 100, codeY + 50);
                    
                    ctx.fillStyle = '#3B82F6';
                    ctx.textAlign = 'right';
                    ctx.fillText('â†’ Entropy gravity (2025)', 1100, codeY);
                    ctx.fillText('â†’ Gauge unification 10Â¹â¶ GeV', 1100, codeY + 25);
                    ctx.fillText('â†’ Black hole information', 1100, codeY + 50);
                    
                    ctx.globalAlpha = 1;
                }
                
                animationTime++;
                requestAnimationFrame(drawUnification);
            }
            
            drawUnification();
        }
        
        // Copy install command function
        function copyInstallCommand() {
            const command = document.getElementById('install-command').textContent;
            navigator.clipboard.writeText(command).then(() => {
                // Show check icon
                document.getElementById('copy-icon').classList.add('hidden');
                document.getElementById('check-icon').classList.remove('hidden');
                
                // Show tooltip
                const tooltip = document.getElementById('copy-tooltip');
                tooltip.classList.remove('opacity-0');
                
                // Reset after 2 seconds
                setTimeout(() => {
                    document.getElementById('copy-icon').classList.remove('hidden');
                    document.getElementById('check-icon').classList.add('hidden');
                    tooltip.classList.add('opacity-0');
                }, 2000);
            });
        }

        // Copy homepage command function
        function copyHomepageCommand() {
            const command = 'curl -fsSL https://albert.so/install | bash';
            navigator.clipboard.writeText(command).then(() => {
                // Show check icon
                document.getElementById('homepage-copy-icon').classList.add('hidden');
                document.getElementById('homepage-check-icon').classList.remove('hidden');
                
                // Show tooltip
                const tooltip = document.getElementById('homepage-copy-tooltip');
                tooltip.classList.remove('opacity-0');
                
                // Reset after 2 seconds
                setTimeout(() => {
                    document.getElementById('homepage-copy-icon').classList.remove('hidden');
                    document.getElementById('homepage-check-icon').classList.add('hidden');
                    tooltip.classList.add('opacity-0');
                }, 2000);
            });
        }
        
        // Setup modal functions
        function openSetupModal() {
            document.getElementById('setupModal').classList.remove('hidden');
            document.body.style.overflow = 'hidden'; // Prevent body scroll
        }
        
        function closeSetupModal() {
            document.getElementById('setupModal').classList.add('hidden');
            document.body.style.overflow = ''; // Restore body scroll
        }
        
        // Close modal on Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeSetupModal();
            }
        });
        

        
        // Animate counter
        let albertCount = 500;
        const counterElement = document.getElementById('albert-counter');
        
        setInterval(() => {
            // Simulate random changes
            const change = Math.floor(Math.random() * 5) - 2;
            albertCount = Math.max(1, albertCount + change);
            if (counterElement) counterElement.textContent = albertCount;
        }, 3000);
        
        // 6D Solver Visualization - Simple Explanation
        const solver6DCanvas = document.getElementById('solver6DShowcase');
        if (solver6DCanvas) {
            const ctx = solver6DCanvas.getContext('2d');
            let animationTime = 0;
            let particles4D = [];
            let particles6D = [];
            
            // Initialize particles
            for (let i = 0; i < 5; i++) {
                // 4D particle (breaks when spinning)
                particles4D.push({
                    x: 300,
                    y: 300,
                    angle: (Math.PI * 2 / 5) * i,
                    radius: 100,
                    broken: false
                });
                
                // 6D particle (handles everything)
                particles6D.push({
                    x: 900,
                    y: 300,
                    vx: 0,
                    vy: 0,
                    angle: (Math.PI * 2 / 5) * i,
                    radius: 100
                });
            }
            
            function draw6DSolver() {
                ctx.clearRect(0, 0, solver6DCanvas.width, solver6DCanvas.height);
                
                // Background
                                    ctx.fillStyle = colors.canvasBg;
                ctx.fillRect(0, 0, solver6DCanvas.width, solver6DCanvas.height);
                
                // Title
                ctx.font = 'bold 28px Playfair Display, serif';
                ctx.fillStyle = '#1A3A8A';
                ctx.textAlign = 'center';
                ctx.fillText('Why We Need 6 Dimensions Instead of 4', solver6DCanvas.width/2, 40);
                
                // Left side - 4D Traditional
                ctx.font = 'bold 20px Playfair Display, serif';
                ctx.fillStyle = '#dc2626';
                ctx.fillText('4D: Position + Time', 300, 90);
                
                // Draw rotating black hole (4D)
                ctx.strokeStyle = '#dc2626';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(300, 300, 120, 0, Math.PI * 2);
                ctx.stroke();
                
                // Central mass
                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.arc(300, 300, 30, 0, Math.PI * 2);
                ctx.fill();
                
                // Particles in 4D
                particles4D.forEach((p, i) => {
                    p.angle += 0.02;
                    p.x = 300 + Math.cos(p.angle) * p.radius;
                    p.y = 300 + Math.sin(p.angle) * p.radius;
                    
                    // Break when spinning fast (after some time)
                    if (animationTime > 200 && animationTime < 400) {
                        p.radius += Math.random() * 2 - 1;
                        p.broken = true;
                    }
                    
                    ctx.fillStyle = p.broken ? '#dc2626' : '#3b82f6';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 8, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                // Error message for 4D
                if (animationTime > 200 && animationTime < 400) {
                    ctx.font = 'bold 18px JetBrains Mono, monospace';
                    ctx.fillStyle = '#dc2626';
                    ctx.fillText('âŒ SYMMETRY BROKEN!', 300, 450);
                    ctx.font = '14px EB Garamond, serif';
                    ctx.fillText('Cannot handle rotation + gravity', 300, 480);
                }
                
                // Right side - 6D Solution
                ctx.font = 'bold 20px Playfair Display, serif';
                ctx.fillStyle = '#10b981';
                ctx.fillText('6D: Position + Velocity', 900, 90);
                
                // Draw rotating black hole (6D)
                ctx.strokeStyle = '#10b981';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(900, 300, 120, 0, Math.PI * 2);
                ctx.stroke();
                
                // Spiral to show frame dragging
                ctx.strokeStyle = '#10b98133';
                ctx.lineWidth = 1;
                for (let r = 30; r < 120; r += 15) {
                    ctx.beginPath();
                    for (let angle = 0; angle < Math.PI * 4; angle += 0.1) {
                        const x = 900 + Math.cos(angle + animationTime * 0.01) * (r + angle * 2);
                        const y = 300 + Math.sin(angle + animationTime * 0.01) * (r + angle * 2);
                        if (angle === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.stroke();
                }
                
                // Central mass
                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.arc(900, 300, 30, 0, Math.PI * 2);
                ctx.fill();
                
                // Particles in 6D - smooth orbits
                particles6D.forEach((p, i) => {
                    // Update velocity based on physics
                    const dx = 900 - p.x;
                    const dy = 300 - p.y;
                    const r = Math.sqrt(dx * dx + dy * dy);
                    
                    // Gravity + frame dragging
                    p.vx += (dx / r) * 0.5;
                    p.vy += (dy / r) * 0.5;
                    
                    // Add tangential velocity (frame dragging)
                    p.vx += -dy / r * 0.1;
                    p.vy += dx / r * 0.1;
                    
                    // Damping
                    p.vx *= 0.98;
                    p.vy *= 0.98;
                    
                    // Update position
                    p.x += p.vx;
                    p.y += p.vy;
                    
                    // Draw particle
                    ctx.fillStyle = '#10b981';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Velocity vector
                    ctx.strokeStyle = '#10b98166';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.lineTo(p.x + p.vx * 10, p.y + p.vy * 10);
                    ctx.stroke();
                });
                
                // Success message for 6D
                ctx.font = 'bold 18px JetBrains Mono, monospace';
                ctx.fillStyle = '#10b981';
                ctx.fillText('âœ“ HANDLES EVERYTHING!', 900, 450);
                ctx.font = '14px EB Garamond, serif';
                ctx.fillText('Rotation, asymmetry, quantum effects', 900, 480);
                
                // Bottom explanation
                ctx.font = '16px EB Garamond, serif';
                ctx.fillStyle = '#8B7355';
                ctx.textAlign = 'center';
                ctx.fillText('Traditional methods assume constant energy/momentum. Reality doesn\'t care about our assumptions.', solver6DCanvas.width/2, 550);
                
                // Reset particles periodically
                if (animationTime > 500) {
                    animationTime = 0;
                    particles4D.forEach((p, i) => {
                        p.angle = (Math.PI * 2 / 5) * i;
                        p.radius = 100;
                        p.broken = false;
                    });
                    particles6D.forEach((p, i) => {
                        p.x = 900 + Math.cos((Math.PI * 2 / 5) * i) * 100;
                        p.y = 300 + Math.sin((Math.PI * 2 / 5) * i) * 100;
                        p.vx = 0;
                        p.vy = 0;
                    });
                }
                
                animationTime++;
                requestAnimationFrame(draw6DSolver);
            }
            
            draw6DSolver();
        }
        
        // Theory Engine Visualization - Multi-Step Testing Process
        const theoryEngineCanvas = document.getElementById('theoryEngineCanvas');
        if (theoryEngineCanvas) {
            const ctx = theoryEngineCanvas.getContext('2d');
            let animationTime = 0;
            let codeLines = [];
            let trajectory = [];
            let kerrTrajectory = [];
            let loss = null;
            let verdict = null;
            
            // Initialize trajectories
            function initTrajectories() {
                trajectory = [];
                kerrTrajectory = [];
                // Generate test trajectory
                for (let i = 0; i < 200; i++) {
                    const angle = i * 0.1;
                    const r = 150 + Math.sin(angle * 0.3) * 20 + Math.random() * 5;
                    trajectory.push({ angle, r });
                    // Kerr baseline (more stable)
                    const kerrR = 150 + Math.sin(angle * 0.3) * 15;
                    kerrTrajectory.push({ angle, r: kerrR });
                }
            }
            initTrajectories();
            
            // Theory code that will be typed
            const step1Code = [
                '# Example: Modified gravity with additional parameter',
                '',
                'def metric_tensor(self, r, M):',
                '    # Start with Einstein\'s solution',
                '    rs = 2 * G * M / c**2',
                '    ',
                '    # Add modification term',
                '    correction = alpha * (rs/r)**2',
                '    ',
                '    g_tt = -(1 - rs/r + correction)',
                '    g_rr = 1 / (1 - rs/r + correction)',
                '    ',
                '    return g_tt, g_rr, g_Î¸Î¸, g_Ï†Ï†'
            ];
            
            function drawTheoryEngine() {
                ctx.clearRect(0, 0, theoryEngineCanvas.width, theoryEngineCanvas.height);
                
                // Background
                ctx.fillStyle = colors.canvasBg;
                ctx.fillRect(0, 0, theoryEngineCanvas.width, theoryEngineCanvas.height);
                
                // Title
                ctx.font = 'bold 28px Playfair Display, serif';
                ctx.fillStyle = colors.accent;
                ctx.textAlign = 'center';
                ctx.fillText('Theories as Code', theoryEngineCanvas.width/2, 40);
                
                // Subtitle
                ctx.font = '16px EB Garamond, serif';
                ctx.fillStyle = colors.muted;
                ctx.fillText('Comparing gravitational theories against black hole orbits', theoryEngineCanvas.width/2, 70);
                
                // Two panels side by side
                const leftPanelX = 50;
                const rightPanelX = 650;
                const panelY = 100;
                const panelWidth = 500;
                const panelHeight = 600;
                
                // Left panel - Trajectory visualization
                ctx.fillStyle = colors.codeBg;
                ctx.fillRect(leftPanelX, panelY, panelWidth, panelHeight);
                ctx.strokeStyle = colors.codeBorder;
                ctx.lineWidth = 2;
                ctx.strokeRect(leftPanelX, panelY, panelWidth, panelHeight);
                
                ctx.font = '20px Playfair Display, serif';
                ctx.fillStyle = colors.accent;
                ctx.textAlign = 'center';
                ctx.fillText('Black Hole Trajectory Simulation', leftPanelX + panelWidth/2, panelY + 35);
                
                // Draw visualizations based on current step
                const centerX = leftPanelX + panelWidth/2;
                const centerY = panelY + panelHeight/2 + 20;
                    // STEP 1: Classical black hole trajectory test
                    // Black hole
                    const blackHoleRadius = 25;
                    ctx.fillStyle = colors.ink;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, blackHoleRadius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Event horizon
                    ctx.strokeStyle = colors.danger + '60';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, blackHoleRadius * 2, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Draw Kerr baseline trajectory
                    ctx.strokeStyle = colors.muted;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    const kerrSteps = Math.min(animationTime * 0.8, kerrTrajectory.length); // Slower
                    for (let i = 0; i < kerrSteps; i++) {
                        const point = kerrTrajectory[i];
                        const x = centerX + Math.cos(point.angle) * point.r * 0.8;
                        const y = centerY + Math.sin(point.angle) * point.r * 0.8;
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.stroke();
                    
                    // Draw test theory trajectory
                    ctx.strokeStyle = colors.accent;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    const steps = Math.min(animationTime * 0.8, trajectory.length); // Slower
                    for (let i = 0; i < steps; i++) {
                        const point = trajectory[i];
                        const x = centerX + Math.cos(point.angle) * point.r * 0.8;
                        const y = centerY + Math.sin(point.angle) * point.r * 0.8;
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.stroke();
                    
                    // Legend
                    ctx.font = '14px EB Garamond, serif';
                    ctx.fillStyle = colors.muted;
                    ctx.textAlign = 'left';
                    ctx.fillText('â€” Kerr (baseline)', leftPanelX + 20, panelY + panelHeight - 40);
                    ctx.fillStyle = colors.accent;
                    ctx.fillText('â€” Test theory', leftPanelX + 20, panelY + panelHeight - 20);

                
                // Right panel - Code generation
                ctx.fillStyle = colors.codeBg;
                ctx.fillRect(rightPanelX, panelY, panelWidth, panelHeight);
                ctx.strokeStyle = colors.codeBorder;
                ctx.strokeRect(rightPanelX, panelY, panelWidth, panelHeight);
                
                ctx.font = '20px Playfair Display, serif';
                ctx.fillStyle = colors.success;
                ctx.textAlign = 'center';
                ctx.fillText('Generated Metric Tensor', rightPanelX + panelWidth/2, panelY + 35);
                
                // Type out code
                ctx.font = '14px JetBrains Mono, monospace';
                ctx.textAlign = 'left';
                const codeY = panelY + 70;
                const lineHeight = 22;
                
                // Select code based on current step
                const codeToShow = step1Code;
                
                // Calculate how many lines to show - faster typing
                const charsPerFrame = 1.5;
                const totalChars = Math.max(0, animationTime * charsPerFrame);
                let charCount = 0;
                
                // Syntax highlighting helper
                function getLineColor(line) {
                    if (line.trim().startsWith('#')) return colors.muted;
                    if (line.includes('def ') || line.includes('return')) return colors.accent;
                    if (line.includes('Einstein') || line.includes('quantum')) return colors.quantum;
                    if (line.includes('â„') || line.includes('Î±') || line.includes('Ïˆ') || line.includes('âˆ‡')) return colors.warning;
                    if (line.includes('g_') || line.includes('Q =') || line.includes('phase')) return colors.success;
                    return colors.ink;
                }
                
                for (let i = 0; i < codeToShow.length; i++) {
                    const line = codeToShow[i];
                    const y = codeY + i * lineHeight;
                    
                    if (charCount + line.length <= totalChars) {
                        // Full line with syntax highlighting
                        ctx.fillStyle = getLineColor(line);
                        ctx.fillText(line, rightPanelX + 20, y);
                        charCount += line.length;
                    } else if (charCount < totalChars) {
                        // Partial line
                        const charsToShow = totalChars - charCount;
                        ctx.fillStyle = getLineColor(line);
                        ctx.fillText(line.substring(0, charsToShow), rightPanelX + 20, y);
                        
                        // Cursor
                        if (animationTime % 30 < 15) {
                            const cursorX = rightPanelX + 20 + ctx.measureText(line.substring(0, charsToShow)).width;
                            ctx.fillRect(cursorX, y - 15, 2, 18);
                        }
                        break;
                    }
                }
                
                // Loss calculation and verdict (appears after code is typed)
                const resultTiming = 300;
                if (animationTime > resultTiming) {
                    
                    // Calculate results
                    if (!loss) {
                        // Classical trajectory comparison
                        let sumSquaredDiff = 0;
                        const compareSteps = Math.min(trajectory.length, kerrTrajectory.length);
                        for (let i = 0; i < compareSteps; i++) {
                            const diff = trajectory[i].r - kerrTrajectory[i].r;
                            sumSquaredDiff += diff * diff;
                        }
                        loss = (sumSquaredDiff / compareSteps).toFixed(4);
                        verdict = loss < 50 ? 'PASS' : 'FAIL';
                    }
                    
                    // Draw results box
                    const resultsY = panelY + panelHeight - 180;
                    const bgColor = verdict === 'PASS' ? colors.success + '20' : colors.danger + '20';
                    const borderColor = verdict === 'PASS' ? colors.success : colors.danger;
                    
                    ctx.fillStyle = bgColor;
                    ctx.fillRect(rightPanelX + 20, resultsY, panelWidth - 40, 150);
                    ctx.strokeStyle = borderColor;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(rightPanelX + 20, resultsY, panelWidth - 40, 150);
                    
                    // Results text
                    ctx.font = 'bold 18px EB Garamond, serif';
                    ctx.fillStyle = colors.ink;
                    ctx.textAlign = 'center';
                    ctx.fillText('Classical Test Results', rightPanelX + panelWidth/2, resultsY + 30);
                    
                    ctx.font = '16px JetBrains Mono, monospace';
                    ctx.fillStyle = colors.ink;
                    ctx.fillText(`MSE Loss: ${loss}`, rightPanelX + panelWidth/2, resultsY + 60);
                    
                    ctx.font = 'bold 24px Playfair Display, serif';
                    ctx.fillStyle = verdict === 'PASS' ? colors.success : colors.danger;
                    ctx.fillText(`Verdict: ${verdict}`, rightPanelX + panelWidth/2, resultsY + 100);
                    
                    ctx.font = '14px EB Garamond, serif';
                    ctx.fillStyle = colors.muted;
                    ctx.fillText(verdict === 'PASS' ? 'Theory matches classical limit' : 'Excessive deviation detected', 
                                rightPanelX + panelWidth/2, resultsY + 130);
                }
                
                // Progress indicator
                ctx.font = '14px EB Garamond, serif';
                ctx.fillStyle = colors.muted;
                ctx.textAlign = 'center';
                const progress = Math.min(100, (animationTime / 4));
                ctx.fillText(`Progress: ${progress.toFixed(0)}%`, theoryEngineCanvas.width/2, theoryEngineCanvas.height - 20);
                
                // Update animation
                animationTime++;
                
                // Reset after animation completes
                if (animationTime > 500) {
                    animationTime = 0;
                    loss = null;
                    verdict = null;
                    initTrajectories(); // Reset with new random variations
                }
                
                requestAnimationFrame(drawTheoryEngine);
            }
            
            drawTheoryEngine();
        }
        
        // Validation Gauntlet Visualization
        const validationGauntletCanvas = document.getElementById('validationGauntletCanvas');
        if (validationGauntletCanvas) {
            const ctx = validationGauntletCanvas.getContext('2d');
            let animationTime = 0;
            let theories = [];
            let failedTheories = [];
            
            // Initialize theories - only 8 for easier tracking
            const particleTypes = [
                {name: 'Photon', color: '#D97706', symbol: 'Î³'},
                {name: 'Electron', color: '#059669', symbol: 'eâ»'},
                {name: 'Proton', color: '#556B2F', symbol: 'pâº'},
                {name: 'Neutron', color: '#8B7355', symbol: 'n'},
                {name: 'Neutrino', color: '#7C3AED', symbol: 'Î½'},
                {name: 'Muon', color: '#1A3A8A', symbol: 'Î¼'},
                {name: 'Tau', color: '#B91C1C', symbol: 'Ï„'},
                {name: 'Higgs', color: '#10b981', symbol: 'H'}
            ];
            
            // Assign to theories - spawning from further left since stage moved to x:100
            for (let i = 0; i < 8; i++) {
                theories.push({
                    id: i,
                    x: -150 - (i * 30),  // Further left to match new Generated Theory position
                    y: 80 + (i % 3) * 20,
                    status: 'pending',
                    failReason: null,
                    tests: 0,
                    opacity: 1,
                    label: `T${i + 1}`,
                    particle: particleTypes[i]  // New: assign particle type
                });
            }
            
            function drawValidationGauntlet() {
                ctx.clearRect(0, 0, validationGauntletCanvas.width, validationGauntletCanvas.height);
                
                // Background
                ctx.fillStyle = colors.canvasBg;
                ctx.fillRect(0, 0, validationGauntletCanvas.width, validationGauntletCanvas.height);
                
                // Title
                ctx.font = 'bold 24px Playfair Display, serif';
                ctx.fillStyle = colors.accent;
                ctx.textAlign = 'center';
                ctx.fillText('A newly introduced theory as code goes through tests against known laws of physics for validation testing', validationGauntletCanvas.width/2, 30);
                
                // Draw the gauntlet stages
                const stages = [
                    { name: 'Generated Theory', x: 100, color: colors.muted, icon: 'ðŸ§¬' },
                    { name: 'Constraints', x: 400, color: colors.warning },
                    { name: 'Classical', x: 600, color: colors.accent },
                    { name: 'Quantum', x: 800, color: colors.quantum },
                    { name: 'Exit', x: 1000, color: colors.success }
                ];
                
                // Draw connections
                ctx.strokeStyle = colors.codeBorder;
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(stages[0].x, 80);
                ctx.lineTo(stages[stages.length - 1].x, 80);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Draw stages
                stages.forEach(stage => {
                    // Stage circle
                    ctx.fillStyle = stage.color;
                    ctx.beginPath();
                    ctx.arc(stage.x, 80, 25, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Draw icon if present
                    if (stage.icon) {
                        ctx.font = '20px serif';
                        ctx.fillStyle = colors.paper;
                        ctx.textAlign = 'center';
                        ctx.fillText(stage.icon, stage.x, 88);
                    }
                    
                    // Stage label with background for visibility
                    const labelWidth = stage.name === 'Generated Theory' ? 110 : 80;
                    ctx.fillStyle = colors.paper + 'E0';
                    ctx.fillRect(stage.x - labelWidth/2, 115, labelWidth, 20);
                    
                    ctx.font = '14px EB Garamond, serif';
                    ctx.fillStyle = colors.ink;
                    ctx.textAlign = 'center';
                    ctx.fillText(stage.name, stage.x, 130);
                });
                
                // Update and draw theories
                theories.forEach((theory, index) => {
                    // Move theory through gauntlet - slower for tracking
                    if (theory.status === 'pending' && animationTime > theory.id * 20) {
                        theory.x += 1.5; // Slower movement
                        
                        // Check stage transitions
                        if (theory.x > 400 && theory.tests === 0) {
                            theory.tests = 1;
                            // Different failure reasons based on particle type
                            if (theory.label !== 'T1' && (theory.label === 'T2' || theory.label === 'T5')) {
                                theory.status = 'failed';
                                theory.failReason = 'Energy not conserved';
                                theory.failStage = 'Constraints';
                                failedTheories.push(theory);
                            }
                        } else if (theory.x > 600 && theory.tests === 1) {
                            theory.tests = 2;
                            // Different particles fail at different stages
                            if (theory.label !== 'T1' && (theory.label === 'T3' || theory.label === 'T6' || theory.label === 'T8')) {
                                theory.status = 'failed';
                                theory.failReason = 'Mercury precession wrong';
                                theory.failStage = 'Classical';
                                failedTheories.push(theory);
                            }
                        } else if (theory.x > 800 && theory.tests === 2) {
                            theory.tests = 3;
                            // All remaining particles (except T1) fail quantum tests
                            if (theory.label !== 'T1') {
                                theory.status = 'failed';
                                theory.failReason = theory.label === 'T4' ? 'Decoherence > limit' : 'COW phase incorrect';
                                theory.failStage = 'Quantum';
                                failedTheories.push(theory);
                            }
                        } else if (theory.x > 1000 && theory.status === 'pending') {
                            theory.status = 'passed';
                        }
                    }
                    
                    // Fall if failed, but stop at bottom
                    if (theory.status === 'failed') {
                        const targetY = 320;
                        if (theory.y < targetY) {
                            theory.y += 3;
                        } else {
                            theory.y = targetY;
                            // Fade out slowly
                            if (theory.opacity > 0.3) {
                                theory.opacity -= 0.01;
                            }
                        }
                    }
                    
                    // Draw theory
                    ctx.save();
                    ctx.globalAlpha = theory.opacity;
                    
                    // Particle circle - bigger for visibility
                    ctx.fillStyle = theory.particle ? theory.particle.color : 
                                  (theory.status === 'failed' ? colors.danger :
                                    theory.status === 'passed' ? colors.success : 
                                    colors.accent);
                    ctx.beginPath();
                    ctx.arc(theory.x, theory.y, 12, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // White border for contrast
                    ctx.strokeStyle = colors.paper;
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    
                    // Label inside particle
                    ctx.fillStyle = colors.paper;
                    ctx.font = 'bold 10px JetBrains Mono, monospace';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(theory.label, theory.x, theory.y);
                    
                    // Show fail reason - keep visible even after falling
                    if (theory.status === 'failed') {
                        ctx.fillStyle = colors.paper + 'E0';
                        const textWidth = ctx.measureText(theory.failReason).width;
                        ctx.fillRect(theory.x + 15, theory.y - 10, textWidth + 6, 20);
                        
                        ctx.font = '12px JetBrains Mono, monospace';
                        ctx.fillStyle = colors.danger;
                        ctx.textAlign = 'left';
                        ctx.fillText(theory.failReason, theory.x + 18, theory.y);
                    }
                    
                    // Highlight T1 (Photon) with a subtle glow when it's about to succeed
                    if (theory.label === 'T1' && theory.x > 700 && theory.status === 'pending') {
                        ctx.strokeStyle = colors.quantum + '40';
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.arc(theory.x, theory.y, 18, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // Small indicator that this one will pass
                        ctx.font = '10px EB Garamond, serif';
                        ctx.fillStyle = colors.success;
                        ctx.textAlign = 'center';
                        ctx.fillText('â†’', theory.x - 25, theory.y);
                    }
                    
                    // Add particle type label below
                    ctx.fillStyle = colors.ink;
                    ctx.font = '10px JetBrains Mono, monospace';
                    ctx.textAlign = 'center';
                    ctx.fillText(theory.particle.symbol, theory.x, theory.y + 20);
                    
                    ctx.restore();
                });
                
                // Draw failed theories graveyard
                ctx.fillStyle = colors.danger + '10';
                ctx.fillRect(0, 300, validationGauntletCanvas.width, 100);
                
                // Graveyard label
                ctx.font = '14px EB Garamond, serif';
                ctx.fillStyle = colors.muted;
                ctx.textAlign = 'left';
                ctx.fillText('Failed Theories Graveyard', 50, 320);
                
                // Particle type legend on the right
                ctx.fillStyle = colors.paper + 'F0';
                ctx.fillRect(validationGauntletCanvas.width - 220, 150, 200, 240);
                ctx.strokeStyle = colors.codeBorder;
                ctx.lineWidth = 1;
                ctx.strokeRect(validationGauntletCanvas.width - 220, 150, 200, 240);
                
                ctx.font = 'bold 14px EB Garamond, serif';
                ctx.fillStyle = colors.ink;
                ctx.textAlign = 'center';
                ctx.fillText('Particle Types', validationGauntletCanvas.width - 120, 175);
                
                ctx.font = '12px EB Garamond, serif';
                ctx.textAlign = 'left';
                
                // Draw particle legend
                particleTypes.forEach((particle, i) => {
                    const y = 200 + i * 22;
                    
                    // Particle circle
                    ctx.fillStyle = particle.color;
                    ctx.beginPath();
                    ctx.arc(validationGauntletCanvas.width - 190, y, 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Particle symbol and name
                    ctx.fillStyle = colors.ink;
                    ctx.font = 'bold 11px JetBrains Mono, monospace';
                    ctx.fillText(particle.symbol, validationGauntletCanvas.width - 165, y + 3);
                    ctx.font = '11px EB Garamond, serif';
                    ctx.fillText(particle.name, validationGauntletCanvas.width - 140, y + 3);
                });
                
                // Note about test results
                ctx.fillStyle = colors.muted;
                ctx.font = 'italic 11px EB Garamond, serif';
                ctx.textAlign = 'center';
                ctx.fillText('Testing from @particles.json', validationGauntletCanvas.width - 120, 370);
                
                // Reset when all theories processed
                if (theories.every(t => t.status !== 'pending' || t.x > validationGauntletCanvas.width)) {
                    theories = [];
                    for (let i = 0; i < 8; i++) {
                        theories.push({
                            id: i,
                            x: -50 - (i * 30),
                            y: 80 + (i % 3) * 20,
                            status: 'pending',
                            failReason: null,
                            tests: 0,
                            opacity: 1,
                            label: `T${i + 1}`,
                            particle: particleTypes[i]  // New: assign particle type
                        });
                    }
                    // Keep only recent failed theories
                    if (failedTheories.length > 30) {
                        failedTheories = failedTheories.slice(-30);
                    }
                }
                
                animationTime++;
                requestAnimationFrame(drawValidationGauntlet);
            }
            
            drawValidationGauntlet();
        }

        // Spacetime Curvature Visualization
        const spacetimeCanvas = document.getElementById('spacetimeCanvas');
        const isMobile = window.innerWidth <= 768;
        
        // Skip canvas animation on mobile for performance
        if (spacetimeCanvas && !isMobile) {
            const spacetimeCtx = spacetimeCanvas.getContext('2d');
            let animationTime = 0;
            let scrollProgress = 0;
            let targetScrollProgress = 0;
            let mouseX = -100;
            let mouseY = -100;
            let ripples = [];
            
            function resizeSpacetimeCanvas() {
                spacetimeCanvas.width = window.innerWidth;
                spacetimeCanvas.height = window.innerHeight;
            }
            resizeSpacetimeCanvas();
            window.addEventListener('resize', resizeSpacetimeCanvas);
            
            // Update scroll progress
            function updateScrollProgress() {
                const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                const documentHeight = document.documentElement.scrollHeight - window.innerHeight;
                targetScrollProgress = Math.min(1, scrollTop / documentHeight);
            }
            window.addEventListener('scroll', updateScrollProgress);
            updateScrollProgress();
            
            // Mouse tracking
            let prevMouseX = -100;
            let prevMouseY = -100;
            let mouseVelocityX = 0;
            let mouseVelocityY = 0;
            
            spacetimeCanvas.addEventListener('mousemove', (e) => {
                const rect = spacetimeCanvas.getBoundingClientRect();
                const newMouseX = e.clientX - rect.left;
                const newMouseY = e.clientY - rect.top;
                
                if (prevMouseX > 0 && prevMouseY > 0) {
                    mouseVelocityX = newMouseX - prevMouseX;
                    mouseVelocityY = newMouseY - prevMouseY;
                }
                
                prevMouseX = mouseX;
                prevMouseY = mouseY;
                mouseX = newMouseX;
                mouseY = newMouseY;
                
                const speed = Math.sqrt(mouseVelocityX * mouseVelocityX + mouseVelocityY * mouseVelocityY);
                
                if (speed > 2 && Math.random() < 0.15) {
                    const angle = Math.atan2(mouseVelocityY, mouseVelocityX);
                    const distance = 30;
                    const rippleX = mouseX + Math.cos(angle) * distance;
                    const rippleY = mouseY + Math.sin(angle) * distance;
                    
                    ripples.push({
                        x: rippleX,
                        y: rippleY,
                        radius: 0,
                        maxRadius: 150 + speed * 5,
                        strength: 0.4 + Math.min(speed * 0.02, 0.4),
                        speed: 2 + speed * 0.1,
                        decay: 0.98,
                        directionX: mouseVelocityX / speed,
                        directionY: mouseVelocityY / speed
                    });
                }
            });
            
            spacetimeCanvas.addEventListener('mouseleave', () => {
                mouseX = -100;
                mouseY = -100;
            });
            
            spacetimeCanvas.addEventListener('click', (e) => {
                const rect = spacetimeCanvas.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const clickY = e.clientY - rect.top;
                
                ripples.push({
                    x: clickX,
                    y: clickY,
                    radius: 0,
                    maxRadius: 300,
                    strength: 0.8,
                    speed: 2.5,
                    decay: 0.97
                });
                
                if (ripples.length > 10) {
                    ripples = ripples.slice(-10);
                }
            });
            
            function updatePositions() {
                scrollProgress += (targetScrollProgress - scrollProgress) * 0.1;
                
                ripples = ripples.filter(ripple => {
                    ripple.radius += ripple.speed;
                    ripple.strength *= ripple.decay;
                    return ripple.strength > 0.02 && ripple.radius < ripple.maxRadius;
                });
                
                if (ripples.length > 5) {
                    ripples.sort((a, b) => b.strength - a.strength);
                    ripples = ripples.slice(0, 5);
                }
            }
            
            function calculateWarp(x, y) {
                let warpX = 0;
                let warpY = 0;
                
                const centerX = spacetimeCanvas.width / 2;
                const centerY = spacetimeCanvas.height * 1.2;
                const dx = x - centerX;
                const dy = y - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                const breathingIntensity = 30 + scrollProgress * 50;
                const breathingWarp = Math.sin(animationTime * 0.002) * breathingIntensity;
                const radialBreathing = (1 - Math.min(1, distance / 1000)) * breathingWarp;
                
                if (distance > 0) {
                    warpX += (dx / distance) * radialBreathing * 0.3;
                    warpY += (dy / distance) * radialBreathing * 0.3;
                    
                    if (scrollProgress > 0.001) {
                        const scrollIntensity = 1200 * Math.pow(scrollProgress, 0.8);
                        const maxDistance = 2000;
                        const normalizedDistance = Math.min(distance / maxDistance, 1);
                        const falloff = Math.pow(1 - normalizedDistance, 1.2);
                        const warpStrength = scrollIntensity * falloff;
                        const angle = Math.atan2(dy, dx);
                        const radialPull = warpStrength * 1.5;
                        warpX = -Math.cos(angle) * radialPull;
                        warpY = -Math.sin(angle) * radialPull;
                    }
                }
                
                if (mouseX > 0 && mouseY > 0) {
                    const mouseDx = x - mouseX;
                    const mouseDy = y - mouseY;
                    const mouseDistance = Math.sqrt(mouseDx * mouseDx + mouseDy * mouseDy);
                    if (mouseDistance > 0 && mouseDistance < 80) {
                        const mouseWarp = (1 - mouseDistance / 80) * 10;
                        warpX += (mouseDx / mouseDistance) * mouseWarp;
                        warpY += (mouseDy / mouseDistance) * mouseWarp;
                    }
                }
                
                ripples.forEach(ripple => {
                    const rippleDx = x - ripple.x;
                    const rippleDy = y - ripple.y;
                    const rippleDistance = Math.sqrt(rippleDx * rippleDx + rippleDy * rippleDy);
                    
                    const waveWidth = 20; // More frequent ripples
                    if (rippleDistance > ripple.radius - waveWidth && rippleDistance < ripple.radius + waveWidth) {
                        const ripplePhase = (rippleDistance - ripple.radius) / waveWidth;
                        const rippleStrength = Math.cos(ripplePhase * Math.PI) * ripple.strength * 30;
                        
                        if (rippleDistance > 0 && ripple.strength > 0.02) {
                            const radialFactor = 0.7;
                            const directionalFactor = 0.3;
                            const radialX = (rippleDx / rippleDistance) * rippleStrength * radialFactor;
                            const radialY = (rippleDy / rippleDistance) * rippleStrength * radialFactor;
                            let dirX = 0, dirY = 0;
                            if (ripple.directionX && ripple.directionY) {
                                dirX = ripple.directionX * rippleStrength * directionalFactor;
                                dirY = ripple.directionY * rippleStrength * directionalFactor;
                            }
                            warpX += radialX + dirX;
                            warpY += radialY + dirY;
                        }
                    }
                });
                
                return { warpX, warpY };
            }
            
            // Wave propagation state
            let wavePhase = 0;
            let waveStrength = 0;
            let wavePhase2 = 0;
            let waveOriginX = 0;
            let waveOriginY = 0;
            let rippleTime = 0;
            let activeRipple = null;
            
            function drawSpacetimeGrid() {
                const gridSize = 40;
                const edgeExtension = 400;
                const centerX = spacetimeCanvas.width / 2;
                const gridOffsetX = (centerX % gridSize) - gridSize / 2;
                
                // Smooth continuous wave animation
                wavePhase += 0.015;
                wavePhase2 += 0.008;
                rippleTime += 0.02;
                
                // Create smooth, continuous wave strength variations
                const wave1 = Math.sin(wavePhase * 0.3) * 0.5 + 0.5;
                const wave2 = Math.sin(wavePhase2 * 0.2) * 0.5 + 0.5;
                waveStrength = (wave1 * 0.7 + wave2 * 0.3) * 0.3; // Base wave strength
                
                // Slowly moving wave origin for more organic feel
                waveOriginX = centerX + Math.sin(wavePhase * 0.1) * 200;
                waveOriginY = spacetimeCanvas.height / 2 + Math.cos(wavePhase * 0.15) * 100;
                
                // Ripple effect every 5 seconds
                if (rippleTime > 5 && !activeRipple) {
                    rippleTime = 0; // Reset timer
                    activeRipple = {
                        x: centerX + (Math.random() - 0.5) * 400,
                        y: spacetimeCanvas.height / 2 + (Math.random() - 0.5) * 200,
                        radius: 0,
                        maxRadius: 600,
                        speed: 3,
                        strength: 1
                    };
                }
                
                if (activeRipple) {
                    activeRipple.radius += activeRipple.speed;
                    activeRipple.strength = 1 - (activeRipple.radius / activeRipple.maxRadius);
                    if (activeRipple.radius > activeRipple.maxRadius) {
                        activeRipple = null;
                    }
                }
                
                // Vertical grid lines
                for (let x = -edgeExtension + gridOffsetX; x <= spacetimeCanvas.width + edgeExtension; x += gridSize) {
                    spacetimeCtx.beginPath();
                    let firstPoint = true;
                    
                    // Calculate distance from wave origin for radial wave effect
                    const distFromWave = Math.sqrt(Math.pow(x - waveOriginX, 2) + Math.pow(spacetimeCanvas.height/2 - waveOriginY, 2));
                    const waveRadial = Math.sin(distFromWave * 0.015 - wavePhase * 2) * 0.5 + 0.5; // More frequent waves
                    
                    // Calculate base grid line brightness
                    const baseBrightness = 0.1; // Slightly brighter base
                    
                    // Add smooth wave effect
                    const waveEffect = waveStrength * waveRadial * 0.15; // More visible waves
                    let brightness = baseBrightness + waveEffect;
                    
                    // Check for ripple effect
                    let rippleGlow = 0;
                    if (activeRipple) {
                        const rippleDist = Math.sqrt(Math.pow(x - activeRipple.x, 2) + Math.pow(spacetimeCanvas.height/2 - activeRipple.y, 2));
                        const rippleWidth = 30; // Tighter ripple bands
                        if (Math.abs(rippleDist - activeRipple.radius) < rippleWidth) {
                            const ripplePhase = 1 - Math.abs(rippleDist - activeRipple.radius) / rippleWidth;
                            rippleGlow = ripplePhase * activeRipple.strength * 0.3;
                            brightness += rippleGlow;
                        }
                    }
                    
                    // More blue color with ripple glow
                    const blueAmount = 0.4 + waveEffect * 0.2 + rippleGlow * 0.3; // 40-70% blue
                    const grayAmount = 1 - blueAmount;
                    spacetimeCtx.strokeStyle = `rgba(${45 * grayAmount + 26 * blueAmount}, ${45 * grayAmount + 58 * blueAmount}, ${45 * grayAmount + 138 * blueAmount}, ${brightness})`;
                    spacetimeCtx.lineWidth = 1 + waveEffect * 0.5 + rippleGlow * 1.5; // Glow on ripple
                    
                    for (let y = -edgeExtension; y <= spacetimeCanvas.height + edgeExtension; y += 10) {
                        const { warpX, warpY } = calculateWarp(x, y);
                        const finalX = x + warpX;
                        const finalY = y + warpY;
                        
                        if (finalX < -edgeExtension * 2 || finalX > spacetimeCanvas.width + edgeExtension * 2 || 
                            finalY < -edgeExtension * 2 || finalY > spacetimeCanvas.height + edgeExtension * 2) {
                            continue;
                        }
                        
                        if (firstPoint) {
                            spacetimeCtx.moveTo(finalX, finalY);
                            firstPoint = false;
                        } else {
                            spacetimeCtx.lineTo(finalX, finalY);
                        }
                    }
                    spacetimeCtx.stroke();
                }
                
                const centerY = spacetimeCanvas.height / 2;
                const gridOffsetY = (centerY % gridSize) - gridSize / 2;
                
                // Horizontal grid lines
                for (let y = -edgeExtension + gridOffsetY; y <= spacetimeCanvas.height + edgeExtension; y += gridSize) {
                    spacetimeCtx.beginPath();
                    let firstPoint = true;
                    
                    // Calculate distance from wave origin for radial wave effect
                    const distFromWave = Math.sqrt(Math.pow(spacetimeCanvas.width/2 - waveOriginX, 2) + Math.pow(y - waveOriginY, 2));
                    const waveRadial = Math.sin(distFromWave * 0.005 - wavePhase * 2 + Math.PI/4) * 0.5 + 0.5; // Phase offset for variety
                    
                    // Calculate base grid line brightness
                    const baseBrightness = 0.1; // Slightly brighter base
                    
                    // Add smooth wave effect
                    const waveEffect = waveStrength * waveRadial * 0.15; // More visible waves
                    let brightness = baseBrightness + waveEffect;
                    
                    // Check for ripple effect
                    let rippleGlow = 0;
                    if (activeRipple) {
                        const rippleDist = Math.sqrt(Math.pow(spacetimeCanvas.width/2 - activeRipple.x, 2) + Math.pow(y - activeRipple.y, 2));
                        const rippleWidth = 30; // Tighter ripple bands
                        if (Math.abs(rippleDist - activeRipple.radius) < rippleWidth) {
                            const ripplePhase = 1 - Math.abs(rippleDist - activeRipple.radius) / rippleWidth;
                            rippleGlow = ripplePhase * activeRipple.strength * 0.3;
                            brightness += rippleGlow;
                        }
                    }
                    
                    // More blue color with ripple glow
                    const blueAmount = 0.4 + waveEffect * 0.2 + rippleGlow * 0.3; // 40-70% blue
                    const grayAmount = 1 - blueAmount;
                    spacetimeCtx.strokeStyle = `rgba(${45 * grayAmount + 26 * blueAmount}, ${45 * grayAmount + 58 * blueAmount}, ${45 * grayAmount + 138 * blueAmount}, ${brightness})`;
                    spacetimeCtx.lineWidth = 1 + waveEffect * 0.5 + rippleGlow * 1.5; // Glow on ripple
                    
                    for (let x = -edgeExtension; x <= spacetimeCanvas.width + edgeExtension; x += 10) {
                        const { warpX, warpY } = calculateWarp(x, y);
                        const finalX = x + warpX;
                        const finalY = y + warpY;
                        
                        if (finalX < -edgeExtension * 2 || finalX > spacetimeCanvas.width + edgeExtension * 2 || 
                            finalY < -edgeExtension * 2 || finalY > spacetimeCanvas.height + edgeExtension * 2) {
                            continue;
                        }
                        
                        if (firstPoint) {
                            spacetimeCtx.moveTo(finalX, finalY);
                            firstPoint = false;
                        } else {
                            spacetimeCtx.lineTo(finalX, finalY);
                        }
                    }
                    spacetimeCtx.stroke();
                }
                
                // Draw light effects at grid intersections - especially during ripples
                if (waveStrength > 0.05 || activeRipple) {
                    // Draw on every 2nd intersection
                    for (let x = -edgeExtension + gridOffsetX; x <= spacetimeCanvas.width + edgeExtension; x += gridSize * 2) {
                        for (let y = -edgeExtension + gridOffsetY; y <= spacetimeCanvas.height + edgeExtension; y += gridSize * 2) {
                            const { warpX, warpY } = calculateWarp(x, y);
                            const finalX = x + warpX;
                            const finalY = y + warpY;
                            
                            // Calculate distance from wave origin
                            const dist = Math.sqrt(Math.pow(finalX - waveOriginX, 2) + Math.pow(finalY - waveOriginY, 2));
                            const radialFactor = Math.exp(-dist * dist / (300000)); // Gaussian falloff
                            
                            // Base pulse intensity
                            const pulseBase = Math.sin(dist * 0.01 - wavePhase * 3) * 0.5 + 0.5;
                            let pulseIntensity = waveStrength * radialFactor * pulseBase * 0.1;
                            
                            // Ripple glow at intersections
                            if (activeRipple) {
                                const rippleDist = Math.sqrt(Math.pow(finalX - activeRipple.x, 2) + Math.pow(finalY - activeRipple.y, 2));
                                const rippleWidth = 80;
                                if (Math.abs(rippleDist - activeRipple.radius) < rippleWidth) {
                                    const ripplePhase = 1 - Math.abs(rippleDist - activeRipple.radius) / rippleWidth;
                                    const rippleIntensity = ripplePhase * activeRipple.strength * 0.6;
                                    pulseIntensity = Math.max(pulseIntensity, rippleIntensity);
                                    
                                    // Brighter blue during ripple - REMOVED for cleaner wave effect
                                    // if (rippleIntensity > 0.1) {
                                    //     spacetimeCtx.fillStyle = `rgba(59, 130, 246, ${rippleIntensity * 0.7})`;
                                    //     spacetimeCtx.beginPath();
                                    //     spacetimeCtx.arc(finalX, finalY, 2 + rippleIntensity * 6, 0, Math.PI * 2);
                                    //     spacetimeCtx.fill();
                                    // }
                                }
                            }
                            
                            // Regular subtle glow - REMOVED for cleaner wave effect
                            // if (pulseIntensity > 0.02 && !activeRipple) {
                            //     spacetimeCtx.fillStyle = `rgba(26, 58, 138, ${pulseIntensity})`;
                            //     spacetimeCtx.beginPath();
                            //     spacetimeCtx.arc(finalX, finalY, 1 + pulseIntensity * 4, 0, Math.PI * 2);
                            //     spacetimeCtx.fill();
                            // }
                        }
                    }
                }
            }
            
            function drawCursor() {
      
                if (mouseX > 0 && mouseY > 0) {
                    spacetimeCtx.strokeStyle = 'rgba(45, 45, 45, 0.15)';
                    spacetimeCtx.lineWidth = 1;
                    spacetimeCtx.beginPath();
                    spacetimeCtx.arc(mouseX, mouseY, 20, 0, Math.PI * 2);
                    spacetimeCtx.stroke();
                    
                    spacetimeCtx.beginPath();
                    spacetimeCtx.arc(mouseX, mouseY, 5, 0, Math.PI * 2);
                    spacetimeCtx.fillStyle = 'rgba(45, 45, 45, 0.25)';
                    spacetimeCtx.fill();
                }
            }
            
            function animateSpacetime() {
                animationTime++;
                
                spacetimeCtx.fillStyle = colors.paper;
                spacetimeCtx.fillRect(0, 0, spacetimeCanvas.width, spacetimeCanvas.height);
                
                updatePositions();
                drawSpacetimeGrid();
                drawCursor();
                
                const fadeHeight = 200;
                const fadeStart = spacetimeCanvas.height - fadeHeight;
                
                // Convert paper color to RGB values for gradient
                const paperRGB = '250, 248, 243'; // This should match colors.paper (#FAF8F3)
                const gradient = spacetimeCtx.createLinearGradient(0, fadeStart, 0, spacetimeCanvas.height + 50);
                gradient.addColorStop(0, `rgba(${paperRGB}, 0)`);
                gradient.addColorStop(0.5, `rgba(${paperRGB}, 0.5)`);
                gradient.addColorStop(0.8, `rgba(${paperRGB}, 0.9)`);
                gradient.addColorStop(1, `rgba(${paperRGB}, 1)`);
                
                spacetimeCtx.fillStyle = gradient;
                spacetimeCtx.fillRect(0, fadeStart, spacetimeCanvas.width, fadeHeight + 50);
                
                requestAnimationFrame(animateSpacetime);
            }
            
            animateSpacetime();
        }

        // Add this function after the existing copyInstallCommand() function (around line 2270):

        function copyModalCommand() {
            const command = document.getElementById('modal-install-command').textContent;
            navigator.clipboard.writeText(command).then(() => {
                // Show check icon
                document.getElementById('modal-copy-icon').classList.add('hidden');
                document.getElementById('modal-check-icon').classList.remove('hidden');
                
                // Show tooltip
                const tooltip = document.getElementById('modal-copy-tooltip');
                tooltip.classList.remove('opacity-0');
                
                // Reset after 2 seconds
                setTimeout(() => {
                    document.getElementById('modal-copy-icon').classList.remove('hidden');
                    document.getElementById('modal-check-icon').classList.add('hidden');
                    tooltip.classList.add('opacity-0');
                }, 2000);
            });
        }
        
        // Toggle Mathematical Foundation details
        function toggleMathDetails() {
            const details = document.getElementById('math-details');
            const chevron = document.getElementById('math-chevron');
            
            if (details.style.maxHeight === '0px' || !details.style.maxHeight) {
                details.style.maxHeight = details.scrollHeight + 'px';
                chevron.style.transform = 'rotate(180deg)';
            } else {
                details.style.maxHeight = '0px';
                chevron.style.transform = 'rotate(0deg)';
            }
        }
        
        // Toggle Clock experiment details
        function toggleClockDetails() {
            const details = document.getElementById('clock-details');
            
            if (details.style.maxHeight === '0px' || !details.style.maxHeight) {
                details.style.maxHeight = details.scrollHeight + 'px';
            } else {
                details.style.maxHeight = '0px';
            }
        }
        
        // Toggle Einstein note details
        function toggleEinsteinDetail(id) {
            const details = document.getElementById(id + '-detail');
            const allDetails = document.querySelectorAll('[id$="-detail"]');
            
            // Hide all other details
            allDetails.forEach(detail => {
                if (detail.id !== id + '-detail' && detail.id.includes('einstein-')) {
                    detail.classList.add('hidden');
                }
            });
            
            // Toggle the clicked detail
            details.classList.toggle('hidden');
        }
        
        // Toggle UGM section
        function toggleUGMSection() {
            const content = document.getElementById('ugm-content');
            const chevron = document.getElementById('ugm-chevron');
            
            if (content.style.maxHeight === '0px' || content.style.maxHeight === '') {
                // Open the section
                content.style.maxHeight = content.scrollHeight + 'px';
                chevron.style.transform = 'rotate(180deg)';
            } else {
                // Close the section
                content.style.maxHeight = '0';
                chevron.style.transform = 'rotate(0deg)';
            }
        }
        
        // Toggle Standard Model section
        function toggleStandardModelSection() {
            const content = document.getElementById('sm-content');
            const chevron = document.getElementById('sm-chevron');
            
            if (content.style.maxHeight === '0px' || content.style.maxHeight === '') {
                // Open the section
                content.style.maxHeight = content.scrollHeight + 'px';
                chevron.style.transform = 'rotate(180deg)';
            } else {
                // Close the section
                content.style.maxHeight = '0';
                chevron.style.transform = 'rotate(0deg)';
            }
        }
        
        // Toggle Physics Engine section
        function togglePhysicsEngineSection() {
            const content = document.getElementById('physics-engine-content');
            const chevron = document.getElementById('physics-engine-chevron');
            
            if (content.style.maxHeight === '0px' || content.style.maxHeight === '') {
                // Open the section
                content.style.maxHeight = content.scrollHeight + 'px';
                chevron.style.transform = 'rotate(180deg)';
            } else {
                // Close the section
                content.style.maxHeight = '0';
                chevron.style.transform = 'rotate(0deg)';
            }
        }
        
        // Toggle Future Vision section
        function toggleFutureVisionSection() {
            const content = document.getElementById('future-vision-content');
            const chevron = document.getElementById('future-vision-chevron');
            
            if (content.style.maxHeight === '0px' || content.style.maxHeight === '') {
                // Open the section
                content.style.maxHeight = content.scrollHeight + 'px';
                chevron.style.transform = 'rotate(180deg)';
            } else {
                // Close the section
                content.style.maxHeight = '0';
                chevron.style.transform = 'rotate(0deg)';
            }
        }
        
        // Toggle clock details
        function toggleClockDetails() {
            const details = document.getElementById('clock-details');
            if (details.style.maxHeight === '0px' || details.style.maxHeight === '') {
                details.style.maxHeight = details.scrollHeight + 'px';
            } else {
                details.style.maxHeight = '0';
            }
        }
        
        // Quantum Validator Visualization
        const quantumValidatorCanvas = document.getElementById('quantumValidatorCanvas');
        if (quantumValidatorCanvas) {
            const ctx = quantumValidatorCanvas.getContext('2d');
            let animationTime = 0;
            
            function drawQuantumValidator() {
                ctx.clearRect(0, 0, quantumValidatorCanvas.width, quantumValidatorCanvas.height);
                
                // Background
                ctx.fillStyle = colors.canvasBg;
                ctx.fillRect(0, 0, quantumValidatorCanvas.width, quantumValidatorCanvas.height);
                
                // Draw atomic clock setup
                const centerX = quantumValidatorCanvas.width / 2;
                const bottomY = quantumValidatorCanvas.height - 40;
                const topY = 60;
                const heightDiff = bottomY - topY;
                
                // Ground level
                ctx.strokeStyle = colors.codeBorder;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(20, bottomY);
                ctx.lineTo(quantumValidatorCanvas.width - 20, bottomY);
                ctx.stroke();
                
                // Height marker
                ctx.strokeStyle = colors.muted;
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.moveTo(40, topY);
                ctx.lineTo(40, bottomY);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Height label
                ctx.font = '12px JetBrains Mono, monospace';
                ctx.fillStyle = colors.muted;
                ctx.textAlign = 'center';
                ctx.save();
                ctx.translate(25, (topY + bottomY) / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText('33 cm', 0, 0);
                ctx.restore();
                
                // Lower clock
                const clockRadius = 30;
                ctx.fillStyle = colors.codeBg;
                ctx.strokeStyle = colors.accent;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(centerX, bottomY - clockRadius - 10, clockRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                // Upper clock
                ctx.fillStyle = colors.codeBg;
                ctx.strokeStyle = colors.quantum;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(centerX, topY + clockRadius + 10, clockRadius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                // Clock faces (simplified)
                ctx.fillStyle = colors.ink;
                ctx.font = '16px JetBrains Mono, monospace';
                ctx.textAlign = 'center';
                ctx.fillText('âš›', centerX, bottomY - clockRadius - 5);
                ctx.fillText('âš›', centerX, topY + clockRadius + 15);
                
                // Gravitational field lines (subtle)
                ctx.strokeStyle = colors.codeBorder + '40';
                ctx.lineWidth = 1;
                for (let i = 0; i < 5; i++) {
                    const y = bottomY - i * 40;
                    const curve = Math.sin(animationTime * 0.02) * 5;
                    ctx.beginPath();
                    ctx.moveTo(60, y);
                    ctx.quadraticCurveTo(centerX + curve, y - 10, quantumValidatorCanvas.width - 60, y);
                    ctx.stroke();
                }
                
                // Frequency shift visualization
                const waveStartX = centerX + clockRadius + 40;
                const waveEndX = quantumValidatorCanvas.width - 40;
                const waveWidth = waveEndX - waveStartX;
                
                // Lower clock wave (reference)
                ctx.strokeStyle = colors.accent;
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let x = 0; x <= waveWidth; x++) {
                    const phase = x * 0.05 + animationTime * 0.05;
                    const y = bottomY - clockRadius - 10 + Math.sin(phase) * 15;
                    if (x === 0) {
                        ctx.moveTo(waveStartX + x, y);
                    } else {
                        ctx.lineTo(waveStartX + x, y);
                    }
                }
                ctx.stroke();
                
                // Upper clock wave (shifted)
                ctx.strokeStyle = colors.quantum;
                ctx.lineWidth = 2;
                ctx.beginPath();
                for (let x = 0; x <= waveWidth; x++) {
                    // Slightly higher frequency due to gravitational time dilation
                    const phase = x * 0.0501 + animationTime * 0.0501; // 0.02% shift
                    const y = topY + clockRadius + 10 + Math.sin(phase) * 15;
                    if (x === 0) {
                        ctx.moveTo(waveStartX + x, y);
                    } else {
                        ctx.lineTo(waveStartX + x, y);
                    }
                }
                ctx.stroke();
                
                // Phase difference indicator
                if (animationTime > 60) {
                    const phaseX = waveStartX + waveWidth * 0.7;
                    
                    // Vertical line showing phase shift
                    ctx.strokeStyle = colors.warning;
                    ctx.lineWidth = 1;
                    ctx.setLineDash([2, 2]);
                    ctx.beginPath();
                    ctx.moveTo(phaseX, topY + clockRadius + 25);
                    ctx.lineTo(phaseX, bottomY - clockRadius - 25);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Label
                    ctx.font = '11px EB Garamond, serif';
                    ctx.fillStyle = colors.warning;
                    ctx.textAlign = 'left';
                    ctx.fillText('Î”f/f = 3.61Ã—10â»Â¹â·', phaseX + 10, (topY + bottomY) / 2);
                }
                
                // Labels
                ctx.font = '12px EB Garamond, serif';
                ctx.fillStyle = colors.ink;
                ctx.textAlign = 'center';
                ctx.fillText('Lower clock', centerX, bottomY + 25);
                ctx.fillText('Upper clock', centerX, topY - 10);
                
                animationTime++;
                requestAnimationFrame(drawQuantumValidator);
            }
            
            drawQuantumValidator();
        }
        
        // Demo Video Autoplay on Scroll
        document.addEventListener('DOMContentLoaded', function() {
            const video = document.getElementById('demoVideo');
            if (!video) return;
            
            // Create intersection observer for autoplay
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        // Video is in viewport - play it
                        video.play().catch(e => {
                            console.log('Autoplay prevented:', e);
                        });
                    } else {
                        // Video is out of viewport - pause it
                        video.pause();
                    }
                });
            }, {
                threshold: 0.5 // Trigger when 50% of video is visible
            });
            
            // Start observing the video
            observer.observe(video);
            
            // Add smooth fade-in effect when video loads
            video.addEventListener('loadeddata', function() {
                video.style.opacity = '0';
                video.style.transition = 'opacity 0.5s ease-in-out';
                setTimeout(() => {
                    video.style.opacity = '1';
                }, 100);
            });
        });
    </script>

</body>
</html> 
